root level build.gradle.kts: 

plugins {
    // this is necessary to avoid the plugins to be loaded multiple times
    // in each subproject's classloader
    alias(libs.plugins.androidApplication) apply false
    alias(libs.plugins.androidLibrary) apply false
    alias(libs.plugins.composeMultiplatform) apply false
    alias(libs.plugins.composeCompiler) apply false
    alias(libs.plugins.kotlinMultiplatform) apply false
}

------------

app level build.gradle.kts: 

import org.jetbrains.compose.desktop.application.dsl.TargetFormat
import org.jetbrains.kotlin.gradle.ExperimentalKotlinGradlePluginApi
import org.jetbrains.kotlin.gradle.dsl.JvmTarget

plugins {
    alias(libs.plugins.kotlinMultiplatform)
    alias(libs.plugins.androidApplication)
    alias(libs.plugins.composeMultiplatform)
    alias(libs.plugins.composeCompiler)
}

kotlin {
    androidTarget {
        @OptIn(ExperimentalKotlinGradlePluginApi::class)
        compilerOptions {
            jvmTarget.set(JvmTarget.JVM_11)
        }
    }
    
    listOf(
        iosX64(),
        iosArm64(),
        iosSimulatorArm64()
    ).forEach { iosTarget ->
        iosTarget.binaries.framework {
            baseName = "ComposeApp"
            isStatic = true
        }
    }
    
    sourceSets {
        androidMain.dependencies {
            implementation(compose.preview)
            implementation(libs.androidx.activity.compose)
        }
        commonMain.dependencies {
            implementation(compose.runtime)
            implementation(compose.foundation)
            implementation(compose.material)
            implementation(compose.ui)
            implementation(compose.components.resources)
            implementation(compose.components.uiToolingPreview)
            implementation(libs.androidx.lifecycle.viewmodel)
            implementation(libs.androidx.lifecycle.runtime.compose)
        }
    }
}

android {
    namespace = "com.openparty.app"
    compileSdk = libs.versions.android.compileSdk.get().toInt()

    defaultConfig {
        applicationId = "com.openparty.app"
        minSdk = libs.versions.android.minSdk.get().toInt()
        targetSdk = libs.versions.android.targetSdk.get().toInt()
        versionCode = 1
        versionName = "1.0"
    }
    packaging {
        resources {
            excludes += "/META-INF/{AL2.0,LGPL2.1}"
        }
    }
    buildTypes {
        getByName("release") {
            isMinifyEnabled = false
        }
    }
    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_11
        targetCompatibility = JavaVersion.VERSION_11
    }
}

dependencies {
    debugImplementation(compose.uiTooling)
}


------------

package com.openparty.app

import android.app.Application
import com.google.firebase.FirebaseApp
import com.google.firebase.ktx.Firebase
import com.google.firebase.firestore.ktx.firestore
import dagger.hilt.android.HiltAndroidApp
import timber.log.Timber

@HiltAndroidApp
class OpenPartyApp : Application() {
    override fun onCreate() {
        super.onCreate()

        if (BuildConfig.DEBUG) {
            Timber.plant(Timber.DebugTree())
        }

        FirebaseApp.initializeApp(this)
        val db = Firebase.firestore
    }
}

package com.openparty.app.navigation

import androidx.compose.runtime.Composable
import androidx.navigation.NavHostController
import androidx.navigation.NavType
import androidx.navigation.compose.NavHost
import androidx.navigation.compose.composable
import androidx.navigation.navArgument
import com.openparty.app.features.engagement.comments.feature_add_comment.presentation.AddCommentScreen
import com.openparty.app.features.newsfeed.council_meetings.feature_council_meetings_article.presentation.CouncilMeetingArticleScreen
import com.openparty.app.features.newsfeed.council_meetings.feature_council_meetings_preview.presentation.CouncilMeetingsPreviewScreen
import com.openparty.app.features.newsfeed.discussions.feature_add_discussion.presentation.AddDiscussionScreen
import com.openparty.app.features.newsfeed.discussions.feature_discussions_article.presentation.DiscussionArticleScreen
import com.openparty.app.features.newsfeed.discussions.feature_discussions_preview.presentation.DiscussionsPreviewScreen
import com.openparty.app.features.startup.account.feature_login.presentation.LoginScreen
import com.openparty.app.features.startup.account.feature_register.presentation.RegisterScreen
import com.openparty.app.features.startup.feature_screen_name_generation.presentation.ScreenNameGenerationScreen
import com.openparty.app.features.startup.feature_splash.presentation.SplashScreen
import com.openparty.app.features.startup.verification.feature_email_verification.presentation.EmailVerificationScreen
import com.openparty.app.features.startup.verification.feature_location_verification.presentation.LocationVerificationScreen
import com.openparty.app.features.startup.verification.feature_manual_verification.presentation.ManualVerificationScreen

@Composable
fun AppNavigation(navController: NavHostController) {
    NavHost(navController = navController, startDestination = NavDestinations.Splash.route) {
        composable(NavDestinations.Splash.route) { SplashScreen(navController = navController) }
        composable(NavDestinations.Login.route) { LoginScreen(navController = navController) }
        composable(NavDestinations.Register.route) { RegisterScreen(navController = navController) }
        composable(NavDestinations.EmailVerification.route) { EmailVerificationScreen(navController = navController) }
        composable(NavDestinations.LocationVerification.route) { LocationVerificationScreen(navController = navController) }
        composable(NavDestinations.ScreenNameGeneration.route) { ScreenNameGenerationScreen(navController = navController) }
        composable(NavDestinations.ManualVerification.route) { ManualVerificationScreen() }
        composable(NavDestinations.DiscussionsPreview.route) { DiscussionsPreviewScreen(navController = navController) }
        composable(
            route = "discussion_article/{discussionId}",
            arguments = listOf(navArgument("discussionId") { type = NavType.StringType })
        ) { DiscussionArticleScreen(navController = navController) }
        composable(NavDestinations.CouncilMeetingsPreview.route) { CouncilMeetingsPreviewScreen(navController = navController) }
        composable(
            route = "council_meetings_article/{councilMeetingId}",
            arguments = listOf(navArgument("councilMeetingId") { type = NavType.StringType })
        ) { CouncilMeetingArticleScreen(navController = navController) }
        composable(
            route = "add_comment_screen?discussionId={discussionId}&titleText={titleText}",
            arguments = listOf(
                navArgument("discussionId") { type = NavType.StringType; defaultValue = "" },
                navArgument("titleText") { type = NavType.StringType; defaultValue = "" }
            )
        ) { AddCommentScreen(navController = navController) }
        composable(NavDestinations.AddDiscussion.route) { AddDiscussionScreen(navController = navController) }
    }
}
package com.openparty.app.navigation

sealed class NavDestinations(val route: String) {
    object Loading : NavDestinations("loading")
    object Splash : NavDestinations("splash")
    object Login : NavDestinations("login")
    object Register : NavDestinations("register")
    object EmailVerification : NavDestinations("email_verification")
    object LocationVerification : NavDestinations("location_verification")
    object ScreenNameGeneration : NavDestinations("screen_name_generation")
    object ManualVerification : NavDestinations("manual_verification")
    object DiscussionsPreview : NavDestinations("discussions_preview")
    data class DiscussionsArticle(val discussionId: String) : NavDestinations("discussion_article/$discussionId")
    object CouncilMeetingsPreview : NavDestinations("council_meetings_preview")
    data class CouncilMeetingsArticle(val councilMeetingId: String) : NavDestinations("council_meetings_article/$councilMeetingId")
    object AddDiscussion : NavDestinations("add_discussion")
    data class AddComment(
        val discussionId: String,
        val titleText: String
    ) : NavDestinations("add_comment_screen?discussionId=$discussionId&titleText=$titleText")
    object Back : NavDestinations("back")
}
package com.openparty.app.main.di

import com.openparty.app.core.analytics.domain.usecase.TrackAppOpenedUseCase
import com.openparty.app.core.analytics.domain.usecase.IdentifyUserUseCase
import com.openparty.app.features.startup.feature_authentication.domain.usecase.GetCurrentUserIdUseCase
import com.openparty.app.main.MainViewModel
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.components.SingletonComponent
import javax.inject.Singleton

@Module
@InstallIn(SingletonComponent::class)
object MainModule {

    @Provides
    @Singleton
    fun provideMainViewModel(
        trackAppOpenedUseCase: TrackAppOpenedUseCase,
        identifyUserUseCase: IdentifyUserUseCase,
        getCurrentUserIdUseCase: GetCurrentUserIdUseCase
    ): MainViewModel {
        return MainViewModel(
            trackAppOpenedUseCase = trackAppOpenedUseCase,
            identifyUserUseCase = identifyUserUseCase,
            getCurrentUserIdUseCase = getCurrentUserIdUseCase
        )
    }
}
package com.openparty.app.main

import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Surface
import androidx.navigation.compose.rememberNavController
import com.openparty.app.navigation.AppNavigation
import com.openparty.app.ui.theme.OpenPartyTheme
import dagger.hilt.android.AndroidEntryPoint
import javax.inject.Inject

@AndroidEntryPoint
class MainActivity : ComponentActivity() {

    @Inject
    lateinit var mainViewModel: MainViewModel

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            OpenPartyTheme {
                Surface(color = MaterialTheme.colorScheme.background) {
                    val navController = rememberNavController()
                    AppNavigation(navController = navController)
                }
            }
        }
        mainViewModel.trackAppOpenedAndIdentifyUser()
    }

    override fun onResume() {
        super.onResume()
        mainViewModel.trackAppOpenedAndIdentifyUser()
    }
}
package com.openparty.app.main

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.openparty.app.core.analytics.domain.usecase.TrackAppOpenedUseCase
import com.openparty.app.core.analytics.domain.usecase.IdentifyUserUseCase
import com.openparty.app.core.shared.domain.DomainResult
import com.openparty.app.features.startup.feature_authentication.domain.usecase.GetCurrentUserIdUseCase
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.launch
import timber.log.Timber
import javax.inject.Inject

@HiltViewModel
class MainViewModel @Inject constructor(
    private val trackAppOpenedUseCase: TrackAppOpenedUseCase,
    private val identifyUserUseCase: IdentifyUserUseCase,
    private val getCurrentUserIdUseCase: GetCurrentUserIdUseCase
) : ViewModel() {

    fun trackAppOpenedAndIdentifyUser() {
        viewModelScope.launch {
            when (val userIdResult = getCurrentUserIdUseCase()) {
                is DomainResult.Success -> {
                    val userId = userIdResult.data
                    handleIdentifyUser(userId)
                    handleTrackAppOpened(userId)
                }
                is DomainResult.Failure -> {
                    handleTrackAppOpened(null)
                }
            }
        }
    }

    private suspend fun handleIdentifyUser(userId: String) {
        when (val identifyResult = identifyUserUseCase(userId)) {
            is DomainResult.Success -> Timber.i("User successfully identified: $userId")
            is DomainResult.Failure -> Timber.w("Failed to identify user: $userId")
        }
    }

    private suspend fun handleTrackAppOpened(userId: String?) {
        when (val trackResult = trackAppOpenedUseCase(userId)) {
            is DomainResult.Success -> Timber.i("App Opened event tracked for userId: $userId")
            is DomainResult.Failure -> Timber.w("Failed to track App Opened event for userId: $userId")
        }
    }
}
package com.openparty.app.di

import android.content.Context
import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.firestore.FirebaseFirestore
import com.openparty.app.core.storage.EncryptedSharedPreferencesSecureStorage
import com.openparty.app.core.storage.SecureStorage
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.android.qualifiers.ApplicationContext
import dagger.hilt.components.SingletonComponent
import javax.inject.Singleton

@Module
@InstallIn(SingletonComponent::class)
object AppModule {
    @Provides
    @Singleton
    fun provideFirebaseAuth(): FirebaseAuth {
        return FirebaseAuth.getInstance()
    }

    @Provides
    @Singleton
    fun provideFirebaseFirestore(): FirebaseFirestore {
        return FirebaseFirestore.getInstance()
    }

    @Provides
    @Singleton
    fun provideSecureStorage(
        @ApplicationContext context: Context
    ): SecureStorage {
        return EncryptedSharedPreferencesSecureStorage(context)
    }
}
package com.openparty.app.di

import com.openparty.app.core.storage.SecureStorage
import com.openparty.app.core.network.TokenInterceptor
import com.openparty.app.features.startup.feature_authentication.domain.usecase.RefreshAccessTokenUseCase
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.components.SingletonComponent
import okhttp3.OkHttpClient
import retrofit2.Retrofit
import retrofit2.converter.gson.GsonConverterFactory
import javax.inject.Singleton

@Module
@InstallIn(SingletonComponent::class)
object NetworkModule {
    @Provides
    @Singleton
    fun provideTokenInterceptor(
        secureStorage: SecureStorage,
        refreshAccessTokenUseCase: RefreshAccessTokenUseCase
    ): TokenInterceptor {
        return TokenInterceptor(secureStorage, refreshAccessTokenUseCase)
    }

    @Provides
    @Singleton
    fun provideOkHttpClient(
        tokenInterceptor: TokenInterceptor
    ): OkHttpClient {
        return OkHttpClient.Builder()
            .addInterceptor(tokenInterceptor)
            .build()
    }

    @Provides
    @Singleton
    fun provideRetrofit(
        client: OkHttpClient
    ): Retrofit {
        return Retrofit.Builder()
            .baseUrl("https://example.com/")
            .addConverterFactory(GsonConverterFactory.create())
            .client(client)
            .build()
    }
}
package com.openparty.app.features.startup.account.feature_login.di

import com.openparty.app.features.startup.account.feature_login.domain.usecase.PerformLoginUseCase
import com.openparty.app.features.startup.account.shared.domain.usecase.ValidateCredentialsUseCase
import com.openparty.app.features.startup.feature_authentication.domain.usecase.SignInUseCase
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.components.SingletonComponent
import javax.inject.Singleton

@Module
@InstallIn(SingletonComponent::class)
object LoginModule {

    @Provides
    @Singleton
    fun providePerformLoginUseCase(
        validateCredentialsUseCase: ValidateCredentialsUseCase,
        signInUseCase: SignInUseCase
    ): PerformLoginUseCase {
        return PerformLoginUseCase(validateCredentialsUseCase, signInUseCase)
    }
}

package com.openparty.app.features.startup.account.feature_login.domain.usecase

import com.openparty.app.core.shared.domain.DomainResult
import com.openparty.app.features.startup.account.shared.domain.usecase.ValidateCredentialsUseCase
import com.openparty.app.features.startup.feature_authentication.domain.usecase.SignInUseCase
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import timber.log.Timber
import javax.inject.Inject

class PerformLoginUseCase @Inject constructor(
    private val validateCredentialsUseCase: ValidateCredentialsUseCase,
    private val signInUseCase: SignInUseCase
) {
    suspend operator fun invoke(email: String, password: String): DomainResult<Unit> {
        Timber.i("PerformLoginUseCase invoked with email: $email")

        return withContext(Dispatchers.IO) {
            Timber.d("Validating credentials")
            when (val validationResult = validateCredentialsUseCase(email, password)) {
                is DomainResult.Failure -> {
                    Timber.e("Validation failed: ${validationResult.error}")
                    return@withContext validationResult
                }
                is DomainResult.Success -> {
                    Timber.i("Validation successful for email: $email")
                }
            }

            Timber.d("Attempting to sign in")
            when (val signInResult = signInUseCase(email, password)) {
                is DomainResult.Success -> {
                    Timber.i("Sign in successful for email: $email")
                    DomainResult.Success(Unit)
                }
                is DomainResult.Failure -> {
                    Timber.e("Sign in failed: ${signInResult.error}")
                    signInResult
                }
            }
        }
    }
}
package com.openparty.app.features.startup.account.feature_login.presentation

import androidx.compose.runtime.Composable
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.navigation.NavHostController
import com.openparty.app.features.startup.account.shared.presentation.AccountScreen

@Composable
fun LoginScreen(
    navController: NavHostController,
    viewModel: LoginViewModel = hiltViewModel()
) {
    AccountScreen(
        viewModel = viewModel,
        title = "Login",
        actionText = "Login",
        footerText = "Don't have an account? Register",
        onActionClick = { viewModel.onLoginButtonClick() },
        onFooterClick = { viewModel.onTextFooterClick() },
        uiEvent = viewModel.uiEvent,
        navController = navController
    )
}
package com.openparty.app.features.startup.account.feature_login.presentation

import androidx.lifecycle.viewModelScope
import com.openparty.app.core.shared.domain.DomainResult
import com.openparty.app.core.shared.domain.error.AppErrorMapper
import com.openparty.app.core.shared.presentation.UiEvent
import com.openparty.app.features.startup.account.feature_login.domain.usecase.PerformLoginUseCase
import com.openparty.app.features.startup.account.shared.presentation.AccountViewModel
import com.openparty.app.features.startup.account.shared.presentation.model.AccountUiStateUpdate
import com.openparty.app.features.startup.feature_authentication.domain.usecase.DetermineAuthStatesUseCase
import com.openparty.app.features.startup.feature_authentication.presentation.AuthFlowNavigationMapper
import com.openparty.app.navigation.NavDestinations
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.SharedFlow
import kotlinx.coroutines.launch
import javax.inject.Inject

@HiltViewModel
class LoginViewModel @Inject constructor(
    private val performLoginUseCase: PerformLoginUseCase,
    private val determineAuthStatesUseCase: DetermineAuthStatesUseCase,
    private val authFlowNavigationMapper: AuthFlowNavigationMapper
) : AccountViewModel() {

    private val _uiEvent = MutableSharedFlow<UiEvent>()
    val uiEvent: SharedFlow<UiEvent> = _uiEvent

    fun onLoginButtonClick() {
        viewModelScope.launch {
            updateState(AccountUiStateUpdate.UpdateLoading(true))
            val currentState = accountUiState.value

            when (val loginResult = performLoginUseCase(currentState.email, currentState.password)) {
                is DomainResult.Success -> {
                    when (val authStatesResult = determineAuthStatesUseCase()) {
                        is DomainResult.Success -> {
                            val destination = authFlowNavigationMapper.determineDestination(authStatesResult.data)
                            _uiEvent.emit(UiEvent.Navigate(destination))
                        }
                        is DomainResult.Failure -> {
                            val errorMessage = AppErrorMapper.getUserFriendlyMessage(authStatesResult.error)
                            updateState(AccountUiStateUpdate.UpdateError(errorMessage))
                        }
                    }
                }
                is DomainResult.Failure -> {
                    val errorMessage = AppErrorMapper.getUserFriendlyMessage(loginResult.error)
                    updateState(AccountUiStateUpdate.UpdateError(errorMessage))
                }
            }
            updateState(AccountUiStateUpdate.UpdateLoading(false))
        }
    }

    fun onTextFooterClick() {
        viewModelScope.launch {
            _uiEvent.emit(UiEvent.Navigate(NavDestinations.Register))
        }
    }

    fun clearError() {
        updateState(AccountUiStateUpdate.UpdateError(null))
    }
}


-----------------

Here is the rough package structure: 

OpenParty/
├── build.gradle.kts
├── gradle/
│   ├── libs.versions.toml
│   └── wrapper/
│       ├── gradle-wrapper.jar
│       └── gradle-wrapper.properties
├── gradle.properties
├── gradlew
├── gradlew.bat
├── composeApp/
│   ├── build.gradle.kts
│   └── src/
│       ├── androidMain/
│       │   ├── AndroidManifest.xml
│       │   └── kotlin/
│       │       └── com/
│       │           └── openparty/
│       │               └── app/
│       │                   └── [Placeholder]
│       ├── commonMain/
│       │   └── kotlin/
│       │       └── com/
│       │           └── openparty/
│       │               └── app/
│       │                   └── [Placeholder]
│       └── iosMain/
│           └── kotlin/
│               └── com/
│                   └── openparty/
│                       └── app/
│                           └── [Placeholder]
└── iosApp/
    ├── configuration/
    ├── iosApp/
    │   ├── Assets.xcassets/
    │   ├── ContentView.swift
    │   ├── Info.plist
    │   ├── iOSApp.swift
    │   ├── iosApp.xcodeproj/
    │   └── Preview Content/
    └── iosApp.xcodeproj/

---------

Notes: 
- When you give code, give the entire file, don't abbreviate anything
- Don't leave comments in the code, except a comment at a top of the file stating the file path
    - e.g. //File: composeApp/src/androidMain/kotlin/com/openparty/app/main/MainViewModel.kt
- Use the cleanest, most robust, scalable architecture you can 
- For every gradle dependency, give it in this format: implementation("org.jetbrains.androidx.lifecycle:lifecycle-viewmodel-compose:2.8.2")
    - don't give it in the libs.version.toml format. i.e. don't do this - implementation(compose.components.uiToolingPreview)
    - The exception to this is the dependencies that are already in my gradle files, leave them in the original format
- For view models, use the compose multiplatform view model i.e. this dependency - implementation("org.jetbrains.androidx.lifecycle:lifecycle-viewmodel-compose:2.8.2")
    - Don't create view models, that don't inherit from anything, instead use the above dependency and this import - import androidx.lifecycle.viewmodel.compose.viewModel
- Don't give me files I haven't given you, only give me the files back that i gave you 
    - The exception to this is koin dependency injection files, you can create those and given them back 
    
---------

- The above code is native kotlin android code 
- I want to change this, so that it instead uses kotlin multiplatform with compose multiplatform
    - i.e. i want you to change this from a native kotlin app to a kotlin multiplatform with compose multiplatform app 
- I've given you the package structure for the kotlin multiplatform app above 

In order to do this you will need to make some changes: 
- Right now, dependency injection is done using dagger hilt, I'll need you to change this to koin dependency injection 
    - Put the koin dependency injection files in commonMain (i.e. use them for both platforms, don't make them platform specific)- I'm also using firebase. Put the firebase dependencies in the commonMain gradle so that I can use firebase shared code across platforms 
- I want to use compose multiplatform navigation, so all navigation should be in commonMain and should be shared across platforms 
    - implementation("org.jetbrains.compose.navigation:navigation:1.0.0")
- Use this for navigation - import androidx.navigation.NavController
    - Don't use this - import androidx.navigation.NavController
- Don't use Timber logs, use normal logs 

Rewrite the files to be mulitplatform and give me  all the files back 