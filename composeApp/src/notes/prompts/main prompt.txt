//File: composeApp/src/commonMain/kotlin/com/openparty/app/core/shared/domain/DomainResult.kt

package com.openparty.app.core.shared.domain

import com.openparty.app.core.shared.domain.error.AppError

sealed class DomainResult<out T> {
    data class Success<out T>(val data: T) : DomainResult<T>()
    data class Failure(val error: AppError) : DomainResult<Nothing>()
}

--
package com.openparty.app.core.shared.domain.error

sealed class AppError : Exception() {

    sealed class Navigation : AppError() {
        object General : AppError()
        object DetermineAuthStates : AppError()
    }

    sealed class Analytics : AppError() {
        object TrackAppOpen : AppError()
        object IdentifyUser : AppError()
        object TrackDiscussionsPreviewClick : AppError()
        object TrackCouncilMeetingPreviewClick : AppError()
        object TrackDiscussionPosted : AppError()
        object TrackCommentPosted : AppError()
    }
.......

--
package com.openparty.app.core.shared.domain.error

import kotlin.reflect.KClass

object AppErrorMapper {

    fun getUserFriendlyMessage(
        error: AppError,
        customOverrides: Map<KClass<out AppError>, String>? = null
    ): String {
        val overrideMessage = customOverrides?.get(error::class)
        if (overrideMessage != null) {
            return overrideMessage
        }
        return when (error) {
            // Authentication
            is AppError.Authentication.SignIn -> "We couldn't sign you in. Please check your credentials."
            is AppError.Authentication.EmailVerification -> "Verification email couldn't be sent. Please try again in a while."
            is AppError.Authentication.RefreshToken -> "There was an issue sending your request. Please try again in a while."
            is AppError.Authentication.Logout -> "Logout failed. Please try again in a while."
            is AppError.Authentication.General -> "Unknown authentication error."
            is AppError.Authentication.GetUser -> "Unable to fetch user."
            is AppError.Authentication.GetUserId -> "Unable to fetch user."
            is AppError.Authentication.Register -> "Registration failed. Please try again in a while."
            is AppError.Authentication.UserAlreadyExists -> "Cannot create a user that already exists."
..........

--

OpenParty/
├── build.gradle.kts
├── gradle/
│   ├── libs.versions.toml
│   └── wrapper/
│       ├── gradle-wrapper.jar
│       └── gradle-wrapper.properties
├── gradle.properties
├── gradlew
├── gradlew.bat
├── composeApp/
│   ├── build.gradle.kts
│   └── src/
│       ├── androidMain/
│       │   ├── AndroidManifest.xml
│       │   └── kotlin/
│       │       └── com/
│       │           └── openparty/
│       │               └── app/
│       │                   └── [Placeholder]
│       ├── commonMain/
│       │   └── kotlin/
│       │       └── com/
│       │           └── openparty/
│       │               └── app/
│       │                   └── [Placeholder]
│       └── iosMain/
│           └── kotlin/
│               └── com/
│                   └── openparty/
│                       └── app/
│                           └── [Placeholder]
└── iosApp/
    ├── configuration/
    ├── iosApp/
    │   ├── Assets.xcassets/
    │   ├── ContentView.swift
    │   ├── Info.plist
    │   ├── iOSApp.swift
    │   ├── iosApp.xcodeproj/
    │   └── Preview Content/
    └── iosApp.xcodeproj/

---------
//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/newsfeed/discussions/feature_discussions_preview/di/DiscussionsKoinModule.kt
package com.openparty.app.features.newsfeed.discussions.feature_discussions_preview.di

import org.koin.dsl.module
import com.openparty.app.features.newsfeed.discussions.shared.domain.repository.DiscussionRepository
import com.openparty.app.features.newsfeed.discussions.shared.data.repository.DiscussionRepositoryImpl
import com.openparty.app.features.newsfeed.discussions.feature_discussions_preview.domain.usecase.GetDiscussionsUseCase
import com.openparty.app.features.newsfeed.discussions.feature_discussions_preview.presentation.DiscussionsPreviewViewModel
import dev.gitlive.firebase.Firebase
import dev.gitlive.firebase.firestore.firestore

val discussionsKoinModule = module {
    single<DiscussionRepository> { DiscussionRepositoryImpl(get()) }
    single { Firebase.firestore }
    single { GetDiscussionsUseCase(get()) }
    factory { DiscussionsPreviewViewModel(get(), get()) }
}
//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/newsfeed/discussions/feature_discussions_preview/domain/usecase/GetDiscussionsUseCase.kt
package com.openparty.app.features.newsfeed.discussions.feature_discussions_preview.domain.usecase

import androidx.paging.PagingData
import com.openparty.app.core.shared.domain.DomainResult
import com.openparty.app.core.shared.domain.error.AppError
import com.openparty.app.features.newsfeed.discussions.shared.domain.model.Discussion
import com.openparty.app.features.newsfeed.discussions.shared.domain.repository.DiscussionRepository
import kotlinx.coroutines.flow.Flow
import com.openparty.app.core.shared.domain.GlobalLogger.logger

class GetDiscussionsUseCase(
    private val repository: DiscussionRepository
) {
    operator fun invoke(): DomainResult<Flow<PagingData<Discussion>>> {
        logger.i { "GetDiscussionsUseCase invoked" }
        return try {
            logger.i { "Fetching discussions from repository" }
            val discussionsFlow = repository.getDiscussions()
            logger.i { "Successfully fetched discussions flow" }
            DomainResult.Success(discussionsFlow)
        } catch (e: Exception) {
            logger.e(e) { "Error occurred while fetching discussions" }
            DomainResult.Failure(AppError.Discussion.FetchDiscussions)
        }
    }
}
//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/newsfeed/discussions/feature_discussions_preview/presentation/DiscussionCard.kt
package com.openparty.app.features.newsfeed.discussions.feature_discussions_preview.presentation

import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.Card
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.dp
import com.openparty.app.features.newsfeed.discussions.shared.domain.model.Discussion

@Composable
fun DiscussionCard(discussion: Discussion, onClick: () -> Unit) {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .padding(8.dp)
            .clickable { onClick() }
    ) {
        Column(modifier = Modifier.padding(16.dp)) {
            Text(
                text = discussion.title,
                style = MaterialTheme.typography.titleLarge,
                maxLines = 1,
                overflow = TextOverflow.Ellipsis
            )
            Spacer(modifier = Modifier.height(8.dp))
            Text(
                text = discussion.contentText,
                style = MaterialTheme.typography.bodyMedium,
                maxLines = 2,
                overflow = TextOverflow.Ellipsis
            )
        }
    }
}

//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/newsfeed/discussions/feature_discussions_preview/presentation/DiscussionsPreviewScreen.kt
package com.openparty.app.features.newsfeed.discussions.feature_discussions_preview.presentation

import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.ui.Modifier
import org.koin.compose.viewmodel.koinViewModel
import androidx.navigation.NavHostController
import app.cash.paging.compose.collectAsLazyPagingItems
import com.openparty.app.core.shared.presentation.ErrorText
import com.openparty.app.core.shared.presentation.UiEvent
import com.openparty.app.features.newsfeed.discussions.feature_add_discussion.presentation.AddDiscussionButton
import com.openparty.app.features.newsfeed.shared.presentation.BaseFeedScreen
import com.openparty.app.navigation.NavigationFooter
import com.openparty.app.navigation.Screen
import com.openparty.app.features.newsfeed.discussions.shared.domain.model.Discussion
import kotlinx.coroutines.flow.collectLatest

@Composable
fun DiscussionsPreviewScreen(
    navController: NavHostController,
    viewModel: DiscussionsPreviewViewModel = koinViewModel()
) {
    val lazyDiscussions = viewModel.discussions.collectAsLazyPagingItems()
    val uiEvent = viewModel.uiEvent
    val uiState by viewModel.uiState.collectAsState()

    LaunchedEffect(uiEvent) {
        uiEvent.collectLatest { event ->
            when (event) {
                is UiEvent.Navigate -> {
                    navController.navigate(event.destination)
                }
            }
        }
    }

    Box(modifier = Modifier.fillMaxSize()) {
        Column(modifier = Modifier.fillMaxSize()) {
            Box(modifier = Modifier.weight(1f)) {
                BaseFeedScreen<Discussion>(
                    items = lazyDiscussions,
                    emptyPlaceholder = "No discussions yet..."
                ) { discussion ->
                    if (discussion != null) {
                        DiscussionCard(discussion = discussion) {
                            viewModel.onDiscussionSelected(discussion.discussionId)
                        }
                    }
                }
                AddDiscussionButton {
                    navController.navigate(Screen.AddDiscussion.route)
                }
            }
            ErrorText(errorMessage = uiState.errorMessage)
//            NavigationFooter(
//                navController = navController,
//                currentRoute = navController.currentBackStackEntry?.destination?.route
//            )
        }
    }
}
//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/newsfeed/discussions/feature_discussions_preview/presentation/DiscussionsPreviewViewModel.kt
package com.openparty.app.features.newsfeed.discussions.feature_discussions_preview.presentation

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import androidx.paging.PagingData
import androidx.paging.cachedIn
import com.openparty.app.core.analytics.domain.usecase.TrackDiscussionSelectedUseCase
import com.openparty.app.core.shared.domain.DomainResult
import com.openparty.app.core.shared.domain.error.AppErrorMapper
import com.openparty.app.core.shared.presentation.UiEvent
import com.openparty.app.core.shared.presentation.UiState
import com.openparty.app.features.newsfeed.discussions.shared.domain.model.Discussion
import com.openparty.app.features.newsfeed.discussions.feature_discussions_preview.domain.usecase.GetDiscussionsUseCase
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.SharedFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch
import com.openparty.app.core.shared.domain.GlobalLogger.logger
import com.openparty.app.navigation.Screen

class DiscussionsPreviewViewModel(
    private val getDiscussionsUseCase: GetDiscussionsUseCase,
    private val trackDiscussionSelectedUseCase: TrackDiscussionSelectedUseCase
) : ViewModel() {

    private val _uiState = MutableStateFlow(UiState())
    val uiState: StateFlow<UiState> = _uiState

    private val _uiEvent = MutableSharedFlow<UiEvent>()
    val uiEvent: SharedFlow<UiEvent> = _uiEvent

    private var _discussions: kotlinx.coroutines.flow.Flow<PagingData<Discussion>> = kotlinx.coroutines.flow.flow { }
    val discussions: kotlinx.coroutines.flow.Flow<PagingData<Discussion>>
        get() = _discussions

    init {
        loadDiscussions()
    }

    private fun loadDiscussions() {
        viewModelScope.launch {
            _uiState.value = _uiState.value.copy(isLoading = true)
            when (val result = getDiscussionsUseCase()) {
                is DomainResult.Success -> {
                    _discussions = result.data.cachedIn(viewModelScope)
                }
                is DomainResult.Failure -> {
                    val errorMessage = AppErrorMapper.getUserFriendlyMessage(result.error)
                    logger.e(result.error) { "Error loading discussions" }
                    _uiState.value = _uiState.value.copy(isLoading = false, errorMessage = errorMessage)
                }
            }
        }
    }

    fun onDiscussionSelected(discussionId: String) {
        viewModelScope.launch {
            when (val result = trackDiscussionSelectedUseCase(discussionId)) {
                is DomainResult.Success -> logger.i { "Discussion selected event tracked: $discussionId" }
                is DomainResult.Failure -> logger.e { "Failed to track discussion selected event for ID: $discussionId" }
            }
            _uiEvent.emit(UiEvent.Navigate(Screen.DiscussionsArticle.createRoute(discussionId)))
        }
    }
}
// File: composeApp/src/commonMain/kotlin/com/openparty/app/features/newsfeed/discussions/shared/data/repository/DiscussionRepositoryImpl.kt
package com.openparty.app.features.newsfeed.discussions.shared.data.repository

import androidx.paging.PagingData
import com.openparty.app.core.shared.domain.DomainResult
import com.openparty.app.core.shared.domain.error.AppError
import com.openparty.app.features.newsfeed.discussions.shared.domain.repository.DiscussionRepository
import com.openparty.app.features.newsfeed.discussions.shared.domain.model.Discussion
import com.openparty.app.features.newsfeed.shared.data.datasource.FirebaseNewsfeedDataSource
import com.openparty.app.features.newsfeed.shared.data.repository.FirestoreRepository
import kotlinx.coroutines.flow.Flow
import com.openparty.app.core.shared.domain.GlobalLogger.logger
import dev.gitlive.firebase.firestore.FirebaseFirestore
import kotlin.random.Random
import kotlinx.serialization.serializer

class DiscussionRepositoryImpl(
    private val firestore: FirebaseFirestore
) : FirestoreRepository<Discussion>(
    dataSource = FirebaseNewsfeedDataSource(
        firestore = firestore,
        collectionName = "discussions",
        orderByField = "upvoteCount",
        transform = { documentSnapshot ->
            try {
                logger.i { "Transforming document snapshot to Discussion object: ${documentSnapshot.id}" }
                val decoded: Discussion? = try {
                    documentSnapshot.data(Discussion.serializer())
                } catch (e: Exception) {
                    null
                }
                decoded?.copy(discussionId = documentSnapshot.id)
            } catch (e: Exception) {
                logger.e(e) { "Error transforming document snapshot to Discussion object: ${documentSnapshot.id}" }
                null
            }
        }
    ),
    error = AppError.Discussion.General
), DiscussionRepository {

    override fun getDiscussions(): Flow<PagingData<Discussion>> {
        logger.i { "Fetching discussions from DiscussionRepositoryImpl" }
        return getPagedItems()
    }

    override suspend fun getDiscussionById(discussionId: String): DomainResult<Discussion> {
        logger.i { "Fetching discussion by ID: $discussionId from DiscussionRepositoryImpl" }
        return getItemById(discussionId)
    }

    override suspend fun addDiscussion(discussion: Discussion): DomainResult<Discussion> {
        logger.i { "addDiscussion invoked for discussion: ${discussion.title}" }
        return try {
            val generatedId = Random.nextLong().toString()
            val document = firestore.collection("discussions").document(generatedId)
            logger.i { "Generated new document ID: ${document.id} for discussion: ${discussion.title}" }
            val discussionWithId = discussion.copy(discussionId = document.id)
            document.set(discussionWithId)
            logger.i { "Successfully added discussion with ID: ${discussionWithId.discussionId}" }
            DomainResult.Success(discussionWithId)
        } catch (e: Exception) {
            logger.e(e) { "Error adding discussion: ${discussion.title}" }
            DomainResult.Failure(AppError.Discussion.General)
        }
    }
}
//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/newsfeed/discussions/shared/domain/model/Discussion.kt
package com.openparty.app.features.newsfeed.discussions.shared.domain.model

import dev.gitlive.firebase.firestore.Timestamp
import kotlinx.serialization.Serializable

@Serializable
data class Discussion(
    val discussionId: String = "",
    val title: String = "",
    val contentText: String = "",
    val timestamp: Timestamp? = null,
    val commentCount: Int = 0,
    val upvoteCount: Int = 0,
    val downvoteCount: Int = 0
)
//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/newsfeed/discussions/shared/data/domain/repository/DiscussionRepository.kt
package com.openparty.app.features.newsfeed.discussions.shared.domain.repository

import androidx.paging.PagingData
import com.openparty.app.core.shared.domain.DomainResult
import com.openparty.app.features.newsfeed.discussions.shared.domain.model.Discussion
import kotlinx.coroutines.flow.Flow

interface DiscussionRepository {
    fun getDiscussions(): Flow<PagingData<Discussion>>
    suspend fun getDiscussionById(discussionId: String): DomainResult<Discussion>
    suspend fun addDiscussion(discussion: Discussion): DomainResult<Discussion>
}
//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/newsfeed/shared/data/datasource/FirebaseNewsfeedDataSource.kt
package com.openparty.app.features.newsfeed.shared.data.datasource

import dev.gitlive.firebase.firestore.DocumentSnapshot
import dev.gitlive.firebase.firestore.FirebaseFirestore
import dev.gitlive.firebase.firestore.Query
import dev.gitlive.firebase.firestore.Direction
import com.openparty.app.core.shared.domain.GlobalLogger.logger

class FirebaseNewsfeedDataSource<T : Any>(
    private val firestore: FirebaseFirestore,
    val collectionName: String,
    private val orderByField: String,
    val transform: (DocumentSnapshot) -> T?
) {
    fun getQuery(startAfter: DocumentSnapshot?, loadSize: Int): Query {
        val queryDescription = buildString {
            appendLine("Constructing Firestore query:")
            appendLine("  Collection: $collectionName")
            appendLine("  OrderBy: $orderByField (DESC)")
            appendLine("  Limit: $loadSize")
            if (startAfter != null) {
                appendLine("  StartAfter doc ID: ${startAfter.id}")
            }
        }
        logger.d { "getQuery() -> $queryDescription" }
        return try {
            val baseQuery = firestore.collection(collectionName)
                .orderBy(orderByField, Direction.DESCENDING)
                .limit(loadSize.toLong())
            if (startAfter != null) {
                baseQuery.startAfter(startAfter)
            } else {
                baseQuery
            }
        } catch (e: Exception) {
            logger.e(e) { "Error creating query for collection: $collectionName" }
            throw Exception("Failed to create query for collection: $collectionName. Please try again.", e)
        }
    }

    suspend fun getItemById(itemId: String): T? {
        logger.d { "Fetching item by ID: $itemId from collection: $collectionName" }
        return try {
            val snapshot = firestore.collection(collectionName)
                .document(itemId)
                .get()
            logger.d { "Item fetched successfully for ID: $itemId in collection: $collectionName" }
            transform(snapshot)
        } catch (e: Exception) {
            logger.e(e) { "Error fetching item by ID: $itemId from collection: $collectionName" }
            null
        }
    }
}
// File: composeApp/src/commonMain/kotlin/com/openparty/app/features/newsfeed/shared/data/datasource/FirestorePagingSource.kt
package com.openparty.app.features.newsfeed.shared.data.datasource

import app.cash.paging.PagingSource
import app.cash.paging.PagingState
import dev.gitlive.firebase.firestore.DocumentSnapshot
import com.openparty.app.core.shared.domain.GlobalLogger.logger

class FirestorePagingSource<T : Any>(
    private val dataSource: FirebaseNewsfeedDataSource<T>
) : PagingSource<DocumentSnapshot, T>() {

    override suspend fun load(params: LoadParams<DocumentSnapshot>): LoadResult<DocumentSnapshot, T> {
        val collection = dataSource.collectionName
        val startAfterId = params.key?.id
        logger.d { "Loading data from FirestorePagingSource for $collection with loadSize: ${params.loadSize} and startAfter: $startAfterId" }
        return try {
            val query = dataSource.getQuery(params.key, params.loadSize)
            val snapshot = query.get()
            val items = snapshot.documents.mapNotNull { dataSource.transform(it) }
            val nextKey = snapshot.documents.lastOrNull()
            if (items.isEmpty()) {
                logger.w { "No items loaded for $collection (startAfter = $startAfterId). Possibly an empty collection or no more data." }
            } else {
                logger.d { "Successfully loaded ${items.size} items from $collection, next key: ${nextKey?.id}" }
            }
            LoadResult.Page(
                data = items,
                prevKey = null,
                nextKey = nextKey
            )
        } catch (e: Exception) {
            logger.e(e) { "Error loading data in FirestorePagingSource for $collection" }
            LoadResult.Error(e)
        }
    }

    override fun getRefreshKey(state: PagingState<DocumentSnapshot, T>): DocumentSnapshot? {
        logger.d { "Getting refresh key in FirestorePagingSource for ${dataSource.collectionName}" }
        return null
    }
}
// File: composeApp/src/commonMain/kotlin/com/openparty/app/features/newsfeed/shared/data/repository/FirestoreRepository.kt
package com.openparty.app.features.newsfeed.shared.data.repository

import app.cash.paging.Pager
import app.cash.paging.PagingConfig
import app.cash.paging.PagingData
import com.openparty.app.core.shared.domain.DomainResult
import com.openparty.app.core.shared.domain.error.AppError
import com.openparty.app.features.newsfeed.shared.data.datasource.FirestorePagingSource
import kotlinx.coroutines.flow.Flow
import com.openparty.app.core.shared.domain.GlobalLogger.logger
import com.openparty.app.features.newsfeed.shared.data.datasource.FirebaseNewsfeedDataSource

abstract class FirestoreRepository<T : Any>(
    private val dataSource: FirebaseNewsfeedDataSource<T>,
    private val error: AppError
) {
    fun getPagedItems(): Flow<PagingData<T>> {
        logger.d { "Fetching paged items from FirestoreRepository for ${dataSource.collectionName}" }
        return Pager(
            config = PagingConfig(
                pageSize = 10,
                enablePlaceholders = false
            ),
            pagingSourceFactory = {
                logger.d { "Creating FirestorePagingSource for ${dataSource.collectionName}" }
                FirestorePagingSource(dataSource)
            }
        ).flow
    }

    suspend fun getItemById(itemId: String): DomainResult<T> {
        logger.d { "Fetching item by ID: $itemId in FirestoreRepository for ${dataSource.collectionName}" }
        return try {
            val item = dataSource.getItemById(itemId)
            if (item != null) {
                logger.d { "Item found for ID: $itemId in ${dataSource.collectionName}" }
                DomainResult.Success(item)
            } else {
                logger.w { "Item not found for ID: $itemId in ${dataSource.collectionName}" }
                DomainResult.Failure(error)
            }
        } catch (e: Exception) {
            logger.e(e) { "Error fetching item by ID: $itemId in ${dataSource.collectionName}" }
            DomainResult.Failure(error)
        }
    }
}
// File: composeApp/src/commonMain/kotlin/com/openparty/app/features/newsfeed/shared/presentation/BaseFeedScreen.kt
package com.openparty.app.features.newsfeed.shared.presentation

import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import app.cash.paging.compose.LazyPagingItems

@Composable
fun <T : Any> BaseFeedScreen(
    items: LazyPagingItems<T>,
    emptyPlaceholder: String,
    content: @Composable (item: T?) -> Unit
) {
    if (items.itemCount == 0) {
        Box(
            modifier = Modifier.fillMaxSize(),
            contentAlignment = Alignment.Center
        ) {
            Text(text = emptyPlaceholder)
        }
    } else {
        LazyColumn {
            items(
                count = items.itemCount,
                key = { index -> items[index]?.hashCode() ?: index }
            ) { index ->
                val item = items[index]
                content(item)
            }
        }
    }
}
//File: composeApp/src/commonMain/kotlin/com/openparty/app/navigation/AppNavigation.kt
package com.openparty.app.navigation

import androidx.compose.foundation.layout.padding
import androidx.compose.material3.Scaffold
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.ui.Modifier
import androidx.navigation.NavType
import androidx.navigation.compose.NavHost
import androidx.navigation.compose.currentBackStackEntryAsState
import androidx.navigation.compose.rememberNavController
import androidx.navigation.compose.composable
import androidx.navigation.navArgument
import com.openparty.app.features.engagement.comments.feature_add_comment.presentation.AddCommentScreen
import com.openparty.app.features.newsfeed.council_meetings.feature_council_meetings_article.presentation.CouncilMeetingArticleScreen
import com.openparty.app.features.newsfeed.council_meetings.feature_council_meetings_preview.presentation.CouncilMeetingsPreviewScreen
import com.openparty.app.features.newsfeed.discussions.feature_add_discussion.presentation.AddDiscussionScreen
import com.openparty.app.features.newsfeed.discussions.feature_discussions_article.presentation.DiscussionArticleScreen
import com.openparty.app.features.newsfeed.discussions.feature_discussions_preview.presentation.DiscussionsPreviewScreen
import com.openparty.app.features.startup.account.feature_login.presentation.LoginScreen
import com.openparty.app.features.startup.account.feature_register.presentation.RegisterScreen
import com.openparty.app.features.startup.feature_screen_name_generation.presentation.ScreenNameGenerationScreen
import com.openparty.app.features.startup.feature_splash.presentation.SplashScreen
import com.openparty.app.features.startup.verification.feature_email_verification.presentation.EmailVerificationScreen
import com.openparty.app.features.startup.verification.feature_location_verification.presentation.LocationVerificationScreen
import com.openparty.app.features.startup.verification.feature_manual_verification.presentation.ManualVerificationScreen
import com.openparty.app.features.utils.feature_settings.presentation.SettingsScreen
import org.koin.compose.viewmodel.koinViewModel
import org.koin.core.parameter.parametersOf

@Composable
fun AppNavigation() {
    val navController = rememberNavController()
    val navBackStackEntry by navController.currentBackStackEntryAsState()
    val currentRoute = navBackStackEntry?.destination?.route
    val bottomBarRoutes = listOf(
        Screen.DiscussionsPreview.route,
        Screen.CouncilMeetingsPreview.route,
        Screen.Settings.route
    )
    Scaffold(
        bottomBar = {
            if (currentRoute in bottomBarRoutes) {
                NavigationFooter(navController = navController, currentRoute = currentRoute)
            }
        }
    ) { padding ->
        NavHost(
            navController = navController,
            startDestination = Screen.Splash.route,
            modifier = Modifier.padding(padding)
        ) {
            composable(Screen.Splash.route) { SplashScreen(navController) }
            composable(Screen.Login.route) { LoginScreen(navController) }
            composable(Screen.Register.route) { RegisterScreen(navController) }
            composable(Screen.EmailVerification.route) { EmailVerificationScreen(navController) }
            composable(Screen.LocationVerification.route) { LocationVerificationScreen(navController) }
            composable(Screen.ScreenNameGeneration.route) { ScreenNameGenerationScreen(navController) }
            composable(Screen.ManualVerification.route) { ManualVerificationScreen() }
            composable(Screen.DiscussionsPreview.route) { DiscussionsPreviewScreen(navController) }
            composable(Screen.CouncilMeetingsPreview.route) { CouncilMeetingsPreviewScreen(navController) }
            composable(Screen.AddDiscussion.route) { AddDiscussionScreen(navController) }
            composable(Screen.Settings.route) { SettingsScreen() }
            composable(
                route = Screen.DiscussionsArticle("").route,
                arguments = listOf(navArgument("discussionId") { type = NavType.StringType })
            ) {
                DiscussionArticleScreen(navController)
            }
            composable(
                route = Screen.CouncilMeetingsArticle("").route,
                arguments = listOf(navArgument("councilMeetingId") { type = NavType.StringType })
            ) { backStackEntry ->
                val councilMeetingId = backStackEntry.arguments?.getString("councilMeetingId") ?: ""
                val viewModel = koinViewModel<com.openparty.app.features.newsfeed.council_meetings.feature_council_meetings_article.presentation.CouncilMeetingArticleViewModel> {
                    parametersOf(councilMeetingId)
                }
                CouncilMeetingArticleScreen(navController, viewModel)
            }
            composable(
                route = Screen.AddComment("", "").route,
                arguments = listOf(
                    navArgument("discussionId") { type = NavType.StringType },
                    navArgument("titleText") { type = NavType.StringType }
                )
            ) { backStackEntry ->
                val discussionId = backStackEntry.arguments?.getString("discussionId") ?: ""
                val titleText = backStackEntry.arguments?.getString("titleText") ?: ""
                val viewModel = koinViewModel<com.openparty.app.features.engagement.comments.feature_add_comment.presentation.AddCommentViewModel> {
                    parametersOf(discussionId, titleText)
                }
                AddCommentScreen(navController, discussionId, titleText, viewModel)
            }
        }
    }
}
//File: composeApp/src/commonMain/kotlin/com/openparty/app/navigation/NavigationFooter.kt
package com.openparty.app.navigation

import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.outlined.Chat
import androidx.compose.material.icons.outlined.Settings
import androidx.compose.material3.Icon
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp

@Composable
fun NavigationFooter(
    navController: androidx.navigation.NavController,
    currentRoute: String?
) {
    val discussionsColor = if (currentRoute == Screen.DiscussionsPreview.route) Color.White else Color.Gray
    val settingsColor = if (currentRoute == Screen.Settings.route) Color.White else Color.Gray

    Row(
        modifier = Modifier
            .fillMaxWidth()
            .height(60.dp)
            .background(Color.Black)
            .padding(top = 8.dp),
        horizontalArrangement = Arrangement.SpaceEvenly,
        verticalAlignment = Alignment.CenterVertically
    ) {
        Column(
            modifier = Modifier
                .clickable {
                    navController.navigate(Screen.DiscussionsPreview.route) {
                        popUpTo(Screen.DiscussionsPreview.route) { inclusive = true }
                    }
                },
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            Icon(
                imageVector = Icons.Outlined.Chat,
                contentDescription = null,
                tint = discussionsColor,
                modifier = Modifier.size(24.dp)
            )
            Text("Discussions", color = discussionsColor, fontSize = 12.sp)
        }

        Column(
            modifier = Modifier
                .clickable {
                    navController.navigate(Screen.Settings.route) {
                        popUpTo(Screen.Settings.route) { inclusive = true }
                    }
                },
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            Icon(
                imageVector = Icons.Outlined.Settings,
                contentDescription = null,
                tint = settingsColor,
                modifier = Modifier.size(24.dp)
            )
            Text("Settings", color = settingsColor, fontSize = 12.sp)
        }
    }
}
//File: composeApp/src/commonMain/kotlin/com/openparty/app/navigation/Screen.kt
package com.openparty.app.navigation

import kotlinx.serialization.Serializable

@Serializable
sealed class Screen(val route: String) {

    @Serializable object Splash : Screen("splash")
    @Serializable object Login : Screen("login")
    @Serializable object Register : Screen("register")
    @Serializable object EmailVerification : Screen("email_verification")
    @Serializable object LocationVerification : Screen("location_verification")
    @Serializable object ScreenNameGeneration : Screen("screen_name_generation")
    @Serializable object ManualVerification : Screen("manual_verification")
    @Serializable object DiscussionsPreview : Screen("discussions_preview")
    @Serializable object CouncilMeetingsPreview : Screen("council_meetings_preview")
    @Serializable object AddDiscussion : Screen("add_discussion")
    @Serializable object Settings : Screen("settings")

    @Serializable
    data class DiscussionsArticle(val discussionId: String) : Screen("discussions_article/{discussionId}") {
        companion object {
            fun createRoute(discussionId: String): String = "discussions_article/$discussionId"
        }
    }

    @Serializable
    data class CouncilMeetingsArticle(val councilMeetingId: String) : Screen("council_meetings_article/{councilMeetingId}") {
        companion object {
            fun createRoute(councilMeetingId: String): String = "council_meetings_article/$councilMeetingId"
        }
    }

    @Serializable
    data class AddComment(val discussionId: String, val titleText: String) : Screen("add_comment/{discussionId}/{titleText}") {
        companion object {
            fun createRoute(discussionId: String, titleText: String): String = "add_comment/$discussionId/$titleText"
        }
    }
}


---------

Notes: 
- When you give code, give the entire file, don't abbreviate anything
- Don't leave comments in the code, except a comment at a top of the file stating the file path
    - e.g. //File: composeApp/src/androidMain/kotlin/com/openparty/app/main/MainViewModel.kt
- Use the cleanest, most robust, scalable architecture you can 
- For every gradle dependency, give it in this format: implementation("org.jetbrains.androidx.lifecycle:lifecycle-viewmodel-compose:2.8.2")
    - don't give it in the libs.version.toml format. i.e. don't do this - implementation(compose.components.uiToolingPreview)
    - The exception to this is the dependencies that are already in my gradle files, leave them in the original format
- I'm using koin compose multiplatform for my depedency injection, that means that in my screen classes, I use this import - import org.koin.compose.viewmodel.koinViewModel
    - And the view model is injected like this - viewModel: DiscussionArticleViewModel = koinViewModel()
    - This might look odd to you since it's a new approach but don't change it, assume it's correct 
- Keep all business logic in use cases where appropriate 
- Whenenever you use use cases, return the DomainResult Success or Failure 
- Add Kermit logs where appropriate 
- Whenever you call a use case (for example in the view model), handle the DomainResult.Success or Failure case and use this: val errorMessage = AppErrorMapper.getUserFriendlyMessage(result.error) - to return a friendly error to the user
- Whenever you use a library in commonMain code, make sure that it's a library that's compatible with compose multiplatform

---------

i'm writing an android app that is  similar to reddit. it has an discussions preview screen which shows a series of discussions like a reddit newsfeed. it does this by displaying a list of discussion cards, each of which rperesents a discussions submitted by the user. irght now each discussion card just has a titel and a discussion 

I want to add a footer to these discussion cards for engagement, (like reddit has for it's newsfeed cards) 

The footer would have an upvote icon, a number next to it (representing the numberr of upvotes), a downvote icon, a comment icon, a number next to it represengint hte number of comments, 

Below is the firebase objects i have whihc relate to my discussions nad comments; 
Here’s a structured breakdown of the Firebase objects you provided:

---

### **Discussion Object**
Represents a discussion post.

| Key           | Type      | Value Example                                  |
|--------------|----------|------------------------------------------------|
| `commentCount`  | Number    | `0`                                          |
| `contentText`   | String    | `"test32"`                                   |
| `discussionId`  | String    | `"-3464349351394190174"`                     |
| `downvoteCount` | Number    | `0`                                          |
| `timestamp`     | Timestamp | `February 19, 2025 at 6:41:18 PM UTC`        |
| `title`         | String    | `"test32"`                                   |
| `upvoteCount`   | Number    | `0`                                          |

---

### **DiscussionVote Object**
Represents a vote (upvote/downvote) on a discussion.

| Key           | Type      | Value Example                                  |
|--------------|----------|------------------------------------------------|
| `discussionId`  | String    | `"iVcCVTrMArlGlY3KPGu2"`                     |
| `timestamp`     | Timestamp | `April 28, 2024 at 3:54:21 AM UTC+1`        |
| `type`          | String    | `"upvote"` (can be `"downvote"`)             |
| `userId`        | String    | `"3b1ae217-6c20-43af-99bb-ba6e3e37a75b"`     |
| `voteId`        | String    | `"00oR3dPWHKq9P1JcNIuV"`                     |

---

### **Comment Object**
Represents a comment made on a discussion or council meeting.

| Key               | Type      | Value Example                                                |
|------------------|----------|------------------------------------------------------------|
| `commentId`       | String    | `"05hkUZopHRF6MgxWjo6n"`                                   |
| `contentText`     | String    | `"This issue has been ignored for too long. Thanks for stepping up."` |
| `councilMeetingId` | String    | `"NDrQEWylELcD5JoxqoWh"`                                   |
| `discussionId`    | Null      | `null` (comment not linked to a discussion)               |
| `downvoteCount`   | Number    | `6`                                                        |
| `parentCommentId` | Null      | `null` (not a reply to another comment)                   |
| `screenName`      | String    | `"Brilliant Forest River"`                                |
| `timestamp`       | Timestamp | `October 29, 2024 at 10:04:25 PM UTC`                     |
| `upvoteCount`     | Number    | `13`                                                       |
| `userId`          | String    | `"3b1ae217-6c20-43af-99bb-ba6e3e37a75b"`                   |

---

### **CommentVote Object**
Represents a vote (upvote/downvote) on a comment.

| Key          | Type      | Value Example                                  |
|-------------|----------|------------------------------------------------|
| `commentId`   | String    | `"4TO63G4LofwSMfHRrrYS"`                      |
| `timestamp`   | Timestamp | `March 15, 2024 at 1:05:44 PM UTC`            |
| `type`        | String    | `"upvote"` (can be `"downvote"`)               |
| `userId`      | String    | `"10384f77-531d-4fdc-b622-1715650f3b80"`      |
| `voteId`      | String    | `"00Tg2KICHqKfF6XUn8wX"`                      |

---

The newsfeed is going to be for discussions, so the newsfeed shows a list of discussion cards, each representing a discussion that the user has submitted 

I want the engagement footer to be in its own feature for separation of priniciples. I also want it to meet these criteria (all of which are standard for a reddit newsfeed): 
- The upvote/downvote icons have to go from outline to filled when clicked (this has to happen immediately, i.e. no delay to call the database) (also when the user goes off the page and comes back on, it should still show the upvote/downvote icons as filled or outlined, depending on if the user has clicked them - i.e. it should not be reset when the user leaves the page, it shoudl remember) 
- The number of upvotes/downvotes should be persisted to the database (i.e. when the user clicks an upvote or downvote, it should persist to the database) 
- When the user clicks the upvote icon, it adds an upvote. When the user clicks the same upvote, it removes the upvote. same for downvote (i.e. clicking the same button twice removes the action) 

---

I asked another AI about how to construct the architecture for this and it gave me this advice: 
Below is an updated architecture tailored for an Android app using Jetpack Compose and Kotlin Compose Multiplatform with Firebase as the backend. This design maintains separation of concerns, provides immediate UI feedback with optimistic updates, and ensures that vote states persist across app sessions.

---

## 1. Overall Component Breakdown

### **Presentation Layer (UI with Jetpack Compose)**
- **Discussion Card & Engagement Footer Composables:**  
  Build a reusable composable for the engagement footer that is embedded in each discussion card. The footer displays:
  - An upvote icon (toggling from outlined to filled when active)
  - A downvote icon (with similar toggling behavior)
  - Vote counts for each action
  - A comment icon with a comment count
- **State Management with Compose:**  
  Use Compose’s state mechanisms (e.g., `MutableState`, `StateFlow`, or `remember { mutableStateOf() }`) to manage the UI state. This allows for immediate visual updates without waiting for a database response.
- **Event Handling:**  
  The footer composable emits events such as `onUpvoteClicked` or `onDownvoteClicked` that are handled by the ViewModel.

### **ViewModel Layer (Kotlin Multiplatform)**
- **Shared ViewModel:**  
  Create a multiplatform ViewModel (using libraries like KMM’s shared modules) that holds the state for each discussion card, including:
  - Current vote state (upvoted, downvoted, or neutral)
  - Vote counts and comment counts
- **Optimistic UI Updates:**  
  When a vote is tapped, the ViewModel immediately updates the state to reflect the change (e.g., filling the icon and updating the vote count) while concurrently triggering a persistence call.
- **State Restoration:**  
  On launch or when returning to the screen, the ViewModel fetches the persisted vote state from Firebase (or a local cache backed by Firebase’s offline support) to render the correct icon state.

### **Domain Layer (Business Logic)**
- **Vote Toggle Logic:**  
  Implement business rules for:
  - Adding a vote when the icon is clicked
  - Removing the vote if the same icon is clicked again
  - Switching votes if the opposite icon is tapped (which removes the existing vote and applies the new one)
- **Atomic Updates:**  
  Ensure that vote operations are performed atomically so that the vote count and the user’s vote record remain in sync. This could be managed by either dedicated interactor classes or within the ViewModel.

### **Data Layer (Repository with Firebase Integration)**
- **Firebase Repository:**  
  Create a repository that abstracts all Firebase interactions:
  - **Persisting Votes:**  
    Write a new `DiscussionVote` object (or remove it if the vote is being retracted) and update the `Discussion` object’s upvote/downvote counts accordingly.
  - **Real-Time Data Sync:**  
    Set up Firebase listeners that observe changes in the relevant nodes (e.g., vote counts, vote states for a user) and propagate these changes back to the ViewModel.
  - **Offline Support:**  
    Leverage Firebase’s offline capabilities so that vote actions are cached locally and synchronized when connectivity is restored.
- **Kotlin Compose Multiplatform Considerations:**  
  Use Kotlin Multiplatform libraries where possible so that the same business logic can be shared across Android, iOS, or web platforms if needed. Firebase’s multiplatform support or abstraction layers can help manage platform-specific differences.

---

## 2. Detailed Flow of User Interaction

1. **User Interaction & Immediate Feedback:**  
   - The user taps the upvote icon on the engagement footer composable.
   - The composable sends an event (e.g., `onUpvoteClicked`) to the ViewModel.
   - The ViewModel immediately updates the local state (e.g., switching the upvote icon from outlined to filled and incrementing the vote count) using Compose’s reactive state management.

2. **Asynchronous Data Persistence:**  
   - The ViewModel calls the repository to persist the vote change to Firebase.
   - The repository performs the appropriate Firebase write (or deletion) and updates the discussion vote count using Firebase transactions or batched writes.
   - Firebase listeners (set up in the repository) capture the change and ensure the local state remains synchronized with the database. If an error occurs, the ViewModel can revert the optimistic update and notify the user.

3. **State Restoration on Return:**  
   - When the user navigates away and returns, the ViewModel queries Firebase (or a cached local copy) for the current vote state and vote counts.
   - The engagement footer composable then renders the icons in the correct state (filled or outlined) based on the persisted data.

4. **Handling Vote Toggling:**  
   - Tapping an already active vote icon will toggle the state back to neutral (removing the vote).
   - Tapping the opposite vote icon will remove the existing vote and add the new one, with all changes immediately reflected in the UI and persisted to Firebase.

---

## 3. Separation of Concerns & Modularity

- **Modular Engagement Footer:**  
  The engagement footer is built as an independent composable, ensuring that its logic is decoupled from other UI elements. This promotes reusability and easier testing.
  
- **ViewModel as the Mediator:**  
  The ViewModel acts as the bridge between the UI and the data layer, handling business logic, managing state, and ensuring that the UI reflects both optimistic and persisted states.
  
- **Repository Abstraction:**  
  Abstracting Firebase interactions in the repository makes it easier to manage data persistence and enables you to swap or extend backend implementations with minimal impact on the UI or business logic.

---

## 4. Summary

- **Immediate, Optimistic UI Feedback:**  
  Jetpack Compose’s reactive state management allows your app to immediately reflect vote changes, providing a seamless user experience.
  
- **Persistent Data & State Restoration:**  
  Firebase (with its offline and real-time syncing capabilities) ensures that vote counts and user-specific vote states are accurately persisted and restored.
  
- **Clean, Modular Architecture:**  
  Using a Kotlin Compose Multiplatform approach, combined with MVVM and repository patterns, guarantees that your code remains maintainable, scalable, and testable across multiple platforms.

This architecture provides a robust foundation for implementing a Reddit-like engagement footer that is both responsive and consistent, leveraging modern Android development practices and multiplatform capabilities.

---------------

Use the above advice as inspiration - you odn't have to follow it fully - particularly if it is contradicted by something else i said 

put the feature in the features/engagement/engagement_bars/feature_preview_enagement_footer

Write all the code for this feature