//File: composeApp/src/commonMain/kotlin/com/openparty/app/core/shared/domain/DomainResult.kt

package com.openparty.app.core.shared.domain

import com.openparty.app.core.shared.domain.error.AppError

sealed class DomainResult<out T> {
    data class Success<out T>(val data: T) : DomainResult<T>()
    data class Failure(val error: AppError) : DomainResult<Nothing>()
}

--
package com.openparty.app.core.shared.domain.error

sealed class AppError : Exception() {

    sealed class Navigation : AppError() {
        object General : AppError()
        object DetermineAuthStates : AppError()
    }

    sealed class Analytics : AppError() {
        object TrackAppOpen : AppError()
        object IdentifyUser : AppError()
        object TrackDiscussionsPreviewClick : AppError()
        object TrackCouncilMeetingPreviewClick : AppError()
        object TrackDiscussionPosted : AppError()
        object TrackCommentPosted : AppError()
    }
.......

--
package com.openparty.app.core.shared.domain.error

import kotlin.reflect.KClass

object AppErrorMapper {

    fun getUserFriendlyMessage(
        error: AppError,
        customOverrides: Map<KClass<out AppError>, String>? = null
    ): String {
        val overrideMessage = customOverrides?.get(error::class)
        if (overrideMessage != null) {
            return overrideMessage
        }
        return when (error) {
            // Authentication
            is AppError.Authentication.SignIn -> "We couldn't sign you in. Please check your credentials."
            is AppError.Authentication.EmailVerification -> "Verification email couldn't be sent. Please try again in a while."
            is AppError.Authentication.RefreshToken -> "There was an issue sending your request. Please try again in a while."
            is AppError.Authentication.Logout -> "Logout failed. Please try again in a while."
            is AppError.Authentication.General -> "Unknown authentication error."
            is AppError.Authentication.GetUser -> "Unable to fetch user."
            is AppError.Authentication.GetUserId -> "Unable to fetch user."
            is AppError.Authentication.Register -> "Registration failed. Please try again in a while."
            is AppError.Authentication.UserAlreadyExists -> "Cannot create a user that already exists."
..........

--

OpenParty/
├── build.gradle.kts
├── gradle/
│   ├── libs.versions.toml
│   └── wrapper/
│       ├── gradle-wrapper.jar
│       └── gradle-wrapper.properties
├── gradle.properties
├── gradlew
├── gradlew.bat
├── composeApp/
│   ├── build.gradle.kts
│   └── src/
│       ├── androidMain/
│       │   ├── AndroidManifest.xml
│       │   └── kotlin/
│       │       └── com/
│       │           └── openparty/
│       │               └── app/
│       │                   └── [Placeholder]
│       ├── commonMain/
│       │   └── kotlin/
│       │       └── com/
│       │           └── openparty/
│       │               └── app/
│       │                   └── [Placeholder]
│       └── iosMain/
│           └── kotlin/
│               └── com/
│                   └── openparty/
│                       └── app/
│                           └── [Placeholder]
└── iosApp/
    ├── configuration/
    ├── iosApp/
    │   ├── Assets.xcassets/
    │   ├── ContentView.swift
    │   ├── Info.plist
    │   ├── iOSApp.swift
    │   ├── iosApp.xcodeproj/
    │   └── Preview Content/
    └── iosApp.xcodeproj/

---------

//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/engagement/engagement_bars/feature_preview_enagement_footer/data/EngagementRepositoryImpl.kt
package com.openparty.app.features.engagement.engagement_bars.feature_preview_enagement_footer.data

import com.openparty.app.features.engagement.engagement_bars.feature_preview_enagement_footer.domain.model.EngagementFooterState
import com.openparty.app.features.engagement.engagement_bars.feature_preview_enagement_footer.domain.model.VoteType
import com.openparty.app.features.engagement.engagement_bars.feature_preview_enagement_footer.domain.repository.EngagementRepository
import dev.gitlive.firebase.firestore.FirebaseFirestore
import kotlinx.datetime.Clock
import kotlin.random.Random

class EngagementRepositoryImpl(
    private val firestore: FirebaseFirestore
) : EngagementRepository {
    override suspend fun updateVote(
        discussionId: String,
        currentUserId: String,
        currentState: EngagementFooterState,
        newVote: VoteType?
    ): EngagementFooterState {
        val voteDocId = "${discussionId}_$currentUserId"
        val votesCollection = firestore.collection("discussion_votes")
        val discussionsCollection = firestore.collection("discussions")
        val discussionDocRef = discussionsCollection.document(discussionId)
        var upvoteCount = currentState.upvoteCount
        var downvoteCount = currentState.downvoteCount
        val oldVote = currentState.userVote

        if (oldVote == VoteType.UPVOTE && (newVote == null || newVote == VoteType.DOWNVOTE)) {
            upvoteCount = (upvoteCount - 1).coerceAtLeast(0)
        }
        if (oldVote == VoteType.DOWNVOTE && (newVote == null || newVote == VoteType.UPVOTE)) {
            downvoteCount = (downvoteCount - 1).coerceAtLeast(0)
        }
        if (oldVote == null && newVote == VoteType.UPVOTE) {
            upvoteCount += 1
        }
        if (oldVote == null && newVote == VoteType.DOWNVOTE) {
            downvoteCount += 1
        }
        if (oldVote == VoteType.UPVOTE && newVote == VoteType.DOWNVOTE) {
            downvoteCount += 1
        }
        if (oldVote == VoteType.DOWNVOTE && newVote == VoteType.UPVOTE) {
            upvoteCount += 1
        }
        try {
            // Use lambda receiver syntax to satisfy expected type
            firestore.runTransaction {
                update(discussionDocRef, mapOf("upvoteCount" to upvoteCount, "downvoteCount" to downvoteCount))
            }
            if (newVote == null) {
                votesCollection.document(voteDocId).delete()
            } else {
                val voteData = mapOf(
                    "discussionId" to discussionId,
                    "userId" to currentUserId,
                    "type" to newVote.name.lowercase(),
                    "timestamp" to Clock.System.now().toEpochMilliseconds(),
                    "voteId" to Random.nextLong().toString()
                )
                votesCollection.document(voteDocId).set(voteData)
            }
        } catch (e: Exception) {
            throw e
        }
        return currentState.copy(
            upvoteCount = upvoteCount,
            downvoteCount = downvoteCount,
            userVote = newVote
        )
    }
}
//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/engagement/engagement_bars/feature_preview_enagement_footer/di/EngagementFooterKoinModule.kt
package com.openparty.app.features.engagement.engagement_bars.feature_preview_enagement_footer.di

import com.openparty.app.features.engagement.engagement_bars.feature_preview_enagement_footer.data.EngagementRepositoryImpl
import com.openparty.app.features.engagement.engagement_bars.feature_preview_enagement_footer.domain.usecase.ToggleVoteUseCase
import com.openparty.app.features.engagement.engagement_bars.feature_preview_enagement_footer.domain.repository.EngagementRepository
import dev.gitlive.firebase.Firebase
import dev.gitlive.firebase.firestore.FirebaseFirestore
import dev.gitlive.firebase.firestore.firestore
import org.koin.dsl.module

val engagementFooterKoinModule = module {
    single<FirebaseFirestore> { Firebase.firestore }
    single<EngagementRepository> { EngagementRepositoryImpl(get()) }
    single { ToggleVoteUseCase(get()) }
    factory { (discussionId: String, initialState: com.openparty.app.features.engagement.engagement_bars.feature_preview_enagement_footer.domain.model.EngagementFooterState) ->
        com.openparty.app.features.engagement.engagement_bars.feature_preview_enagement_footer.presentation.EngagementFooterViewModel(get(), discussionId, initialState)
    }
}
//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/engagement/engagement_bars/feature_preview_enagement_footer/domain/model/EngagementFooterState.kt
package com.openparty.app.features.engagement.engagement_bars.feature_preview_enagement_footer.domain.model

data class EngagementFooterState(
    val upvoteCount: Int,
    val downvoteCount: Int,
    val commentCount: Int,
    val userVote: VoteType?
)//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/engagement/engagement_bars/feature_preview_enagement_footer/domain/model/VoteType.kt
package com.openparty.app.features.engagement.engagement_bars.feature_preview_enagement_footer.domain.model

enum class VoteType {
    UPVOTE,
    DOWNVOTE
}
//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/engagement/engagement_bars/feature_preview_enagement_footer/domain/repository/EngagementRepository.kt
package com.openparty.app.features.engagement.engagement_bars.feature_preview_enagement_footer.domain.repository

import com.openparty.app.features.engagement.engagement_bars.feature_preview_enagement_footer.domain.model.EngagementFooterState
import com.openparty.app.features.engagement.engagement_bars.feature_preview_enagement_footer.domain.model.VoteType

interface EngagementRepository {
    suspend fun updateVote(
        discussionId: String,
        currentUserId: String,
        currentState: EngagementFooterState,
        newVote: VoteType?
    ): EngagementFooterState
}
//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/engagement/engagement_bars/feature_preview_enagement_footer/domain/usecase/ToggleVoteUseCase.kt
package com.openparty.app.features.engagement.engagement_bars.feature_preview_enagement_footer.domain.usecase

import com.openparty.app.core.shared.domain.DomainResult
import com.openparty.app.core.shared.domain.GlobalLogger.logger
import com.openparty.app.core.shared.domain.error.AppError
import com.openparty.app.features.engagement.engagement_bars.feature_preview_enagement_footer.domain.model.EngagementFooterState
import com.openparty.app.features.engagement.engagement_bars.feature_preview_enagement_footer.domain.model.VoteType
import com.openparty.app.features.engagement.engagement_bars.feature_preview_enagement_footer.domain.repository.EngagementRepository

class ToggleVoteUseCase(
    private val repository: EngagementRepository
) {
    suspend operator fun invoke(
        discussionId: String,
        currentUserId: String,
        currentState: EngagementFooterState,
        voteType: VoteType
    ): DomainResult<EngagementFooterState> {
        logger.i { "ToggleVoteUseCase invoked for discussion $discussionId with voteType $voteType" }
        val newVote = if (currentState.userVote == voteType) null else voteType
        return try {
            val updatedState = repository.updateVote(discussionId, currentUserId, currentState, newVote)
            logger.i { "Vote updated successfully for discussion $discussionId" }
            DomainResult.Success(updatedState)
        } catch (e: Exception) {
            logger.e(e) { "Error updating vote for discussion $discussionId" }
            DomainResult.Failure(AppError.Discussion.General)
        }
    }
}
//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/engagement/engagement_bars/feature_preview_enagement_footer/presentation/EngagementFooter.kt
package com.openparty.app.features.engagement.engagement_bars.feature_preview_enagement_footer.presentation

import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.width
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowDownward
import androidx.compose.material.icons.filled.ArrowUpward
import androidx.compose.material.icons.outlined.ArrowDownward
import androidx.compose.material.icons.outlined.ArrowUpward
import androidx.compose.material.icons.outlined.Chat
import androidx.compose.material3.Icon
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.collectAsState
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import com.openparty.app.features.engagement.engagement_bars.feature_preview_enagement_footer.domain.model.EngagementFooterState
import com.openparty.app.features.engagement.engagement_bars.feature_preview_enagement_footer.domain.model.VoteType
import org.koin.compose.viewmodel.koinViewModel
import org.koin.core.parameter.parametersOf

@Composable
fun EngagementFooter(
    currentUserId: String,
    discussionId: String,
    initialState: EngagementFooterState,
    viewModel: EngagementFooterViewModel =
        koinViewModel { parametersOf(discussionId, initialState) }
) {
    val state = viewModel.state.collectAsState().value
    Row {
        if (state.userVote != VoteType.UPVOTE) {
            Icon(
                imageVector = Icons.Outlined.ArrowUpward,
                contentDescription = "Upvote",
                modifier = Modifier.clickable { viewModel.onUpvoteClicked(currentUserId) }
            )
        } else {
            Icon(
                imageVector = Icons.Filled.ArrowUpward,
                contentDescription = "Upvoted",
                modifier = Modifier.clickable { viewModel.onUpvoteClicked(currentUserId) }
            )
        }
        Text(text = state.upvoteCount.toString())
        Spacer(modifier = Modifier.width(16.dp))
        if (state.userVote != VoteType.DOWNVOTE) {
            Icon(
                imageVector = Icons.Outlined.ArrowDownward,
                contentDescription = "Downvote",
                modifier = Modifier.clickable { viewModel.onDownvoteClicked(currentUserId) }
            )
        } else {
            Icon(
                imageVector = Icons.Filled.ArrowDownward,
                contentDescription = "Downvoted",
                modifier = Modifier.clickable { viewModel.onDownvoteClicked(currentUserId) }
            )
        }
        Text(text = state.downvoteCount.toString())
        Spacer(modifier = Modifier.width(16.dp))
        Icon(
            imageVector = Icons.Outlined.Chat,
            contentDescription = "Comments"
        )
        Text(text = state.commentCount.toString())
    }
}
//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/engagement/engagement_bars/feature_preview_enagement_footer/presentation/EngagementFooterViewModel.kt
package com.openparty.app.features.engagement.engagement_bars.feature_preview_enagement_footer.presentation

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.openparty.app.core.shared.domain.DomainResult
import com.openparty.app.core.shared.domain.GlobalLogger.logger
import com.openparty.app.core.shared.domain.error.AppErrorMapper
import com.openparty.app.features.engagement.engagement_bars.feature_preview_enagement_footer.domain.model.EngagementFooterState
import com.openparty.app.features.engagement.engagement_bars.feature_preview_enagement_footer.domain.model.VoteType
import com.openparty.app.features.engagement.engagement_bars.feature_preview_enagement_footer.domain.usecase.ToggleVoteUseCase
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch

class EngagementFooterViewModel(
    private val toggleVoteUseCase: ToggleVoteUseCase,
    private val discussionId: String,
    initialState: EngagementFooterState
) : ViewModel() {
    private val _state = MutableStateFlow(initialState)
    val state: StateFlow<EngagementFooterState> = _state

    fun onUpvoteClicked(currentUserId: String) {
        viewModelScope.launch {
            when (val result = toggleVoteUseCase(discussionId, currentUserId, _state.value, VoteType.UPVOTE)) {
                is DomainResult.Success -> {
                    _state.value = result.data
                }
                is DomainResult.Failure -> {
                    val errorMessage = AppErrorMapper.getUserFriendlyMessage(result.error)
                    logger.e(result.error) { "Error updating upvote: $errorMessage" }
                    // Optionally, update UI state with error feedback
                }
            }
        }
    }

    fun onDownvoteClicked(currentUserId: String) {
        viewModelScope.launch {
            when (val result = toggleVoteUseCase(discussionId, currentUserId, _state.value, VoteType.DOWNVOTE)) {
                is DomainResult.Success -> {
                    _state.value = result.data
                }
                is DomainResult.Failure -> {
                    val errorMessage = AppErrorMapper.getUserFriendlyMessage(result.error)
                    logger.e(result.error) { "Error updating downvote: $errorMessage" }
                    // Optionally, update UI state with error feedback
                }
            }
        }
    }
}
//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/newsfeed/discussions/feature_discussions_preview/presentation/DiscussionsPreviewScreen.kt
package com.openparty.app.features.newsfeed.discussions.feature_discussions_preview.presentation

import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.ui.Modifier
import org.koin.compose.viewmodel.koinViewModel
import androidx.navigation.NavHostController
import app.cash.paging.compose.collectAsLazyPagingItems
import com.openparty.app.core.shared.presentation.ErrorText
import com.openparty.app.core.shared.presentation.UiEvent
import com.openparty.app.features.newsfeed.discussions.feature_add_discussion.presentation.AddDiscussionButton
import com.openparty.app.features.newsfeed.shared.presentation.BaseFeedScreen
import com.openparty.app.navigation.NavigationFooter
import com.openparty.app.navigation.Screen
import com.openparty.app.features.newsfeed.discussions.shared.domain.model.Discussion
import kotlinx.coroutines.flow.collectLatest

@Composable
fun DiscussionsPreviewScreen(
    navController: NavHostController,
    viewModel: DiscussionsPreviewViewModel = koinViewModel()
) {
    val lazyDiscussions = viewModel.discussions.collectAsLazyPagingItems()
    val uiEvent = viewModel.uiEvent
    val uiState by viewModel.uiState.collectAsState()
    val currentUserId by viewModel.currentUserId.collectAsState()

    LaunchedEffect(uiEvent) {
        uiEvent.collectLatest { event ->
            when (event) {
                is UiEvent.Navigate -> {
                    navController.navigate(event.destination)
                }
            }
        }
    }

    Box(modifier = Modifier.fillMaxSize()) {
        Column(modifier = Modifier.fillMaxSize()) {
            Box(modifier = Modifier.weight(1f)) {
                if (currentUserId != null) {
                    BaseFeedScreen<Discussion>(
                        items = lazyDiscussions,
                        emptyPlaceholder = "No discussions yet..."
                    ) { discussion ->
                        if (discussion != null) {
                            DiscussionCard(
                                discussion = discussion,
                                currentUserId = currentUserId!!  // using the fetched user ID
                            ) {
                                viewModel.onDiscussionSelected(discussion.discussionId)
                            }
                        }
                    }
                    AddDiscussionButton {
                        navController.navigate(Screen.AddDiscussion.route)
                    }
                } else {
                    // Optionally, display a loading indicator or placeholder until user ID is available.
                }
            }
            ErrorText(errorMessage = uiState.errorMessage)
        }
    }
}
//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/newsfeed/discussions/feature_discussions_preview/presentation/DiscussionsPreviewViewModel.kt
package com.openparty.app.features.newsfeed.discussions.feature_discussions_preview.presentation

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import androidx.paging.PagingData
import androidx.paging.cachedIn
import com.openparty.app.core.analytics.domain.usecase.TrackDiscussionSelectedUseCase
import com.openparty.app.core.shared.domain.DomainResult
import com.openparty.app.core.shared.domain.error.AppErrorMapper
import com.openparty.app.core.shared.presentation.UiEvent
import com.openparty.app.core.shared.presentation.UiState
import com.openparty.app.features.newsfeed.discussions.shared.domain.model.Discussion
import com.openparty.app.features.newsfeed.discussions.feature_discussions_preview.domain.usecase.GetDiscussionsUseCase
import com.openparty.app.features.startup.feature_authentication.domain.usecase.GetCurrentUserIdUseCase
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.SharedFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch
import com.openparty.app.core.shared.domain.GlobalLogger.logger
import com.openparty.app.navigation.Screen

class DiscussionsPreviewViewModel(
    private val getDiscussionsUseCase: GetDiscussionsUseCase,
    private val trackDiscussionSelectedUseCase: TrackDiscussionSelectedUseCase,
    private val getCurrentUserIdUseCase: GetCurrentUserIdUseCase
) : ViewModel() {

    private val _uiState = MutableStateFlow(UiState())
    val uiState: StateFlow<UiState> = _uiState

    private val _uiEvent = MutableSharedFlow<UiEvent>()
    val uiEvent: SharedFlow<UiEvent> = _uiEvent

    private var _discussions: kotlinx.coroutines.flow.Flow<PagingData<Discussion>> =
        kotlinx.coroutines.flow.flow { }
    val discussions: kotlinx.coroutines.flow.Flow<PagingData<Discussion>>
        get() = _discussions

    private val _currentUserId = MutableStateFlow<String?>(null)
    val currentUserId: StateFlow<String?> = _currentUserId

    init {
        loadCurrentUserId()
        loadDiscussions()
    }

    private fun loadCurrentUserId() {
        viewModelScope.launch {
            when (val result = getCurrentUserIdUseCase()) {
                is DomainResult.Success -> {
                    _currentUserId.value = result.data
                    logger.i { "Fetched current user id: ${result.data}" }
                }
                is DomainResult.Failure -> {
                    val errorMessage = AppErrorMapper.getUserFriendlyMessage(result.error)
                    logger.e(result.error) { "Error fetching current user id: $errorMessage" }
                }
            }
        }
    }

    private fun loadDiscussions() {
        viewModelScope.launch {
            _uiState.value = _uiState.value.copy(isLoading = true)
            when (val result = getDiscussionsUseCase()) {
                is DomainResult.Success -> {
                    _discussions = result.data.cachedIn(viewModelScope)
                }
                is DomainResult.Failure -> {
                    val errorMessage = AppErrorMapper.getUserFriendlyMessage(result.error)
                    logger.e(result.error) { "Error loading discussions" }
                    _uiState.value = _uiState.value.copy(isLoading = false, errorMessage = errorMessage)
                }
            }
        }
    }

    fun onDiscussionSelected(discussionId: String) {
        viewModelScope.launch {
            when (val result = trackDiscussionSelectedUseCase(discussionId)) {
                is DomainResult.Success -> logger.i { "Discussion selected event tracked: $discussionId" }
                is DomainResult.Failure -> logger.e { "Failed to track discussion selected event for ID: $discussionId" }
            }
            _uiEvent.emit(UiEvent.Navigate(Screen.DiscussionsArticle.createRoute(discussionId)))
        }
    }
}
//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/newsfeed/discussions/feature_discussions_preview/presentation/DiscussionCard.kt
package com.openparty.app.features.newsfeed.discussions.feature_discussions_preview.presentation

import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.Card
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.dp
import com.openparty.app.features.newsfeed.discussions.shared.domain.model.Discussion
import com.openparty.app.features.engagement.engagement_bars.feature_preview_enagement_footer.domain.model.EngagementFooterState
import com.openparty.app.features.engagement.engagement_bars.feature_preview_enagement_footer.presentation.EngagementFooter

@Composable
fun DiscussionCard(
    discussion: Discussion,
    currentUserId: String,
    onClick: () -> Unit
) {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .padding(8.dp)
            .clickable { onClick() }
    ) {
        Column(modifier = Modifier.padding(16.dp)) {
            Text(
                text = discussion.title,
                style = MaterialTheme.typography.titleLarge,
                maxLines = 1,
                overflow = TextOverflow.Ellipsis
            )
            Spacer(modifier = Modifier.height(8.dp))
            Text(
                text = discussion.contentText,
                style = MaterialTheme.typography.bodyMedium,
                maxLines = 2,
                overflow = TextOverflow.Ellipsis
            )
            Spacer(modifier = Modifier.height(16.dp))
            EngagementFooter(
                currentUserId = currentUserId,
                discussionId = discussion.discussionId,
                initialState = EngagementFooterState(
                    upvoteCount = discussion.upvoteCount,
                    downvoteCount = discussion.downvoteCount,
                    commentCount = discussion.commentCount,
                    userVote = null
                )
            )
        }
    }
}
//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/newsfeed/discussions/feature_discussions_preview/di/DiscussionsKoinModule.kt
package com.openparty.app.features.newsfeed.discussions.feature_discussions_preview.di

import com.openparty.app.features.newsfeed.discussions.shared.domain.repository.DiscussionRepository
import com.openparty.app.features.newsfeed.discussions.shared.data.repository.DiscussionRepositoryImpl
import com.openparty.app.features.newsfeed.discussions.feature_discussions_preview.domain.usecase.GetDiscussionsUseCase
import com.openparty.app.features.newsfeed.discussions.feature_discussions_preview.presentation.DiscussionsPreviewViewModel
import dev.gitlive.firebase.Firebase
import dev.gitlive.firebase.firestore.firestore
import org.koin.core.module.dsl.viewModel
import org.koin.dsl.module

val discussionsKoinModule = module {
    single<DiscussionRepository> { DiscussionRepositoryImpl(get()) }
    single { Firebase.firestore }
    single { GetDiscussionsUseCase(get()) }
    viewModel { DiscussionsPreviewViewModel(get(), get(), get()) }
}


---------

Notes: 
- When you give code, give the entire file, don't abbreviate anything
- Don't leave comments in the code, except a comment at a top of the file stating the file path
    - e.g. //File: composeApp/src/androidMain/kotlin/com/openparty/app/main/MainViewModel.kt
- Use the cleanest, most robust, scalable architecture you can 
- For every gradle dependency, give it in this format: implementation("org.jetbrains.androidx.lifecycle:lifecycle-viewmodel-compose:2.8.2")
    - don't give it in the libs.version.toml format. i.e. don't do this - implementation(compose.components.uiToolingPreview)
    - The exception to this is the dependencies that are already in my gradle files, leave them in the original format
- I'm using koin compose multiplatform for my depedency injection, that means that in my screen classes, I use this import - import org.koin.compose.viewmodel.koinViewModel
    - And the view model is injected like this - viewModel: DiscussionArticleViewModel = koinViewModel()
    - This might look odd to you since it's a new approach but don't change it, assume it's correct 
- Keep all business logic in use cases where appropriate 
- Whenenever you use use cases, return the DomainResult Success or Failure 
- Add Kermit logs where appropriate 
- Whenever you call a use case (for example in the view model), handle the DomainResult.Success or Failure case and use this: val errorMessage = AppErrorMapper.getUserFriendlyMessage(result.error) - to return a friendly error to the user
- Whenever you use a library in commonMain code, make sure that it's a library that's compatible with compose multiplatform

---------

I've given you my feature_preview_engagement_footer code above 

The point of this footer is that it's an engagement bar that is attached to every discussion card 

in the firebase database, each discussion card has a number of upvotes, downvotes, comments etc 

The engagement footer lets the user add upvotes and downvotes to a given discussion card 

however this isn't working right now 

instead of the discussion footer working for a specific card, every card has the same engagemetn footer, attached to the same discussion 

so if you upvote one discussion, it upvotes all of them. 

why is this happening? What's the flaw in the design? 