package com.openparty.app.core.shared.domain

import co.touchlab.kermit.Logger

object GlobalLogger {
    val logger: Logger = Logger.withTag("GlobalLogger")
}

//File: composeApp/src/commonMain/kotlin/com/openparty/app/core/shared/domain/DomainResult.kt

package com.openparty.app.core.shared.domain

import com.openparty.app.core.shared.domain.error.AppError

sealed class DomainResult<out T> {
    data class Success<out T>(val data: T) : DomainResult<T>()
    data class Failure(val error: AppError) : DomainResult<Nothing>()
}

--
package com.openparty.app.core.shared.domain.error

sealed class AppError : Exception() {

    sealed class Navigation : AppError() {
        object General : AppError()
        object DetermineAuthStates : AppError()
    }

    sealed class Analytics : AppError() {
        object TrackAppOpen : AppError()
        object IdentifyUser : AppError()
        object TrackDiscussionsPreviewClick : AppError()
        object TrackCouncilMeetingPreviewClick : AppError()
        object TrackDiscussionPosted : AppError()
        object TrackCommentPosted : AppError()
    }
.......

--
package com.openparty.app.core.shared.domain.error

import kotlin.reflect.KClass

object AppErrorMapper {

    fun getUserFriendlyMessage(
        error: AppError,
        customOverrides: Map<KClass<out AppError>, String>? = null
    ): String {
        val overrideMessage = customOverrides?.get(error::class)
        if (overrideMessage != null) {
            return overrideMessage
        }
        return when (error) {
            // Authentication
            is AppError.Authentication.SignIn -> "We couldn't sign you in. Please check your credentials."
            is AppError.Authentication.EmailVerification -> "Verification email couldn't be sent. Please try again in a while."
            is AppError.Authentication.RefreshToken -> "There was an issue sending your request. Please try again in a while."
            is AppError.Authentication.Logout -> "Logout failed. Please try again in a while."
            is AppError.Authentication.General -> "Unknown authentication error."
            is AppError.Authentication.GetUser -> "Unable to fetch user."
            is AppError.Authentication.GetUserId -> "Unable to fetch user."
            is AppError.Authentication.Register -> "Registration failed. Please try again in a while."
            is AppError.Authentication.UserAlreadyExists -> "Cannot create a user that already exists."
..........

- Also on a side note, i'm using compose multiplatform with the koin compose library. This is an unusual library but it's important that any code you give me uses it
- I'm going to give you code from my splash feature below as an example of using koin compose library 

package com.openparty.app.features.startup.feature_splash.di

import com.openparty.app.features.startup.feature_splash.presentation.SplashViewModel
import org.koin.core.module.dsl.viewModel
import org.koin.core.module.Module
import org.koin.dsl.module

val splashModule: Module = module {
    viewModel {
        SplashViewModel(
            determineAuthStatesUseCase = get(),
            authFlowNavigationMapper = get()
        )
    }
}
package com.openparty.app.features.startup.feature_splash.presentation

import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.navigation.NavHostController
import com.openparty.app.core.shared.presentation.ErrorText
import com.openparty.app.core.shared.presentation.UiEvent
import kotlinx.coroutines.flow.collectLatest
import org.koin.compose.viewmodel.koinViewModel

@Composable
fun SplashScreen(
    navController: NavHostController,
    viewModel: SplashViewModel = koinViewModel()
) {
    val uiState by viewModel.uiState.collectAsState()

    LaunchedEffect(Unit) {
        viewModel.uiEvent.collectLatest { event ->
            when (event) {
                is UiEvent.Navigate -> {
                    navController.navigate(event.destination) {
                        popUpTo(0) { inclusive = true }
                    }
                }
            }
        }
    }

    if (uiState.errorMessage != null) {
        ErrorText(errorMessage = uiState.errorMessage)
    }
}
//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/startup/feature_splash/presentation/SplashViewModel.kt
// File: composeApp/src/commonMain/kotlin/com/openparty/app/features/startup/feature_splash/presentation/SplashViewModel.kt
package com.openparty.app.features.startup.feature_splash.presentation

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.openparty.app.core.shared.domain.DomainResult
import com.openparty.app.core.shared.domain.error.AppErrorMapper
import com.openparty.app.core.shared.presentation.UiEvent
import com.openparty.app.core.shared.presentation.UiState
import com.openparty.app.features.startup.feature_authentication.domain.usecase.DetermineAuthStatesUseCase
import com.openparty.app.features.startup.feature_authentication.presentation.AuthFlowNavigationMapper
import com.openparty.app.core.shared.domain.GlobalLogger.logger
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.SharedFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch

class SplashViewModel(
    private val determineAuthStatesUseCase: DetermineAuthStatesUseCase,
    private val authFlowNavigationMapper: AuthFlowNavigationMapper
) : ViewModel() {

    private val _uiState = MutableStateFlow(UiState())
    val uiState: StateFlow<UiState> = _uiState

    private val _uiEvent = MutableSharedFlow<UiEvent>()
    val uiEvent: SharedFlow<UiEvent> = _uiEvent

    init {
        logger.i { "SplashViewModel initialized" }
        viewModelScope.launch {
            navigateToNextAuthScreen()
        }
    }

    private suspend fun navigateToNextAuthScreen() {
        logger.i { "Starting navigation process in SplashViewModel" }
        _uiState.value = _uiState.value.copy(isLoading = true)
        when (val authStatesResult = determineAuthStatesUseCase()) {
            is DomainResult.Success -> {
                logger.i { "DetermineAuthStatesUseCase succeeded with states: ${authStatesResult.data}" }
                val destination = authFlowNavigationMapper.determineDestination(authStatesResult.data)
                _uiState.value = _uiState.value.copy(isLoading = false, errorMessage = null)
                logger.i { "Navigating to destination: ${destination.route}" }
                _uiEvent.emit(UiEvent.Navigate(destination.route))
            }
            is DomainResult.Failure -> {
                logger.e { "DetermineAuthStatesUseCase failed with error: ${authStatesResult.error}" }
                val errorMessage = AppErrorMapper.getUserFriendlyMessage(authStatesResult.error)
                _uiState.value = _uiState.value.copy(isLoading = false, errorMessage = errorMessage)
            }
        }
    }
}

- So notice that the SplashScreen uses this import: 
    - import org.koin.compose.viewmodel.koinViewModel
- And the SplashModule uses this: 
    - import org.koin.core.module.dsl.viewModel
- and it looks like this: 
viewModel {
        SplashViewModel(
            determineAuthStatesUseCase = get(),
            authFlowNavigationMapper = get()
        )
    }
- Make sure that whenever you are injecting view models using koin, it's done using koin compose and it's done using the same method as the splash view model
- Also notice how the splash viewmodel handles errors: 
when (val authStatesResult = determineAuthStatesUseCase()) {
            is DomainResult.Success -> {
                val destination = authFlowNavigationMapper.determineDestination(authStatesResult.data)
                _uiState.value = _uiState.value.copy(isLoading = false, errorMessage = null)
                _uiEvent.emit(UiEvent.Navigate(destination.route))
            }
            is DomainResult.Failure -> {
                val errorMessage = AppErrorMapper.getUserFriendlyMessage(authStatesResult.error)
                _uiState.value = _uiState.value.copy(isLoading = false, errorMessage = errorMessage)
            }
        }
- It handles them in a when statement
- If it's a success it handles the success
- If it's a failure, it unwraps the DomainResult Failure message
- It uses AppErrorMapper.getUserFriendlyMessage to map the error code to a friendly message for hte user 
- Then it uses this: 
    - _uiState.value = _uiState.value.copy(isLoading = false, errorMessage = errorMessage)
- To send an event to the SplashScreen to trigger the ErrorText in the SplashScreen: 
if (uiState.errorMessage != null) {
        ErrorText(errorMessage = uiState.errorMessage)
    }
- Make sure that whenever you are handling use cases in view models, you do it using the above pattern 
- All use cases will return a DomainResult, if it's a failure you map it to a user friendly message and send an event about it to the user 
- Also notice that navigation is done using this in the SplashScreen:
LaunchedEffect(Unit) {
        viewModel.uiEvent.collectLatest { event ->
            when (event) {
                is UiEvent.Navigate -> {
                    navController.navigate(event.destination) {
                        popUpTo(0) { inclusive = true }
                    }
                }
            }
        }
    }
- This is standard across my app. Whenever you do navigation, it should be handled in the screen
- All navigation based logic should be done in places like the view model or use cases, then the view model emits a navigation event for the screen to handle 
- This is standard across my app, so whenever you are doing navigation you should follow this pattern
- Also notice that my SplashViewModel doesn't contain any business logic
    - Instead it has use cases that handle all business logic and it injects them 
    - This again is standard across my app, all business logic is handled in use cases
    - Whenever you want to do business logic, it should be in use cases (unless it's logic that is tightly tied to the user interface)
- Also notice how the logging in splashviewmodel is done with kermit logging
    - It uses my global logger using kermit
    - Then it just implements that logging 
    - Use logging in the code you give me whwere appropriate, but always use the kermit global logger in the same way the SplashViewModel does

.............

- Also on another note, i want my use cases to be set up a specific way so i'll give you an example of that

//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/startup/feature_authentication/domain/usecase/GetCurrentUserIdUseCase.kt
package com.openparty.app.features.startup.feature_authentication.domain.usecase

import com.openparty.app.core.shared.domain.DomainResult
import com.openparty.app.core.shared.domain.error.AppError
import com.openparty.app.core.shared.domain.GlobalLogger.logger
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext

class GetCurrentUserIdUseCase(
    private val getFirebaseUserUseCase: GetFirebaseUserUseCase
) {
    suspend operator fun invoke(): DomainResult<String> {
        return withContext(Dispatchers.Default) {
            logger.i { "GetCurrentUserIdUseCase invoked" }
            try {
                logger.i { "Fetching current user" }
                when (val userResult = getFirebaseUserUseCase()) {
                    is DomainResult.Success -> {
                        logger.i { "User fetched successfully: UID=${userResult.data.uid}" }
                        DomainResult.Success(userResult.data.uid)
                    }
                    is DomainResult.Failure -> {
                        logger.e { "Failed to fetch user: ${userResult.error}" }
                        DomainResult.Failure(AppError.Authentication.GetUserId)
                    }
                }
            } catch (e: Throwable) {
                logger.e(e) { "Unexpected error while fetching user ID: ${e.message}" }
                DomainResult.Failure(AppError.Authentication.GetUserId)
            }
        }
    }
}

- So whenever there is a success, the use case wraps the success in a DomainResult and returns the relevant data
- It also has a catch statement 
- It uses kermit logging with the global logger as before
- Whenever there is a catch or a fail case, it returns the same AppError wrapped in a DomainResult.Failure
- The reason is because the point of the AppErrors is to create user friendly messages in the user interface 
- All the actual debugging is done by developers using log statements, the AppErrors are just to create user messages
- For that reason, the only thing the AppErrors represent is a simple Error about where the app failed 
- For example, if i have this -  AppError.Authentication.GetUserId
    - I know that can be mapped to a user friendly message about getting the user id such as "Failed to find the user. Try again later."
- Whenever you have use cases, it should follow the above pattern 
- Use logging, a catch statement, wrap every result in a DomainResult, have it be a DomainResult.Success for success and DomainResult.Failure for anything else
- In a DomainResult.Failure, put an error code which relates to that specific use case
- For example, if the above use case, it's called GetCurrentUserIdUseCase and returns AppError.Authentication.GetUserId
    - i.e. the AppError reflects the use case where the app failed
- You will probably need to create new AppErrors when you create a new use case since one likely won't exist
- Remember that only your use cases should be returning DomainResult object, you don't need to do this for every class
- For example this is wrong: 
class PrivacyPolicyRepositoryImpl : PrivacyPolicyRepository {
    override suspend fun acceptPrivacyPolicy(): DomainResult<Unit> {
        return DomainResult.Success(Unit)
    }
}
- There is no reason to wrap a repository implementation in a DomainResult

--

OpenParty/
├── build.gradle.kts
├── gradle/
│   ├── libs.versions.toml
│   └── wrapper/
│       ├── gradle-wrapper.jar
│       └── gradle-wrapper.properties
├── gradle.properties
├── gradlew
├── gradlew.bat
├── composeApp/
│   ├── build.gradle.kts
│   └── src/
│       ├── androidMain/
│       │   ├── AndroidManifest.xml
│       │   └── kotlin/
│       │       └── com/
│       │           └── openparty/
│       │               └── app/
│       │                   └── [Placeholder]
│       ├── commonMain/
│       │   └── kotlin/
│       │       └── com/
│       │           └── openparty/
│       │               └── app/
│       │                   └── [Placeholder]
│       └── iosMain/
│           └── kotlin/
│               └── com/
│                   └── openparty/
│                       └── app/
│                           └── [Placeholder]
└── iosApp/
    ├── configuration/
    ├── iosApp/
    │   ├── Assets.xcassets/
    │   ├── ContentView.swift
    │   ├── Info.plist
    │   ├── iOSApp.swift
    │   ├── iosApp.xcodeproj/
    │   └── Preview Content/
    └── iosApp.xcodeproj/

---------

//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/newsfeed/discussions/feature_discussions_preview/di/DiscussionsKoinModule.kt
package com.openparty.app.features.newsfeed.discussions.feature_discussions_preview.di

import com.openparty.app.features.newsfeed.discussions.shared.domain.repository.DiscussionRepository
import com.openparty.app.features.newsfeed.discussions.shared.data.repository.DiscussionRepositoryImpl
import com.openparty.app.features.newsfeed.discussions.feature_discussions_preview.domain.usecase.GetDiscussionsUseCase
import com.openparty.app.features.newsfeed.discussions.feature_discussions_preview.presentation.DiscussionsPreviewViewModel
import dev.gitlive.firebase.Firebase
import dev.gitlive.firebase.firestore.firestore
import org.koin.core.module.dsl.viewModel
import org.koin.dsl.module

val discussionsKoinModule = module {
    single<DiscussionRepository> { DiscussionRepositoryImpl(get()) }
    single { Firebase.firestore }
    single { GetDiscussionsUseCase(get()) }
    viewModel { DiscussionsPreviewViewModel(get(), get(), get(), get()) }
}
//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/newsfeed/discussions/feature_discussions_preview/domain/usecase/GetDiscussionsUseCase.kt
package com.openparty.app.features.newsfeed.discussions.feature_discussions_preview.domain.usecase

import androidx.paging.PagingData
import com.openparty.app.core.shared.domain.DomainResult
import com.openparty.app.core.shared.domain.error.AppError
import com.openparty.app.features.newsfeed.discussions.shared.domain.model.Discussion
import com.openparty.app.features.newsfeed.discussions.shared.domain.repository.DiscussionRepository
import kotlinx.coroutines.flow.Flow
import com.openparty.app.core.shared.domain.GlobalLogger.logger

class GetDiscussionsUseCase(
    private val repository: DiscussionRepository
) {
    operator fun invoke(): DomainResult<Flow<PagingData<Discussion>>> {
        logger.i { "GetDiscussionsUseCase invoked" }
        return try {
            logger.i { "Fetching discussions from repository" }
            val discussionsFlow = repository.getDiscussions()
            logger.i { "Successfully fetched discussions flow" }
            DomainResult.Success(discussionsFlow)
        } catch (e: Exception) {
            logger.e(e) { "Error occurred while fetching discussions" }
            DomainResult.Failure(AppError.Discussion.FetchDiscussions)
        }
    }
}
//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/newsfeed/discussions/feature_discussions_preview/presentation/DiscussionCard.kt
package com.openparty.app.features.newsfeed.discussions.feature_discussions_preview.presentation

import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.Card
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.ListItem
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.ModalBottomSheet
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.getValue
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.dp
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.MoreVert
import androidx.compose.material.icons.filled.Block
import androidx.compose.material.icons.filled.VisibilityOff
import com.openparty.app.features.engagement.engagement_bars.feature_preview_enagement_footer.presentation.EngagementFooter
import com.openparty.app.features.engagement.engagement_bars.feature_preview_enagement_footer.domain.model.EngagementFooterState
import com.openparty.app.features.newsfeed.discussions.shared.domain.model.Discussion

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun DiscussionCard(
    discussion: Discussion,
    currentUserId: String,
    onClick: () -> Unit,
    onBlockUser: (blockedUserId: String) -> Unit
) {
    var showBottomSheet by remember { mutableStateOf(false) }
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .padding(8.dp)
    ) {
        Box(modifier = Modifier.fillMaxSize()) {
            Column(
                modifier = Modifier
                    .clickable { onClick() }
                    .padding(16.dp)
            ) {
                Text(
                    text = discussion.title,
                    style = MaterialTheme.typography.titleLarge,
                    maxLines = 1,
                    overflow = TextOverflow.Ellipsis
                )
                Spacer(modifier = Modifier.height(8.dp))
                Text(
                    text = discussion.contentText,
                    style = MaterialTheme.typography.bodyMedium,
                    maxLines = 2,
                    overflow = TextOverflow.Ellipsis
                )
                Spacer(modifier = Modifier.height(16.dp))
                EngagementFooter(
                    currentUserId = currentUserId,
                    discussionId = discussion.discussionId,
                    initialState = EngagementFooterState(
                        upvoteCount = discussion.upvoteCount,
                        downvoteCount = discussion.downvoteCount,
                        commentCount = discussion.commentCount,
                        userVote = null
                    )
                )
            }
            IconButton(
                onClick = { showBottomSheet = true },
                modifier = Modifier.align(Alignment.TopEnd)
            ) {
                Icon(
                    imageVector = Icons.Default.MoreVert,
                    contentDescription = "Settings"
                )
            }
        }
    }
    if (showBottomSheet) {
        ModalBottomSheet(
            onDismissRequest = { showBottomSheet = false }
        ) {
            ListItem(
                headlineContent = { Text("Block Account") },
                leadingContent = {
                    Icon(
                        imageVector = Icons.Default.Block,
                        contentDescription = "Block Account"
                    )
                },
                modifier = Modifier.clickable {
                    showBottomSheet = false
                    onBlockUser(discussion.userId)
                }
            )
            ListItem(
                headlineContent = { Text("Hide Content") },
                leadingContent = {
                    Icon(
                        imageVector = Icons.Default.VisibilityOff,
                        contentDescription = "Hide Content"
                    )
                },
                modifier = Modifier.clickable { showBottomSheet = false }
            )
        }
    }
}
//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/newsfeed/discussions/feature_discussions_preview/presentation/DiscussionsPreviewScreen.kt
package com.openparty.app.features.newsfeed.discussions.feature_discussions_preview.presentation

import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.ui.Modifier
import org.koin.compose.viewmodel.koinViewModel
import androidx.navigation.NavHostController
import app.cash.paging.compose.collectAsLazyPagingItems
import com.openparty.app.core.shared.presentation.ErrorText
import com.openparty.app.core.shared.presentation.UiEvent
import com.openparty.app.features.newsfeed.discussions.feature_add_discussion.presentation.AddDiscussionButton
import com.openparty.app.features.newsfeed.shared.presentation.BaseFeedScreen
import com.openparty.app.navigation.NavigationFooter
import com.openparty.app.navigation.Screen
import com.openparty.app.features.newsfeed.discussions.shared.domain.model.Discussion
import kotlinx.coroutines.flow.collectLatest

@Composable
fun DiscussionsPreviewScreen(
    navController: NavHostController,
    viewModel: DiscussionsPreviewViewModel = koinViewModel()
) {
    val lazyDiscussions = viewModel.discussions.collectAsLazyPagingItems()
    val uiEvent = viewModel.uiEvent
    val uiState by viewModel.uiState.collectAsState()
    val currentUserId by viewModel.currentUserId.collectAsState()

    LaunchedEffect(uiEvent) {
        uiEvent.collectLatest { event ->
            when (event) {
                is UiEvent.Navigate -> {
                    navController.navigate(event.destination)
                }
            }
        }
    }

    Box(modifier = Modifier.fillMaxSize()) {
        Column(modifier = Modifier.fillMaxSize()) {
            Box(modifier = Modifier.weight(1f)) {
                if (currentUserId != null) {
                    BaseFeedScreen<Discussion>(
                        items = lazyDiscussions,
                        emptyPlaceholder = "No discussions yet..."
                    ) { discussion ->
                        if (discussion != null) {
                            DiscussionCard(
                                discussion = discussion,
                                currentUserId = currentUserId!!,
                                onClick = { viewModel.onDiscussionSelected(discussion.discussionId) },
                                onBlockUser = { blockedUserId ->
                                    viewModel.onBlockUser(blockedUserId)
                                }
                            )
                        }
                    }
                    AddDiscussionButton {
                        navController.navigate(Screen.AddDiscussion.route)
                    }
                } else {
                    // Optionally, display a loading indicator or placeholder until user ID is available.
                }
            }
            ErrorText(errorMessage = uiState.errorMessage)
        }
    }
}//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/newsfeed/discussions/feature_discussions_preview/presentation/DiscussionsPreviewViewModel.kt
package com.openparty.app.features.newsfeed.discussions.feature_discussions_preview.presentation

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import androidx.paging.PagingData
import androidx.paging.cachedIn
import androidx.paging.filter  // Import the PagingData filter extension
import com.openparty.app.core.analytics.domain.usecase.TrackDiscussionSelectedUseCase
import com.openparty.app.core.shared.domain.DomainResult
import com.openparty.app.core.shared.domain.error.AppErrorMapper
import com.openparty.app.core.shared.presentation.UiEvent
import com.openparty.app.core.shared.presentation.UiState
import com.openparty.app.features.newsfeed.discussions.shared.domain.model.Discussion
import com.openparty.app.features.newsfeed.discussions.feature_discussions_preview.domain.usecase.GetDiscussionsUseCase
import com.openparty.app.features.shared.feature_user.domain.usecase.BlockUserUseCase
import com.openparty.app.features.shared.feature_user.domain.usecase.GetUserUseCase
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.SharedFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.launch
import com.openparty.app.core.shared.domain.GlobalLogger.logger
import com.openparty.app.navigation.Screen

class DiscussionsPreviewViewModel(
    private val getDiscussionsUseCase: GetDiscussionsUseCase,
    private val trackDiscussionSelectedUseCase: TrackDiscussionSelectedUseCase,
    private val blockUserUseCase: BlockUserUseCase,
    private val getUserUseCase: GetUserUseCase
) : ViewModel() {

    private val _uiState = MutableStateFlow(UiState())
    val uiState: StateFlow<UiState> = _uiState

    private val _uiEvent = MutableSharedFlow<UiEvent>()
    val uiEvent: SharedFlow<UiEvent> = _uiEvent

    private var _discussions: kotlinx.coroutines.flow.Flow<PagingData<Discussion>> =
        kotlinx.coroutines.flow.flow { }
    val discussions: kotlinx.coroutines.flow.Flow<PagingData<Discussion>>
        get() = _discussions

    private val _currentUserId = MutableStateFlow<String?>(null)
    val currentUserId: StateFlow<String?> = _currentUserId

    private val _blockedUsers = MutableStateFlow<List<String>>(emptyList())
    val blockedUsers: StateFlow<List<String>> = _blockedUsers

    init {
        loadUser()
        loadDiscussions()
    }

    private fun loadUser() {
        viewModelScope.launch {
            when (val result = getUserUseCase()) {
                is DomainResult.Success -> {
                    val user = result.data
                    _currentUserId.value = user.userId
                    _blockedUsers.value = user.blockedUsers
                    logger.i { "Loaded user: ${user.userId} with blocked users: ${user.blockedUsers}" }
                }
                is DomainResult.Failure -> {
                    val errorMessage = AppErrorMapper.getUserFriendlyMessage(result.error)
                    logger.e(result.error) { "Error loading user: $errorMessage" }
                }
            }
        }
    }

    private fun loadDiscussions() {
        viewModelScope.launch {
            _uiState.value = _uiState.value.copy(isLoading = true)
            when (val result = getDiscussionsUseCase()) {
                is DomainResult.Success -> {
                    _discussions = result.data
                        .cachedIn(viewModelScope)
                        .map { pagingData ->
                            pagingData.filter { discussion ->
                                !_blockedUsers.value.contains(discussion.userId)
                            }
                        }
                    _uiState.value = _uiState.value.copy(isLoading = false, errorMessage = null)
                }
                is DomainResult.Failure -> {
                    val errorMessage = AppErrorMapper.getUserFriendlyMessage(result.error)
                    logger.e(result.error) { "Error loading discussions" }
                    _uiState.value = _uiState.value.copy(isLoading = false, errorMessage = errorMessage)
                }
            }
        }
    }

    fun onDiscussionSelected(discussionId: String) {
        viewModelScope.launch {
            when (val result = trackDiscussionSelectedUseCase(discussionId)) {
                is DomainResult.Success -> logger.i { "Discussion selected event tracked: $discussionId" }
                is DomainResult.Failure -> logger.e { "Failed to track discussion selected event for ID: $discussionId" }
            }
            _uiEvent.emit(UiEvent.Navigate(Screen.DiscussionsArticle.createRoute(discussionId)))
        }
    }

    fun onBlockUser(authorId: String) {
        viewModelScope.launch {
            val currentUser = _currentUserId.value
            if (currentUser == null) {
                logger.e { "Current user ID is null, cannot block user" }
                return@launch
            }
            when (val result = blockUserUseCase(currentUser, authorId)) {
                is DomainResult.Success -> {
                    logger.i { "Successfully blocked user: $authorId" }
                    loadUser() // Reload user to update blocked users list
                }
                is DomainResult.Failure -> {
                    val errorMessage = AppErrorMapper.getUserFriendlyMessage(result.error)
                    logger.e(result.error) { "Failed to block user: $authorId" }
                    _uiState.value = _uiState.value.copy(errorMessage = errorMessage)
                }
            }
        }
    }
}
// File: composeApp/src/commonMain/kotlin/com/openparty/app/features/newsfeed/discussions/shared/data/repository/DiscussionRepositoryImpl.kt
package com.openparty.app.features.newsfeed.discussions.shared.data.repository

import androidx.paging.PagingData
import com.openparty.app.core.shared.domain.DomainResult
import com.openparty.app.core.shared.domain.error.AppError
import com.openparty.app.features.newsfeed.discussions.shared.domain.repository.DiscussionRepository
import com.openparty.app.features.newsfeed.discussions.shared.domain.model.Discussion
import com.openparty.app.features.newsfeed.shared.data.datasource.FirebaseNewsfeedDataSource
import com.openparty.app.features.newsfeed.shared.data.repository.FirestoreRepository
import kotlinx.coroutines.flow.Flow
import com.openparty.app.core.shared.domain.GlobalLogger.logger
import dev.gitlive.firebase.firestore.FirebaseFirestore
import kotlin.random.Random
import kotlinx.serialization.serializer

class DiscussionRepositoryImpl(
    private val firestore: FirebaseFirestore
) : FirestoreRepository<Discussion>(
    dataSource = FirebaseNewsfeedDataSource(
        firestore = firestore,
        collectionName = "discussions",
        orderByField = "upvoteCount",
        transform = { documentSnapshot ->
            try {
                logger.i { "Transforming document snapshot to Discussion object: ${documentSnapshot.id}" }
                val decoded: Discussion? = try {
                    documentSnapshot.data(Discussion.serializer())
                } catch (e: Exception) {
                    null
                }
                decoded?.copy(discussionId = documentSnapshot.id)
            } catch (e: Exception) {
                logger.e(e) { "Error transforming document snapshot to Discussion object: ${documentSnapshot.id}" }
                null
            }
        }
    ),
    error = AppError.Discussion.General
), DiscussionRepository {

    override fun getDiscussions(): Flow<PagingData<Discussion>> {
        logger.i { "Fetching discussions from DiscussionRepositoryImpl" }
        return getPagedItems()
    }

    override suspend fun getDiscussionById(discussionId: String): DomainResult<Discussion> {
        logger.i { "Fetching discussion by ID: $discussionId from DiscussionRepositoryImpl" }
        return getItemById(discussionId)
    }

    override suspend fun addDiscussion(discussion: Discussion): DomainResult<Discussion> {
        logger.i { "addDiscussion invoked for discussion: ${discussion.title}" }
        return try {
            val generatedId = Random.nextLong().toString()
            val document = firestore.collection("discussions").document(generatedId)
            logger.i { "Generated new document ID: ${document.id} for discussion: ${discussion.title}" }
            val discussionWithId = discussion.copy(discussionId = document.id)
            document.set(discussionWithId)
            logger.i { "Successfully added discussion with ID: ${discussionWithId.discussionId}" }
            DomainResult.Success(discussionWithId)
        } catch (e: Exception) {
            logger.e(e) { "Error adding discussion: ${discussion.title}" }
            DomainResult.Failure(AppError.Discussion.General)
        }
    }
}
//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/newsfeed/discussions/shared/domain/model/Discussion.kt
package com.openparty.app.features.newsfeed.discussions.shared.domain.model

import dev.gitlive.firebase.firestore.Timestamp
import kotlinx.serialization.Serializable

@Serializable
data class Discussion(
    val discussionId: String = "",
    val userId: String = "",
    val title: String = "",
    val contentText: String = "",
    val timestamp: Timestamp? = null,
    val commentCount: Int = 0,
    val upvoteCount: Int = 0,
    val downvoteCount: Int = 0
)
//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/newsfeed/discussions/shared/data/domain/repository/DiscussionRepository.kt
package com.openparty.app.features.newsfeed.discussions.shared.domain.repository

import androidx.paging.PagingData
import com.openparty.app.core.shared.domain.DomainResult
import com.openparty.app.features.newsfeed.discussions.shared.domain.model.Discussion
import kotlinx.coroutines.flow.Flow

interface DiscussionRepository {
    fun getDiscussions(): Flow<PagingData<Discussion>>
    suspend fun getDiscussionById(discussionId: String): DomainResult<Discussion>
    suspend fun addDiscussion(discussion: Discussion): DomainResult<Discussion>
}
//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/newsfeed/shared/data/datasource/FirebaseNewsfeedDataSource.kt
package com.openparty.app.features.newsfeed.shared.data.datasource

import dev.gitlive.firebase.firestore.DocumentSnapshot
import dev.gitlive.firebase.firestore.FirebaseFirestore
import dev.gitlive.firebase.firestore.Query
import dev.gitlive.firebase.firestore.Direction
import com.openparty.app.core.shared.domain.GlobalLogger.logger

class FirebaseNewsfeedDataSource<T : Any>(
    private val firestore: FirebaseFirestore,
    val collectionName: String,
    private val orderByField: String,
    val transform: (DocumentSnapshot) -> T?
) {
    fun getQuery(startAfter: DocumentSnapshot?, loadSize: Int): Query {
        val queryDescription = buildString {
            appendLine("Constructing Firestore query:")
            appendLine("  Collection: $collectionName")
            appendLine("  OrderBy: $orderByField (DESC)")
            appendLine("  Limit: $loadSize")
            if (startAfter != null) {
                appendLine("  StartAfter doc ID: ${startAfter.id}")
            }
        }
        logger.d { "getQuery() -> $queryDescription" }
        return try {
            val baseQuery = firestore.collection(collectionName)
                .orderBy(orderByField, Direction.DESCENDING)
                .limit(loadSize.toLong())
            if (startAfter != null) {
                baseQuery.startAfter(startAfter)
            } else {
                baseQuery
            }
        } catch (e: Exception) {
            logger.e(e) { "Error creating query for collection: $collectionName" }
            throw Exception("Failed to create query for collection: $collectionName. Please try again.", e)
        }
    }

    suspend fun getItemById(itemId: String): T? {
        logger.d { "Fetching item by ID: $itemId from collection: $collectionName" }
        return try {
            val snapshot = firestore.collection(collectionName)
                .document(itemId)
                .get()
            logger.d { "Item fetched successfully for ID: $itemId in collection: $collectionName" }
            transform(snapshot)
        } catch (e: Exception) {
            logger.e(e) { "Error fetching item by ID: $itemId from collection: $collectionName" }
            null
        }
    }
}// File: composeApp/src/commonMain/kotlin/com/openparty/app/features/newsfeed/shared/data/datasource/FirestorePagingSource.kt
package com.openparty.app.features.newsfeed.shared.data.datasource

import app.cash.paging.PagingSource
import app.cash.paging.PagingState
import dev.gitlive.firebase.firestore.DocumentSnapshot
import com.openparty.app.core.shared.domain.GlobalLogger.logger

class FirestorePagingSource<T : Any>(
    private val dataSource: FirebaseNewsfeedDataSource<T>
) : PagingSource<DocumentSnapshot, T>() {

    override suspend fun load(params: LoadParams<DocumentSnapshot>): LoadResult<DocumentSnapshot, T> {
        val collection = dataSource.collectionName
        val startAfterId = params.key?.id
        logger.d { "Loading data from FirestorePagingSource for $collection with loadSize: ${params.loadSize} and startAfter: $startAfterId" }
        return try {
            val query = dataSource.getQuery(params.key, params.loadSize)
            val snapshot = query.get()
            val items = snapshot.documents.mapNotNull { dataSource.transform(it) }
            val nextKey = snapshot.documents.lastOrNull()
            if (items.isEmpty()) {
                logger.w { "No items loaded for $collection (startAfter = $startAfterId). Possibly an empty collection or no more data." }
            } else {
                logger.d { "Successfully loaded ${items.size} items from $collection, next key: ${nextKey?.id}" }
            }
            LoadResult.Page(
                data = items,
                prevKey = null,
                nextKey = nextKey
            )
        } catch (e: Exception) {
            logger.e(e) { "Error loading data in FirestorePagingSource for $collection" }
            LoadResult.Error(e)
        }
    }

    override fun getRefreshKey(state: PagingState<DocumentSnapshot, T>): DocumentSnapshot? {
        logger.d { "Getting refresh key in FirestorePagingSource for ${dataSource.collectionName}" }
        return null
    }
}
// File: composeApp/src/commonMain/kotlin/com/openparty/app/features/newsfeed/shared/data/repository/FirestoreRepository.kt
package com.openparty.app.features.newsfeed.shared.data.repository

import app.cash.paging.Pager
import app.cash.paging.PagingConfig
import app.cash.paging.PagingData
import com.openparty.app.core.shared.domain.DomainResult
import com.openparty.app.core.shared.domain.error.AppError
import com.openparty.app.features.newsfeed.shared.data.datasource.FirestorePagingSource
import kotlinx.coroutines.flow.Flow
import com.openparty.app.core.shared.domain.GlobalLogger.logger
import com.openparty.app.features.newsfeed.shared.data.datasource.FirebaseNewsfeedDataSource

abstract class FirestoreRepository<T : Any>(
    private val dataSource: FirebaseNewsfeedDataSource<T>,
    private val error: AppError
) {
    fun getPagedItems(): Flow<PagingData<T>> {
        logger.d { "Fetching paged items from FirestoreRepository for ${dataSource.collectionName}" }
        return Pager(
            config = PagingConfig(
                pageSize = 10,
                enablePlaceholders = false
            ),
            pagingSourceFactory = {
                logger.d { "Creating FirestorePagingSource for ${dataSource.collectionName}" }
                FirestorePagingSource(dataSource)
            }
        ).flow
    }

    suspend fun getItemById(itemId: String): DomainResult<T> {
        logger.d { "Fetching item by ID: $itemId in FirestoreRepository for ${dataSource.collectionName}" }
        return try {
            val item = dataSource.getItemById(itemId)
            if (item != null) {
                logger.d { "Item found for ID: $itemId in ${dataSource.collectionName}" }
                DomainResult.Success(item)
            } else {
                logger.w { "Item not found for ID: $itemId in ${dataSource.collectionName}" }
                DomainResult.Failure(error)
            }
        } catch (e: Exception) {
            logger.e(e) { "Error fetching item by ID: $itemId in ${dataSource.collectionName}" }
            DomainResult.Failure(error)
        }
    }
}
// File: composeApp/src/commonMain/kotlin/com/openparty/app/features/newsfeed/shared/presentation/BaseFeedScreen.kt
package com.openparty.app.features.newsfeed.shared.presentation

import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import app.cash.paging.compose.LazyPagingItems

@Composable
fun <T : Any> BaseFeedScreen(
    items: LazyPagingItems<T>,
    emptyPlaceholder: String,
    content: @Composable (item: T?) -> Unit
) {
    if (items.itemCount == 0) {
        Box(
            modifier = Modifier.fillMaxSize(),
            contentAlignment = Alignment.Center
        ) {
            Text(text = emptyPlaceholder)
        }
    } else {
        LazyColumn {
            items(
                count = items.itemCount,
                key = { index -> items[index]?.hashCode() ?: index }
            ) { index ->
                val item = items[index]
                content(item)
            }
        }
    }
}
//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/shared/feature_user/data/datasource/FirebaseUserDataSource.kt
package com.openparty.app.features.shared.feature_user.data.datasource

import com.openparty.app.core.shared.domain.GlobalLogger.logger
import com.openparty.app.features.shared.feature_user.data.model.UserDto
import com.openparty.app.features.shared.feature_user.domain.model.UpdateUserRequest
import dev.gitlive.firebase.Firebase
import dev.gitlive.firebase.firestore.FirebaseFirestore
import dev.gitlive.firebase.firestore.FieldValue
import dev.gitlive.firebase.firestore.firestore
import dev.gitlive.firebase.firestore.where
import org.koin.core.component.KoinComponent

class FirebaseUserDataSource(
    private val firestore: FirebaseFirestore = Firebase.firestore
) : UserDataSource, KoinComponent {

    override suspend fun fetchUser(userId: String): UserDto {
        logger.d { "Fetching user with userId: $userId" }
        return try {
            val snapshot = firestore.collection("users").document(userId).get()
            val userDto = snapshot.data(UserDto.serializer())
            if (userDto == null) {
                logger.e { "User not found or data is null for userId: $userId" }
                throw IllegalStateException("User data is null or could not be mapped for userId: $userId")
            }
            userDto
        } catch (e: IllegalStateException) {
            logger.e(e) { "Error while fetching user: $userId" }
            throw e
        } catch (e: Exception) {
            logger.e(e) { "Unexpected error occurred while fetching user: $userId" }
            throw RuntimeException("Failed to fetch user for userId: $userId", e)
        }
    }

    override suspend fun isScreenNameTaken(name: String): Boolean {
        logger.d { "Checking if screen name is taken: $name" }
        return try {
            val snapshot = firestore.collection("users")
                .where("screenName", "==", name)
                .get()
            snapshot.documents.isNotEmpty()
        } catch (e: Exception) {
            logger.e(e) { "Error checking if screen name is taken: $name" }
            throw RuntimeException("Failed to check if screen name is taken: $name", e)
        }
    }

    override suspend fun updateUser(userId: String, request: Any) {
        logger.d { "Updating user with userId: $userId" }
        try {
            if (request is UpdateUserRequest) {
                val updates = mutableMapOf<String, Any>()
                request.location?.let { updates["location"] = it }
                request.locationVerified?.let { updates["locationVerified"] = it }
                request.screenName?.let { updates["screenName"] = it }
                if (updates.isNotEmpty()) {
                    firestore.collection("users").document(userId).update(updates)
                    logger.d { "Successfully updated user document for userId: $userId" }
                } else {
                    logger.d { "No document updates to apply for userId: $userId" }
                }
                request.locationCoordinates?.let { coordinates ->
                    val parts = coordinates.split(",")
                    if (parts.size == 2) {
                        val lat = parts[0].toDoubleOrNull() ?: 0.0
                        val lon = parts[1].toDoubleOrNull() ?: 0.0
                        val historyData = mapOf(
                            "latitude" to lat,
                            "longitude" to lon,
                            "timestamp" to FieldValue.serverTimestamp
                        )
                        firestore.collection("users").document(userId)
                            .collection("locationHistory")
                            .add(historyData)
                        logger.d { "Successfully added location history for userId: $userId" }
                    } else {
                        logger.e { "Invalid locationCoordinates format for userId: $userId" }
                    }
                }
            } else {
                logger.e { "Invalid update request type for userId: $userId" }
                throw IllegalArgumentException("Invalid update request type for userId: $userId")
            }
        } catch (e: Exception) {
            logger.e(e) { "Error updating user: $userId" }
            throw RuntimeException("Failed to update user for userId: $userId", e)
        }
    }

    override suspend fun addUser(userId: String, user: UserDto) {
        logger.d { "Adding new user with userId: $userId" }
        try {
            firestore.collection("users").document(userId).set(user)
            logger.d { "Successfully added user with userId: $userId" }
        } catch (e: Exception) {
            logger.e(e) { "Error adding user: $userId" }
            throw RuntimeException("Failed to add user for userId: $userId", e)
        }
    }

    override suspend fun blockUser(userId: String, blockedUserId: String) {
        logger.d { "Blocking user: $blockedUserId for user: $userId" }
        try {
            firestore.collection("users").document(userId)
                .update("blockedUsers" to FieldValue.arrayUnion(blockedUserId))
            logger.d { "Successfully blocked user: $blockedUserId for user: $userId" }
        } catch (e: Exception) {
            logger.e(e) { "Error blocking user: $blockedUserId for user: $userId" }
            throw RuntimeException("Failed to block user for userId: $userId", e)
        }
    }
}
//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/shared/feature_user/data/datasource/UserDataSource.kt
package com.openparty.app.features.shared.feature_user.data.datasource

import com.openparty.app.features.shared.feature_user.data.model.UserDto

interface UserDataSource {
    suspend fun fetchUser(userId: String): UserDto
    suspend fun isScreenNameTaken(name: String): Boolean
    suspend fun updateUser(userId: String, request: Any)
    suspend fun addUser(userId: String, user: UserDto)
    suspend fun blockUser(userId: String, blockedUserId: String)
}
//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/shared/feature_user/data/mapper/UserMapper.kt
package com.openparty.app.features.shared.feature_user.data.mapper

import com.openparty.app.features.shared.feature_user.data.model.UserDto
import com.openparty.app.features.shared.feature_user.domain.model.AccountType
import com.openparty.app.features.shared.feature_user.domain.model.User

object UserMapper {
    fun map(dto: UserDto): User {
        val accountType = when (dto.accountType) {
            "admin" -> AccountType.ADMIN
            "representative" -> AccountType.REPRESENTATIVE
            else -> AccountType.CONSTITUENT
        }
        return User(
            screenName = dto.screenName.orEmpty(),
            accountType = accountType,
            title = dto.title,
            manuallyVerified = dto.manuallyVerified,
            isLocationVerified = dto.locationVerified,
            isPolicyAccepted = dto.isPolicyAccepted,
            userId = dto.userId,
            blockedUsers = dto.blockedUsers
        )
    }
}

//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/shared/feature_user/data/model/UserDto.kt
package com.openparty.app.features.shared.feature_user.data.model

import kotlinx.serialization.Serializable

@Serializable
data class UserDto(
    val userId: String = "",
    val accountType: String? = null,
    val manuallyVerified: Boolean = false,
    val governmentName: String? = null,
    val location: String? = null,
    val locationVerified: Boolean = false,
    val otherUserInfo: OtherUserInfo? = null,
    val screenName: String? = null,
    val title: String? = null,
    val isPolicyAccepted: Boolean = false,
    val blockedUsers: List<String> = emptyList()
)

@Serializable
data class OtherUserInfo(
    val email: String = "",
    val phoneNumber: String? = null,
    val profilePictureUrl: String? = null
)
//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/shared/feature_user/data/repository/UserRepositoryImpl.kt
package com.openparty.app.features.shared.feature_user.data.repository

import com.openparty.app.core.shared.domain.DomainResult
import com.openparty.app.core.shared.domain.error.AppError
import com.openparty.app.features.shared.feature_user.data.datasource.UserDataSource
import com.openparty.app.features.shared.feature_user.data.mapper.UserMapper
import com.openparty.app.features.shared.feature_user.data.model.UserDto
import com.openparty.app.features.shared.feature_user.domain.model.User
import com.openparty.app.features.shared.feature_user.domain.repository.UserRepository

class UserRepositoryImpl(
    private val userDataSource: UserDataSource
) : UserRepository {

    override suspend fun getUser(userId: String): DomainResult<User> {
        println("getUser called with userId: $userId")
        return try {
            val dto = userDataSource.fetchUser(userId)
            val user = UserMapper.map(dto)
            DomainResult.Success(user)
        } catch (e: Exception) {
            println("Error fetching user with userId: $userId, exception: ${e.message}")
            DomainResult.Failure(AppError.User.General)
        }
    }

    override suspend fun isScreenNameTaken(name: String): DomainResult<Boolean> {
        println("isScreenNameTaken called for name: $name")
        return try {
            val taken = userDataSource.isScreenNameTaken(name)
            DomainResult.Success(taken)
        } catch (e: Exception) {
            println("Error checking if screen name is taken: $name, exception: ${e.message}")
            DomainResult.Failure(AppError.User.General)
        }
    }

    override suspend fun updateUser(userId: String, request: Any): DomainResult<Unit> {
        println("updateUser called with userId: $userId, request: $request")
        return try {
            if (request is com.openparty.app.features.shared.feature_user.domain.model.UpdateUserRequest) {
                userDataSource.updateUser(userId, request)
                println("Successfully updated user with userId: $userId")
            } else {
                println("Invalid request type for updateUser: $request")
            }
            DomainResult.Success(Unit)
        } catch (e: Exception) {
            println("Error updating user with userId: $userId, exception: ${e.message}")
            DomainResult.Failure(AppError.User.UpdateUserUseCase)
        }
    }

    override suspend fun addUser(userId: String, user: UserDto): DomainResult<Unit> {
        println("addUser called with userId: $userId, user: $user")
        return try {
            userDataSource.addUser(userId, user)
            println("Successfully added user with userId: $userId")
            DomainResult.Success(Unit)
        } catch (e: Exception) {
            println("Error adding user with userId: $userId, exception: ${e.message}")
            DomainResult.Failure(AppError.User.General)
        }
    }

    override suspend fun blockUser(currentUserId: String, blockedUserId: String): DomainResult<Unit> {
        println("blockUser called with currentUserId: $currentUserId, blockedUserId: $blockedUserId")
        return try {
            userDataSource.blockUser(currentUserId, blockedUserId)
            println("Successfully blocked user: $blockedUserId for user: $currentUserId")
            DomainResult.Success(Unit)
        } catch (e: Exception) {
            println("Error blocking user with currentUserId: $currentUserId, blockedUserId: $blockedUserId, exception: ${e.message}")
            DomainResult.Failure(AppError.User.BlockUser)
        }
    }
}//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/shared/feature_user/di/userModule.kt
package com.openparty.app.features.shared.feature_user.di

import com.openparty.app.features.shared.feature_user.data.datasource.FirebaseUserDataSource
import com.openparty.app.features.shared.feature_user.data.datasource.UserDataSource
import com.openparty.app.features.shared.feature_user.data.repository.UserRepositoryImpl
import com.openparty.app.features.shared.feature_user.domain.repository.UserRepository
import com.openparty.app.features.shared.feature_user.domain.usecase.GetUserUseCase
import com.openparty.app.features.shared.feature_user.domain.usecase.UpdateUserUseCase
import com.openparty.app.features.shared.feature_user.domain.usecase.BlockUserUseCase
import dev.gitlive.firebase.Firebase
import dev.gitlive.firebase.firestore.firestore
import org.koin.core.module.Module
import org.koin.dsl.module

val userModule: Module = module {
    single {
        Firebase.firestore
    }

    single<UserDataSource> {
        FirebaseUserDataSource(
            firestore = get()
        )
    }

    single<UserRepository> {
        UserRepositoryImpl(
            userDataSource = get()
        )
    }

    single {
        GetUserUseCase(
            userRepository = get(),
            getFirebaseUserUseCase = get()
        )
    }

    single {
        UpdateUserUseCase(
            userRepository = get()
        )
    }

    single {
        BlockUserUseCase(
            userRepository = get()
        )
    }
}

//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/shared/feature_user/domain/model/UpdateUserRequest.kt
package com.openparty.app.features.shared.feature_user.domain.model

data class UpdateUserRequest(
    val location: String? = null,
    val locationVerified: Boolean? = null,
    val screenName: String? = null,
    val locationCoordinates: String? = null
)
//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/shared/feature_user/domain/model/User.kt
package com.openparty.app.features.shared.feature_user.domain.model

data class User(
    val userId: String,
    val screenName: String,
    val accountType: AccountType,
    val title: String?,
    val manuallyVerified: Boolean,
    val isLocationVerified: Boolean,
    val isPolicyAccepted: Boolean,
    val blockedUsers: List<String> // NEW: blockedUsers field
)

enum class AccountType {
    ADMIN,
    CONSTITUENT,
    REPRESENTATIVE
}
//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/shared/feature_user/domain/repository/UserRepository.kt
package com.openparty.app.features.shared.feature_user.domain.repository

import com.openparty.app.core.shared.domain.DomainResult
import com.openparty.app.features.shared.feature_user.data.model.UserDto
import com.openparty.app.features.shared.feature_user.domain.model.User

interface UserRepository {
    suspend fun getUser(userId: String): DomainResult<User>
    suspend fun isScreenNameTaken(name: String): DomainResult<Boolean>
    suspend fun updateUser(userId: String, request: Any): DomainResult<Unit>
    suspend fun addUser(userId: String, user: UserDto): DomainResult<Unit>
    suspend fun blockUser(currentUserId: String, blockedUserId: String): DomainResult<Unit>
}

//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/shared/feature_user/domain/usecase/BlockUserUseCase.kt
package com.openparty.app.features.shared.feature_user.domain.usecase

import com.openparty.app.core.shared.domain.DomainResult
import com.openparty.app.core.shared.domain.error.AppError
import com.openparty.app.core.shared.domain.GlobalLogger.logger
import com.openparty.app.features.shared.feature_user.domain.repository.UserRepository

class BlockUserUseCase(
    private val userRepository: UserRepository
) {
    suspend operator fun invoke(currentUserId: String, blockedUserId: String): DomainResult<Unit> {
        logger.i { "BlockUserUseCase invoked with currentUserId: $currentUserId and blockedUserId: $blockedUserId" }
        return try {
            userRepository.blockUser(currentUserId, blockedUserId)
        } catch (e: Throwable) {
            logger.e(e) { "Exception in BlockUserUseCase: ${e.message}" }
            DomainResult.Failure(AppError.User.BlockUser)
        }
    }
}
//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/shared/feature_user/domain/usecase/GetUserUseCase.kt
package com.openparty.app.features.shared.feature_user.domain.usecase

import com.openparty.app.core.shared.domain.DomainResult
import com.openparty.app.core.shared.domain.error.AppError
import com.openparty.app.features.shared.feature_user.domain.model.User
import com.openparty.app.features.shared.feature_user.domain.repository.UserRepository
import com.openparty.app.features.startup.feature_authentication.domain.usecase.GetFirebaseUserUseCase

class GetUserUseCase(
    private val userRepository: UserRepository,
    private val getFirebaseUserUseCase: GetFirebaseUserUseCase
) {
    suspend operator fun invoke(): DomainResult<User> {
        println("GetUserUseCase invoked")
        return try {
            when (val firebaseUserResult = getFirebaseUserUseCase()) {
                is DomainResult.Success -> {
                    val userId = firebaseUserResult.data.uid
                    println("Successfully retrieved FirebaseUser with UID: $userId")
                    when (val userResult = userRepository.getUser(userId)) {
                        is DomainResult.Success -> {
                            println("Successfully fetched user with userId: $userId")
                            DomainResult.Success(userResult.data)
                        }
                        is DomainResult.Failure -> {
                            println("Failed to fetch user with userId: $userId")
                            DomainResult.Failure(AppError.Authentication.GetUser)
                        }
                    }
                }
                is DomainResult.Failure -> {
                    println("Failed to retrieve FirebaseUser")
                    DomainResult.Failure(AppError.Authentication.GetUser)
                }
            }
        } catch (e: Throwable) {
            println("Exception occurred while fetching user: ${e.message}")
            DomainResult.Failure(AppError.Authentication.GetUser)
        }
    }
}
//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/shared/feature_user/domain/usecase/UpdateUserUseCase.kt
package com.openparty.app.features.shared.feature_user.domain.usecase

import com.openparty.app.core.shared.domain.DomainResult
import com.openparty.app.core.shared.domain.error.AppError
import com.openparty.app.features.shared.feature_user.domain.model.UpdateUserRequest
import com.openparty.app.features.shared.feature_user.domain.repository.UserRepository

class UpdateUserUseCase(
    private val userRepository: UserRepository
) {
    suspend operator fun invoke(userId: String, request: UpdateUserRequest): DomainResult<Unit> {
        println("UpdateUserUseCase invoked with userId: $userId and request: $request")
        return try {
            when (val result = userRepository.updateUser(userId, request)) {
                is DomainResult.Success -> {
                    println("Successfully updated user with userId: $userId")
                    result
                }
                is DomainResult.Failure -> {
                    println("Failed to update user with userId: $userId")
                    DomainResult.Failure(AppError.User.UpdateUserUseCase)
                }
            }
        } catch (e: Throwable) {
            println("Exception occurred while updating user with userId: $userId, exception: ${e.message}")
            DomainResult.Failure(AppError.User.UpdateUserUseCase)
        }
    }
}


---------

Notes: 
- When you give code, give the entire file, don't abbreviate anything
- Don't leave comments in the code, except a comment at a top of the file stating the file path
    - e.g. //File: composeApp/src/androidMain/kotlin/com/openparty/app/main/MainViewModel.kt
- Use the cleanest, most robust, scalable architecture you can 
- For every gradle dependency, give it in this format: implementation("org.jetbrains.androidx.lifecycle:lifecycle-viewmodel-compose:2.8.2")
    - don't give it in the libs.version.toml format. i.e. don't do this - implementation(compose.components.uiToolingPreview)
    - The exception to this is the dependencies that are already in my gradle files, leave them in the original format
- I'm using koin compose multiplatform for my depedency injection, that means that in my screen classes, I use this import - import org.koin.compose.viewmodel.koinViewModel
    - And the view model is injected like this - viewModel: DiscussionArticleViewModel = koinViewModel()
    - This might look odd to you since it's a new approach but don't change it, assume it's correct 
- Keep all business logic in use cases where appropriate 
- Whenenever you use use cases, return the DomainResult Success or Failure 
- Add Kermit logs where appropriate 
- Whenever you call a use case (for example in the view model), handle the DomainResult.Success or Failure case and use this: val errorMessage = AppErrorMapper.getUserFriendlyMessage(result.error) - to return a friendly error to the user
- Whenever you use a library in commonMain code, make sure that it's a library that's compatible with compose multiplatform

---------

I've given you my discussion preview code above. There is functionality to block users through the discussion card 

When this is done, it adds a user to a list of blocked users in the firebase database 

The discussions preview screen then filters content based on this blocked users list 

This all works fine, however it only works when the app starts up 

For example, if user1 blocks user2, then user2 content will still be on user1 discussion preview screen until user1 reloads the app 

This is because the block users filter only works on app refresh 

instead of this, when the block user action is clicked, I want the discussions preview list to update so that the blocked users discussion cards are no longer shown 