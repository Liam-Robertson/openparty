OpenParty/
├── build.gradle.kts
├── gradle/
│   ├── libs.versions.toml
│   └── wrapper/
│       ├── gradle-wrapper.jar
│       └── gradle-wrapper.properties
├── gradle.properties
├── gradlew
├── gradlew.bat
├── composeApp/
│   ├── build.gradle.kts
│   └── src/
│       ├── androidMain/
│       │   ├── AndroidManifest.xml
│       │   └── kotlin/
│       │       └── com/
│       │           └── openparty/
│       │               └── app/
│       │                   └── [Placeholder]
│       ├── commonMain/
│       │   └── kotlin/
│       │       └── com/
│       │           └── openparty/
│       │               └── app/
│       │                   └── [Placeholder]
│       └── iosMain/
│           └── kotlin/
│               └── com/
│                   └── openparty/
│                       └── app/
│                           └── [Placeholder]
└── iosApp/
    ├── configuration/
    ├── iosApp/
    │   ├── Assets.xcassets/
    │   ├── ContentView.swift
    │   ├── Info.plist
    │   ├── iOSApp.swift
    │   ├── iosApp.xcodeproj/
    │   └── Preview Content/
    └── iosApp.xcodeproj/

---------

// File: composeApp/src/commonMain/kotlin/com/openparty/app/features/startup/verification/feature_location_verification/di/LocationVerificationModule.kt
package com.openparty.app.features.startup.verification.feature_location_verification.di

import com.openparty.app.features.shared.feature_permissions.domain.usecase.LocationPermissionCheckUseCase
import com.openparty.app.features.startup.feature_authentication.domain.usecase.DetermineAuthStatesUseCase
import com.openparty.app.features.startup.feature_authentication.presentation.AuthFlowNavigationMapper
import com.openparty.app.features.startup.verification.feature_location_verification.domain.usecase.GetUserLocationUseCase
import com.openparty.app.features.startup.verification.feature_location_verification.domain.usecase.HandleLocationPopupUseCase
import com.openparty.app.features.startup.verification.feature_location_verification.domain.usecase.UpdateUserLocationUseCase
import com.openparty.app.features.startup.verification.feature_location_verification.domain.usecase.VerifyAndUpdateLocationUseCase
import com.openparty.app.features.startup.verification.feature_location_verification.presentation.LocationVerificationViewModel
import org.koin.core.module.dsl.viewModel
import org.koin.dsl.module

val locationVerificationModule = module {
    viewModel {
        LocationVerificationViewModel(
            verifyAndUpdateLocationUseCase = get<VerifyAndUpdateLocationUseCase>(),
            handleLocationPopupUseCase = get<HandleLocationPopupUseCase>(),
            determineAuthStatesUseCase = get<DetermineAuthStatesUseCase>(),
            authFlowNavigationMapper = get<AuthFlowNavigationMapper>()
        )
    }
    single { HandleLocationPopupUseCase() }
    single { LocationPermissionCheckUseCase(get()) }
    single { GetUserLocationUseCase() }
    single { UpdateUserLocationUseCase(get(), get()) }
    single { VerifyAndUpdateLocationUseCase(get(), get(), get()) }
}
// File: composeApp/src/commonMain/kotlin/com/openparty/app/features/startup/verification/feature_location_verification/domain/model/LocationCoordinate.kt
package com.openparty.app.features.startup.verification.feature_location_verification.domain.model

data class LocationCoordinate(val latitude: Double, val longitude: Double)
// File: composeApp/src/commonMain/kotlin/com/openparty/app/features/startup/verification/feature_location_verification/domain/model/VerificationResult.kt
package com.openparty.app.features.startup.verification.feature_location_verification.domain.model

import com.openparty.app.features.startup.verification.feature_location_verification.domain.model.LocationCoordinate

data class VerificationResult(val isInside: Boolean, val coordinate: LocationCoordinate)
// File: composeApp/src/commonMain/kotlin/com/openparty/app/features/startup/verification/feature_location_verification/domain/usecase/GetUserLocationUseCase.kt
package com.openparty.app.features.startup.verification.feature_location_verification.domain.usecase

import com.openparty.app.features.startup.verification.feature_location_verification.domain.model.LocationCoordinate

expect class GetUserLocationUseCase() {
    suspend fun execute(): LocationCoordinate?
}
// File: composeApp/src/commonMain/kotlin/com/openparty/app/features/startup/verification/feature_location_verification/domain/usecase/HandleLocationPopupUseCase.kt
package com.openparty.app.features.startup.verification.feature_location_verification.domain.usecase

import com.openparty.app.core.shared.domain.DomainResult
import com.openparty.app.core.shared.domain.error.AppError
import com.openparty.app.features.startup.verification.feature_location_verification.presentation.components.LocationVerificationUiState
import com.openparty.app.core.shared.domain.GlobalLogger.logger

class HandleLocationPopupUseCase {

    fun execute(
        isGranted: Boolean,
        currentState: LocationVerificationUiState,
        permissionRequestCount: Int
    ): DomainResult<LocationVerificationUiState> {
        logger.i { "Executing HandleLocationPopupUseCase with isGranted: $isGranted, permissionRequestCount: $permissionRequestCount" }
        return try {
            if (isGranted) {
                logger.i { "Permissions granted, updating UI state" }
                DomainResult.Success(
                    currentState.copy(
                        showVerificationDialog = false,
                        showSettingsDialog = false,
                        permissionsGranted = true,
                        isLoading = false
                    )
                )
            } else {
                val updatedCount = permissionRequestCount + 1
                logger.i { "Permissions not granted, updated request count: $updatedCount" }
                if (updatedCount >= 3) {
                    logger.i { "Permission request count exceeded threshold, showing settings dialog" }
                    DomainResult.Success(
                        currentState.copy(
                            showVerificationDialog = false,
                            showSettingsDialog = true,
                            permissionsGranted = false,
                            isLoading = false
                        )
                    )
                } else {
                    logger.i { "Prompting user with verification dialog" }
                    DomainResult.Success(
                        currentState.copy(
                            showVerificationDialog = true,
                            showSettingsDialog = false,
                            permissionsGranted = false,
                            isLoading = false
                        )
                    )
                }
            }
        } catch (e: Exception) {
            logger.e(e) { "Error occurred while handling location popup" }
            DomainResult.Failure(AppError.LocationVerification.HandleLocationsPopup)
        }
    }
}
// File: composeApp/src/commonMain/kotlin/com/openparty/app/features/startup/verification/feature_location_verification/domain/usecase/UpdateUserLocationUseCase.kt
package com.openparty.app.features.startup.verification.feature_location_verification.domain.usecase

import com.openparty.app.core.shared.domain.DomainResult
import com.openparty.app.core.shared.domain.error.AppError
import com.openparty.app.features.shared.feature_user.domain.model.UpdateUserRequest
import com.openparty.app.features.shared.feature_user.domain.usecase.UpdateUserUseCase
import com.openparty.app.features.startup.feature_authentication.domain.usecase.GetCurrentUserIdUseCase
import com.openparty.app.core.shared.domain.GlobalLogger.logger
import com.openparty.app.features.startup.verification.feature_location_verification.domain.model.VerificationResult

class UpdateUserLocationUseCase(
    private val getCurrentUserIdUseCase: GetCurrentUserIdUseCase,
    private val updateUserUseCase: UpdateUserUseCase
) {
    suspend fun execute(verificationResult: VerificationResult): DomainResult<Unit> {
        return when (val userIdResult = getCurrentUserIdUseCase.invoke()) {
            is DomainResult.Success -> updateUserLocation(userIdResult.data, verificationResult)
            is DomainResult.Failure -> {
                logger.e { "Failed to retrieve user ID: ${userIdResult.error}" }
                DomainResult.Failure(AppError.LocationVerification.UpdateUserLocation)
            }
        }
    }

    private suspend fun updateUserLocation(userId: String, verificationResult: VerificationResult): DomainResult<Unit> {
        return try {
            val locationValue = if (verificationResult.isInside) "West Lothian" else null
            val locationVerified = verificationResult.isInside
            val coordinatesValue = "${verificationResult.coordinate.latitude},${verificationResult.coordinate.longitude}"
            when (val updateResult = updateUserUseCase(
                userId = userId,
                request = UpdateUserRequest(
                    location = locationValue,
                    locationVerified = locationVerified,
                    locationCoordinates = coordinatesValue
                )
            )) {
                is DomainResult.Success -> {
                    logger.i { "Successfully updated location for user ID: $userId" }
                    DomainResult.Success(Unit)
                }
                is DomainResult.Failure -> {
                    logger.e { "Failed to update location for user ID: $userId, Error: ${updateResult.error}" }
                    DomainResult.Failure(AppError.LocationVerification.UpdateUserLocation)
                }
            }
        } catch (e: Exception) {
            logger.e(e) { "Unexpected error updating user location for user ID: $userId" }
            DomainResult.Failure(AppError.LocationVerification.UpdateUserLocation)
        }
    }
}
// File: composeApp/src/commonMain/kotlin/com/openparty/app/features/startup/verification/feature_location_verification/domain/usecase/VerifyAndUpdateLocationUseCase.kt
package com.openparty.app.features.startup.verification.feature_location_verification.domain.usecase

import com.openparty.app.core.shared.domain.DomainResult
import com.openparty.app.core.shared.domain.error.AppError
import com.openparty.app.core.shared.domain.GlobalLogger.logger
import com.openparty.app.features.shared.feature_permissions.domain.usecase.LocationPermissionCheckUseCase
import com.openparty.app.features.startup.verification.feature_location_verification.domain.model.LocationCoordinate
import com.openparty.app.features.startup.verification.feature_location_verification.domain.model.VerificationResult
import kotlin.math.PI
import kotlin.math.atan2
import kotlin.math.cos
import kotlin.math.sin
import kotlin.math.sqrt
import kotlin.math.pow

class VerifyAndUpdateLocationUseCase(
    private val locationPermissionCheckUseCase: LocationPermissionCheckUseCase,
    private val getUserLocationUseCase: GetUserLocationUseCase,
    private val updateUserLocationUseCase: UpdateUserLocationUseCase
) {
    suspend fun execute(): DomainResult<Boolean> {
        val permissionResult = locationPermissionCheckUseCase.execute()
        if (permissionResult is DomainResult.Failure) {
            return DomainResult.Failure(AppError.LocationVerification.LocationPermissionsError)
        }
        val coordinate: LocationCoordinate = getUserLocationUseCase.execute() ?: return DomainResult.Failure(AppError.LocationVerification.VerifyLocation)
        val isInside = isInsideWestLothian(coordinate.latitude, coordinate.longitude)
        val verificationResult = VerificationResult(isInside, coordinate)
        return when (val updateResult = updateUserLocationUseCase.execute(verificationResult)) {
            is DomainResult.Success -> DomainResult.Success(isInside)
            is DomainResult.Failure -> DomainResult.Failure(AppError.LocationVerification.UpdateUserLocation)
        }
    }

    private fun isInsideWestLothian(latitude: Double, longitude: Double): Boolean {
        val westLothianCenterLat = 55.908
        val westLothianCenterLon = -3.551
        val radiusKm = 20.0
        val earthRadiusKm = 6371.0
        val dLat = (latitude - westLothianCenterLat) * (PI / 180)
        val dLon = (longitude - westLothianCenterLon) * (PI / 180)
        val a = sin(dLat / 2).pow(2.0) +
                cos(westLothianCenterLat * (PI / 180)) *
                cos(latitude * (PI / 180)) *
                sin(dLon / 2).pow(2.0)
        val c = 2 * atan2(sqrt(a), sqrt(1 - a))
        val distance = earthRadiusKm * c
        return distance <= radiusKm
    }
}
// File: composeApp/src/commonMain/kotlin/com/openparty/app/features/startup/verification/feature_location_verification/domain/RequestLocationPermission.kt
package com.openparty.app.features.startup.verification.feature_location_verification.domain

import androidx.compose.runtime.Composable

@Composable
expect fun RequestLocationPermission(permission: String, onResult: (Boolean) -> Unit)
// File: composeApp/src/commonMain/kotlin/com/openparty/app/features/startup/verification/feature_location_verification/presentation/components/LocationVerificationUiEvent.kt
package com.openparty.app.features.startup.verification.feature_location_verification.presentation.components


sealed class LocationVerificationUiEvent {
    data class Navigate(val destination: String) : LocationVerificationUiEvent()
    data class RequestPermission(val permission: String) : LocationVerificationUiEvent()
}
// File: composeApp/src/commonMain/kotlin/com/openparty/app/features/startup/verification/feature_location_verification/presentation/components/LocationVerificationUiState.kt
package com.openparty.app.features.startup.verification.feature_location_verification.presentation.components

data class LocationVerificationUiState(
    val showVerificationDialog: Boolean = false,
    val showSettingsDialog: Boolean = false,
    val permissionsGranted: Boolean = false,
    val isLoading: Boolean = false,
    val errorMessage: String? = null
)
// File: composeApp/src/commonMain/kotlin/com/openparty/app/features/startup/verification/feature_location_verification/presentation/LocationVerificationScreen.kt
package com.openparty.app.features.startup.verification.feature_location_verification.presentation

import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.material3.AlertDialog
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Surface
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.navigation.NavController
import com.openparty.app.core.shared.presentation.ErrorText
import com.openparty.app.features.startup.verification.feature_location_verification.domain.RequestLocationPermission
import com.openparty.app.features.startup.verification.feature_location_verification.presentation.components.LocationVerificationUiEvent
import kotlinx.coroutines.flow.collectLatest
import org.koin.compose.viewmodel.koinViewModel

@Composable
fun LocationVerificationScreen(
    navController: NavController,
    viewModel: LocationVerificationViewModel = koinViewModel()
) {
    val uiState by viewModel.uiState.collectAsState()
    var permissionToRequest by remember { mutableStateOf<String?>(null) }

    LaunchedEffect(Unit) {
        viewModel.uiEvent.collectLatest { event ->
            when (event) {
                is LocationVerificationUiEvent.Navigate -> {
                    navController.navigate(event.destination) {
                        popUpTo(event.destination) { inclusive = true }
                    }
                }
                is LocationVerificationUiEvent.RequestPermission -> {
                    permissionToRequest = event.permission
                }
            }
        }
    }

    if (permissionToRequest != null) {
        RequestLocationPermission(permissionToRequest!!) { isGranted ->
            viewModel.handleLocationPopupResult(isGranted)
            permissionToRequest = null
        }
    }

    Surface(
        modifier = Modifier.fillMaxSize(),
        color = MaterialTheme.colorScheme.background
    ) {
        Box(modifier = Modifier.fillMaxSize()) {
            if (uiState.showVerificationDialog) {
                AlertDialog(
                    onDismissRequest = {},
                    title = { Text("Verify Your Location") },
                    text = { Text("This app is only for residents of West Lothian. Verify your location to continue.") },
                    confirmButton = {
                        TextButton(onClick = { viewModel.onVerificationDialogOkClicked() }) {
                            Text("Ok")
                        }
                    }
                )
            }
            if (uiState.showSettingsDialog) {
                AlertDialog(
                    onDismissRequest = {},
                    title = { Text("Enable Location Permissions") },
                    text = { Text("This app requires location permissions. Enable them in your device settings.") },
                    confirmButton = {
                        TextButton(onClick = { viewModel.onSettingsDialogClicked() }) {
                            Text("Settings")
                        }
                    },
                    dismissButton = {
                        TextButton(onClick = {}) {
                            Text("Cancel")
                        }
                    }
                )
            }
            ErrorText(errorMessage = uiState.errorMessage)
            if (uiState.isLoading) {
                CircularProgressIndicator(
                    modifier = Modifier.align(Alignment.Center)
                )
            }
        }
    }
}
// File: composeApp/src/commonMain/kotlin/com/openparty/app/features/startup/verification/feature_location_verification/presentation/LocationVerificationViewModel.kt
package com.openparty.app.features.startup.verification.feature_location_verification.presentation

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.openparty.app.core.shared.domain.DomainResult
import com.openparty.app.core.shared.domain.error.AppErrorMapper
import com.openparty.app.features.startup.feature_authentication.domain.usecase.DetermineAuthStatesUseCase
import com.openparty.app.features.startup.feature_authentication.presentation.AuthFlowNavigationMapper
import com.openparty.app.features.startup.verification.feature_location_verification.domain.usecase.HandleLocationPopupUseCase
import com.openparty.app.features.startup.verification.feature_location_verification.domain.usecase.VerifyAndUpdateLocationUseCase
import com.openparty.app.features.startup.verification.feature_location_verification.presentation.components.LocationVerificationUiEvent
import com.openparty.app.features.startup.verification.feature_location_verification.presentation.components.LocationVerificationUiState
import com.openparty.app.core.shared.domain.GlobalLogger.logger
import com.openparty.app.core.shared.domain.openAppSettings
import com.openparty.app.navigation.Screen
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.SharedFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch

class LocationVerificationViewModel(
    private val verifyAndUpdateLocationUseCase: VerifyAndUpdateLocationUseCase,
    private val handleLocationPopupUseCase: HandleLocationPopupUseCase,
    private val determineAuthStatesUseCase: DetermineAuthStatesUseCase,
    private val authFlowNavigationMapper: AuthFlowNavigationMapper
) : ViewModel() {

    private val _uiState = MutableStateFlow(LocationVerificationUiState())
    val uiState: StateFlow<LocationVerificationUiState> = _uiState

    private val _uiEvent = MutableSharedFlow<LocationVerificationUiEvent>()
    val uiEvent: SharedFlow<LocationVerificationUiEvent> = _uiEvent

    private var permissionRequestCount = 0

    init {
        viewModelScope.launch {
            logger.i { "Initializing LocationVerificationViewModel: Showing verification dialog" }
            _uiState.emit(_uiState.value.copy(showVerificationDialog = true))
        }
    }

    fun onVerificationDialogOkClicked() {
        viewModelScope.launch {
            logger.i { "Ok clicked: Hiding verification dialog and emitting RequestPermission event" }
            _uiState.emit(_uiState.value.copy(showVerificationDialog = false))
            _uiEvent.emit(LocationVerificationUiEvent.RequestPermission("android.permission.ACCESS_FINE_LOCATION"))
        }
    }

    fun onSettingsDialogClicked() {
        logger.i { "Settings dialog clicked: Opening app settings" }
        openAppSettings()
    }

    fun handleLocationPopupResult(isGranted: Boolean) {
        viewModelScope.launch {
            logger.i { "Handling location popup result: isGranted = $isGranted" }
            val currentState = _uiState.value
            when (val result = handleLocationPopupUseCase.execute(isGranted, currentState, permissionRequestCount)) {
                is DomainResult.Success -> {
                    val updatedState = result.data
                    logger.i { "Permission result handled successfully, updated state: $updatedState" }
                    _uiState.value = updatedState
                    if (updatedState.permissionsGranted) {
                        logger.i { "Permissions granted: Verifying and updating location" }
                        fetchAndUpdateLocation()
                    } else if (updatedState.showVerificationDialog) {
                        permissionRequestCount++
                        logger.i { "Permissions not granted; incrementing request count to $permissionRequestCount" }
                    }
                }
                is DomainResult.Failure -> {
                    val errorMessage = AppErrorMapper.getUserFriendlyMessage(result.error)
                    logger.e { "Error handling location popup: $errorMessage" }
                    _uiState.value = _uiState.value.copy(errorMessage = errorMessage)
                }
            }
        }
    }

    private fun fetchAndUpdateLocation() {
        viewModelScope.launch {
            logger.i { "Verifying and updating location: Setting loading state" }
            _uiState.emit(_uiState.value.copy(isLoading = true))
            when (val result = verifyAndUpdateLocationUseCase.execute()) {
                is DomainResult.Success -> {
                    if (result.data) {
                        navigateToNextAuthScreen()
                    } else {
                        logger.i { "User is outside West Lothian" }
                        _uiState.emit(
                            _uiState.value.copy(
                                showVerificationDialog = true,
                                errorMessage = "You appear to be outside West Lothian. This app is only for West Lothian residents."
                            )
                        )
                    }
                }
                is DomainResult.Failure -> {
                    val errorMessage = AppErrorMapper.getUserFriendlyMessage(result.error)
                    logger.e { "Error verifying/updating location: $errorMessage" }
                    _uiState.value = _uiState.value.copy(isLoading = false, errorMessage = errorMessage)
                }
            }
            _uiState.emit(_uiState.value.copy(isLoading = false))
        }
    }

    private suspend fun navigateToNextAuthScreen() {
        when (val authStatesResult = determineAuthStatesUseCase()) {
            is DomainResult.Success -> {
                val destination = authFlowNavigationMapper.determineDestination(authStatesResult.data)
                if (destination == Screen.LocationVerification) {
                    _uiState.value = _uiState.value.copy(errorMessage = "Location verification is incomplete. Please try again.")
                    logger.e { "Already on LocationVerification. Not navigating." }
                } else {
                    logger.i { "Navigating to next auth screen: ${destination.route}" }
                    _uiEvent.emit(LocationVerificationUiEvent.Navigate(destination.route))
                }
            }
            is DomainResult.Failure -> {
                val errorMessage = AppErrorMapper.getUserFriendlyMessage(authStatesResult.error)
                _uiState.value = _uiState.value.copy(errorMessage = errorMessage)
                logger.e { "Error determining next auth screen: $errorMessage" }
            }
        }
    }
}
// File: composeApp/src/iosMain/kotlin/com/openparty/app/features/startup/verification/feature_location_verification/domain/usecase/GetUserLocationUseCase.ios.kt
package com.openparty.app.features.startup.verification.feature_location_verification.domain.usecase

import kotlinx.coroutines.suspendCancellableCoroutine
import platform.CoreLocation.*
import kotlin.coroutines.resume

actual class GetUserLocationUseCase actual constructor() {
    actual suspend fun execute(): Coordinate? = suspendCancellableCoroutine { cont ->
        val locationManager = CLLocationManager().apply {
            desiredAccuracy = kCLLocationAccuracyBest
        }
//        val delegate = object : NSObject(), CLLocationManagerDelegateProtocol {
//            override fun locationManager(manager: CLLocationManager, didUpdateLocations: List<*>) {
//                val location = didUpdateLocations.lastOrNull() as? CLLocation
//                if (location != null) {
//                    cont.resume(Coordinate(location.coordinate.latitude, location.coordinate.longitude))
//                    manager.stopUpdatingLocation()
//                }
//            }
//            override fun locationManager(manager: CLLocationManager, didFailWithError: NSError) {
//                cont.resume(null)
//            }
//        }
//        locationManager.delegate = delegate
//        locationManager.startUpdatingLocation()
//        cont.invokeOnCancellation { locationManager.stopUpdatingLocation() }
    }
}
// File: composeApp/src/iosMain/kotlin/com/openparty/app/features/startup/verification/feature_location_verification/RequestLocationPermission.ios.kt
package com.openparty.app.features.startup.verification.feature_location_verification.domain

import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import platform.CoreLocation.CLLocationManager
import platform.CoreLocation.CLLocationManagerDelegateProtocol
import platform.CoreLocation.kCLAuthorizationStatusAuthorizedAlways
import platform.CoreLocation.kCLAuthorizationStatusAuthorizedWhenInUse
import platform.CoreLocation.CLAuthorizationStatus
//import platform.Foundation.NSObject

//class LocationManagerDelegate(private val onResult: (Boolean) -> Unit) : NSObject(), CLLocationManagerDelegateProtocol {
//    override fun locationManager(manager: CLLocationManager, didChangeAuthorizationStatus: CLAuthorizationStatus) {
//        when (didChangeAuthorizationStatus) {
//            kCLAuthorizationStatusAuthorizedAlways, kCLAuthorizationStatusAuthorizedWhenInUse -> onResult(true)
//            else -> onResult(false)
//        }
//    }
//}

@Composable
actual fun RequestLocationPermission(permission: String, onResult: (Boolean) -> Unit) {
    LaunchedEffect(Unit) {
//        val locationManager = CLLocationManager()
//        val delegate = LocationManagerDelegate(onResult)
//        locationManager.delegate = delegate
//        locationManager.requestWhenInUseAuthorization()
    }
}
// File: composeApp/src/iosMain/kotlin/com/openparty/app/features/startup/verification/feature_location_verification/domain/usecase/GetUserLocationUseCase.ios.kt
package com.openparty.app.features.startup.verification.feature_location_verification.domain.usecase

import kotlinx.coroutines.suspendCancellableCoroutine
import platform.CoreLocation.*
import kotlin.coroutines.resume

actual class GetUserLocationUseCase actual constructor() {
    actual suspend fun execute(): Coordinate? = suspendCancellableCoroutine { cont ->
        val locationManager = CLLocationManager().apply {
            desiredAccuracy = kCLLocationAccuracyBest
        }
//        val delegate = object : NSObject(), CLLocationManagerDelegateProtocol {
//            override fun locationManager(manager: CLLocationManager, didUpdateLocations: List<*>) {
//                val location = didUpdateLocations.lastOrNull() as? CLLocation
//                if (location != null) {
//                    cont.resume(Coordinate(location.coordinate.latitude, location.coordinate.longitude))
//                    manager.stopUpdatingLocation()
//                }
//            }
//            override fun locationManager(manager: CLLocationManager, didFailWithError: NSError) {
//                cont.resume(null)
//            }
//        }
//        locationManager.delegate = delegate
//        locationManager.startUpdatingLocation()
//        cont.invokeOnCancellation { locationManager.stopUpdatingLocation() }
    }
}
// File: composeApp/src/androidMain/kotlin/com/openparty/app/features/startup/verification/feature_location_verification/domain/usecase/GetUserLocationUseCase.android.kt
package com.openparty.app.features.startup.verification.feature_location_verification.domain.usecase

import android.annotation.SuppressLint
import android.content.Context
import com.google.android.gms.location.LocationServices
import kotlinx.coroutines.tasks.await
import org.koin.core.context.GlobalContext.get
import com.openparty.app.features.startup.verification.feature_location_verification.domain.model.LocationCoordinate

actual class GetUserLocationUseCase actual constructor() {
    @SuppressLint("MissingPermission")
    actual suspend fun execute(): LocationCoordinate? {
        val context: Context = get().get()
        val fusedLocationClient = LocationServices.getFusedLocationProviderClient(context)
        val location = fusedLocationClient.lastLocation.await()
        return location?.let { LocationCoordinate(it.latitude, it.longitude) }
    }
}
// File: composeApp/src/iosMain/kotlin/com/openparty/app/features/startup/verification/feature_location_verification/RequestLocationPermission.ios.kt
package com.openparty.app.features.startup.verification.feature_location_verification.domain

import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import platform.CoreLocation.CLLocationManager
import platform.CoreLocation.CLLocationManagerDelegateProtocol
import platform.CoreLocation.kCLAuthorizationStatusAuthorizedAlways
import platform.CoreLocation.kCLAuthorizationStatusAuthorizedWhenInUse
import platform.CoreLocation.CLAuthorizationStatus
//import platform.Foundation.NSObject

//class LocationManagerDelegate(private val onResult: (Boolean) -> Unit) : NSObject(), CLLocationManagerDelegateProtocol {
//    override fun locationManager(manager: CLLocationManager, didChangeAuthorizationStatus: CLAuthorizationStatus) {
//        when (didChangeAuthorizationStatus) {
//            kCLAuthorizationStatusAuthorizedAlways, kCLAuthorizationStatusAuthorizedWhenInUse -> onResult(true)
//            else -> onResult(false)
//        }
//    }
//}

@Composable
actual fun RequestLocationPermission(permission: String, onResult: (Boolean) -> Unit) {
    LaunchedEffect(Unit) {
//        val locationManager = CLLocationManager()
//        val delegate = LocationManagerDelegate(onResult)
//        locationManager.delegate = delegate
//        locationManager.requestWhenInUseAuthorization()
    }
}// File: composeApp/src/androidMain/kotlin/com/openparty/app/features/startup/verification/feature_location_verification/domain/RequestLocationPermission.android.kt
package com.openparty.app.features.startup.verification.feature_location_verification.domain

import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import com.openparty.app.core.shared.domain.GlobalLogger.logger
import kotlinx.coroutines.delay

@Composable
actual fun RequestLocationPermission(permission: String, onResult: (Boolean) -> Unit) {
    logger.i { "Inside RequestLocationPermission (Android): Preparing launcher for permission: $permission" }
    val launcher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.RequestPermission()
    ) { granted ->
        logger.i { "Permission launcher result for $permission: $granted" }
        onResult(granted)
    }
    LaunchedEffect(permission) {
        logger.i { "Launching permission request for $permission" }
        launcher.launch(permission)
    }
}
---------

Notes: 
- When you give code, give the entire file, don't abbreviate anything
- Don't leave comments in the code, except a comment at a top of the file stating the file path
    - e.g. //File: composeApp/src/androidMain/kotlin/com/openparty/app/main/MainViewModel.kt
- Use the cleanest, most robust, scalable architecture you can 
- For every gradle dependency, give it in this format: implementation("org.jetbrains.androidx.lifecycle:lifecycle-viewmodel-compose:2.8.2")
    - don't give it in the libs.version.toml format. i.e. don't do this - implementation(compose.components.uiToolingPreview)
    - The exception to this is the dependencies that are already in my gradle files, leave them in the original format
- I'm using koin compose multiplatform for my depedency injection, that means that in my screen classes, I use this import - import org.koin.compose.viewmodel.koinViewModel
    - And the view model is injected like this - viewModel: DiscussionArticleViewModel = koinViewModel()
    - This might look odd to you since it's a new approach but don't change it, assume it's correct 

---------

So above i've given you the location verification feature for my app. It's job is to get location permissions from the user, and verify that the user is in West Lothian. 

The feature_location_verification works fine for android since I've written all the code and make sure it works, but it doesn't work for ios 

Make the feature work for ios 

in particular, the actual fun RequestLocationPermission and actual fun GetUserLocationUseCase doesn't work at all in ios

Look at how the android app works and replicate the same thing for ios 

Remember - the android functionality all works exactly as intended, so all you need to do is create an ios version of that code