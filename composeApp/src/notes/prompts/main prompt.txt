package com.openparty.app.core.shared.domain

import co.touchlab.kermit.Logger

object GlobalLogger {
    val logger: Logger = Logger.withTag("GlobalLogger")
}

//File: composeApp/src/commonMain/kotlin/com/openparty/app/core/shared/domain/DomainResult.kt

package com.openparty.app.core.shared.domain

import com.openparty.app.core.shared.domain.error.AppError

sealed class DomainResult<out T> {
    data class Success<out T>(val data: T) : DomainResult<T>()
    data class Failure(val error: AppError) : DomainResult<Nothing>()
}

--
package com.openparty.app.core.shared.domain.error

sealed class AppError : Exception() {

    sealed class Navigation : AppError() {
        object General : AppError()
        object DetermineAuthStates : AppError()
    }

    sealed class Analytics : AppError() {
        object TrackAppOpen : AppError()
        object IdentifyUser : AppError()
        object TrackDiscussionsPreviewClick : AppError()
        object TrackCouncilMeetingPreviewClick : AppError()
        object TrackDiscussionPosted : AppError()
        object TrackCommentPosted : AppError()
    }
.......

--
package com.openparty.app.core.shared.domain.error

import kotlin.reflect.KClass

object AppErrorMapper {

    fun getUserFriendlyMessage(
        error: AppError,
        customOverrides: Map<KClass<out AppError>, String>? = null
    ): String {
        val overrideMessage = customOverrides?.get(error::class)
        if (overrideMessage != null) {
            return overrideMessage
        }
        return when (error) {
            // Authentication
            is AppError.Authentication.SignIn -> "We couldn't sign you in. Please check your credentials."
            is AppError.Authentication.EmailVerification -> "Verification email couldn't be sent. Please try again in a while."
            is AppError.Authentication.RefreshToken -> "There was an issue sending your request. Please try again in a while."
            is AppError.Authentication.Logout -> "Logout failed. Please try again in a while."
            is AppError.Authentication.General -> "Unknown authentication error."
            is AppError.Authentication.GetUser -> "Unable to fetch user."
            is AppError.Authentication.GetUserId -> "Unable to fetch user."
            is AppError.Authentication.Register -> "Registration failed. Please try again in a while."
            is AppError.Authentication.UserAlreadyExists -> "Cannot create a user that already exists."
..........

- Also on a side note, i'm using compose multiplatform with the koin compose library. This is an unusual library but it's important that any code you give me uses it
- I'm going to give you code from my splash feature below as an example of using koin compose library 

package com.openparty.app.features.startup.feature_splash.di

import com.openparty.app.features.startup.feature_splash.presentation.SplashViewModel
import org.koin.core.module.dsl.viewModel
import org.koin.core.module.Module
import org.koin.dsl.module

val splashModule: Module = module {
    viewModel {
        SplashViewModel(
            determineAuthStatesUseCase = get(),
            authFlowNavigationMapper = get()
        )
    }
}
package com.openparty.app.features.startup.feature_splash.presentation

import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.navigation.NavHostController
import com.openparty.app.core.shared.presentation.ErrorText
import com.openparty.app.core.shared.presentation.UiEvent
import kotlinx.coroutines.flow.collectLatest
import org.koin.compose.viewmodel.koinViewModel

@Composable
fun SplashScreen(
    navController: NavHostController,
    viewModel: SplashViewModel = koinViewModel()
) {
    val uiState by viewModel.uiState.collectAsState()

    LaunchedEffect(Unit) {
        viewModel.uiEvent.collectLatest { event ->
            when (event) {
                is UiEvent.Navigate -> {
                    navController.navigate(event.destination) {
                        popUpTo(0) { inclusive = true }
                    }
                }
            }
        }
    }

    if (uiState.errorMessage != null) {
        ErrorText(errorMessage = uiState.errorMessage)
    }
}
//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/startup/feature_splash/presentation/SplashViewModel.kt
// File: composeApp/src/commonMain/kotlin/com/openparty/app/features/startup/feature_splash/presentation/SplashViewModel.kt
package com.openparty.app.features.startup.feature_splash.presentation

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.openparty.app.core.shared.domain.DomainResult
import com.openparty.app.core.shared.domain.error.AppErrorMapper
import com.openparty.app.core.shared.presentation.UiEvent
import com.openparty.app.core.shared.presentation.UiState
import com.openparty.app.features.startup.feature_authentication.domain.usecase.DetermineAuthStatesUseCase
import com.openparty.app.features.startup.feature_authentication.presentation.AuthFlowNavigationMapper
import com.openparty.app.core.shared.domain.GlobalLogger.logger
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.SharedFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch

class SplashViewModel(
    private val determineAuthStatesUseCase: DetermineAuthStatesUseCase,
    private val authFlowNavigationMapper: AuthFlowNavigationMapper
) : ViewModel() {

    private val _uiState = MutableStateFlow(UiState())
    val uiState: StateFlow<UiState> = _uiState

    private val _uiEvent = MutableSharedFlow<UiEvent>()
    val uiEvent: SharedFlow<UiEvent> = _uiEvent

    init {
        logger.i { "SplashViewModel initialized" }
        viewModelScope.launch {
            navigateToNextAuthScreen()
        }
    }

    private suspend fun navigateToNextAuthScreen() {
        logger.i { "Starting navigation process in SplashViewModel" }
        _uiState.value = _uiState.value.copy(isLoading = true)
        when (val authStatesResult = determineAuthStatesUseCase()) {
            is DomainResult.Success -> {
                logger.i { "DetermineAuthStatesUseCase succeeded with states: ${authStatesResult.data}" }
                val destination = authFlowNavigationMapper.determineDestination(authStatesResult.data)
                _uiState.value = _uiState.value.copy(isLoading = false, errorMessage = null)
                logger.i { "Navigating to destination: ${destination.route}" }
                _uiEvent.emit(UiEvent.Navigate(destination.route))
            }
            is DomainResult.Failure -> {
                logger.e { "DetermineAuthStatesUseCase failed with error: ${authStatesResult.error}" }
                val errorMessage = AppErrorMapper.getUserFriendlyMessage(authStatesResult.error)
                _uiState.value = _uiState.value.copy(isLoading = false, errorMessage = errorMessage)
            }
        }
    }
}

- So notice that the SplashScreen uses this import: 
    - import org.koin.compose.viewmodel.koinViewModel
- And the SplashModule uses this: 
    - import org.koin.core.module.dsl.viewModel
- and it looks like this: 
viewModel {
        SplashViewModel(
            determineAuthStatesUseCase = get(),
            authFlowNavigationMapper = get()
        )
    }
- Make sure that whenever you are injecting view models using koin, it's done using koin compose and it's done using the same method as the splash view model
- Also notice how the splash viewmodel handles errors: 
when (val authStatesResult = determineAuthStatesUseCase()) {
            is DomainResult.Success -> {
                val destination = authFlowNavigationMapper.determineDestination(authStatesResult.data)
                _uiState.value = _uiState.value.copy(isLoading = false, errorMessage = null)
                _uiEvent.emit(UiEvent.Navigate(destination.route))
            }
            is DomainResult.Failure -> {
                val errorMessage = AppErrorMapper.getUserFriendlyMessage(authStatesResult.error)
                _uiState.value = _uiState.value.copy(isLoading = false, errorMessage = errorMessage)
            }
        }
- It handles them in a when statement
- If it's a success it handles the success
- If it's a failure, it unwraps the DomainResult Failure message
- It uses AppErrorMapper.getUserFriendlyMessage to map the error code to a friendly message for hte user 
- Then it uses this: 
    - _uiState.value = _uiState.value.copy(isLoading = false, errorMessage = errorMessage)
- To send an event to the SplashScreen to trigger the ErrorText in the SplashScreen: 
if (uiState.errorMessage != null) {
        ErrorText(errorMessage = uiState.errorMessage)
    }
- Make sure that whenever you are handling use cases in view models, you do it using the above pattern 
- All use cases will return a DomainResult, if it's a failure you map it to a user friendly message and send an event about it to the user 
- Also notice that navigation is done using this in the SplashScreen:
LaunchedEffect(Unit) {
        viewModel.uiEvent.collectLatest { event ->
            when (event) {
                is UiEvent.Navigate -> {
                    navController.navigate(event.destination) {
                        popUpTo(0) { inclusive = true }
                    }
                }
            }
        }
    }
- This is standard across my app. Whenever you do navigation, it should be handled in the screen
- All navigation based logic should be done in places like the view model or use cases, then the view model emits a navigation event for the screen to handle 
- This is standard across my app, so whenever you are doing navigation you should follow this pattern
- Also notice that my SplashViewModel doesn't contain any business logic
    - Instead it has use cases that handle all business logic and it injects them 
    - This again is standard across my app, all business logic is handled in use cases
    - Whenever you want to do business logic, it should be in use cases (unless it's logic that is tightly tied to the user interface)
- Also notice how the logging in splashviewmodel is done with kermit logging
    - It uses my global logger using kermit
    - Then it just implements that logging 
    - Use logging in the code you give me whwere appropriate, but always use the kermit global logger in the same way the SplashViewModel does

.............

- Also on another note, i want my use cases to be set up a specific way so i'll give you an example of that

//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/startup/feature_authentication/domain/usecase/GetCurrentUserIdUseCase.kt
package com.openparty.app.features.startup.feature_authentication.domain.usecase

import com.openparty.app.core.shared.domain.DomainResult
import com.openparty.app.core.shared.domain.error.AppError
import com.openparty.app.core.shared.domain.GlobalLogger.logger
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext

class GetCurrentUserIdUseCase(
    private val getFirebaseUserUseCase: GetFirebaseUserUseCase
) {
    suspend operator fun invoke(): DomainResult<String> {
        return withContext(Dispatchers.Default) {
            logger.i { "GetCurrentUserIdUseCase invoked" }
            try {
                logger.i { "Fetching current user" }
                when (val userResult = getFirebaseUserUseCase()) {
                    is DomainResult.Success -> {
                        logger.i { "User fetched successfully: UID=${userResult.data.uid}" }
                        DomainResult.Success(userResult.data.uid)
                    }
                    is DomainResult.Failure -> {
                        logger.e { "Failed to fetch user: ${userResult.error}" }
                        DomainResult.Failure(AppError.Authentication.GetUserId)
                    }
                }
            } catch (e: Throwable) {
                logger.e(e) { "Unexpected error while fetching user ID: ${e.message}" }
                DomainResult.Failure(AppError.Authentication.GetUserId)
            }
        }
    }
}

- So whenever there is a success, the use case wraps the success in a DomainResult and returns the relevant data
- It also has a catch statement 
- It uses kermit logging with the global logger as before
- Whenever there is a catch or a fail case, it returns the same AppError wrapped in a DomainResult.Failure
- The reason is because the point of the AppErrors is to create user friendly messages in the user interface 
- All the actual debugging is done by developers using log statements, the AppErrors are just to create user messages
- For that reason, the only thing the AppErrors represent is a simple Error about where the app failed 
- For example, if i have this -  AppError.Authentication.GetUserId
    - I know that can be mapped to a user friendly message about getting the user id such as "Failed to find the user. Try again later."
- Whenever you have use cases, it should follow the above pattern 
- Use logging, a catch statement, wrap every result in a DomainResult, have it be a DomainResult.Success for success and DomainResult.Failure for anything else
- In a DomainResult.Failure, put an error code which relates to that specific use case
- For example, if the above use case, it's called GetCurrentUserIdUseCase and returns AppError.Authentication.GetUserId
    - i.e. the AppError reflects the use case where the app failed
- You will probably need to create new AppErrors when you create a new use case since one likely won't exist
- Remember that only your use cases should be returning DomainResult object, you don't need to do this for every class
- For example this is wrong: 
class PrivacyPolicyRepositoryImpl : PrivacyPolicyRepository {
    override suspend fun acceptPrivacyPolicy(): DomainResult<Unit> {
        return DomainResult.Success(Unit)
    }
}
- There is no reason to wrap a repository implementation in a DomainResult

--

OpenParty/
├── build.gradle.kts
├── gradle/
│   ├── libs.versions.toml
│   └── wrapper/
│       ├── gradle-wrapper.jar
│       └── gradle-wrapper.properties
├── gradle.properties
├── gradlew
├── gradlew.bat
├── composeApp/
│   ├── build.gradle.kts
│   └── src/
│       ├── androidMain/
│       │   ├── AndroidManifest.xml
│       │   └── kotlin/
│       │       └── com/
│       │           └── openparty/
│       │               └── app/
│       │                   └── [Placeholder]
│       ├── commonMain/
│       │   └── kotlin/
│       │       └── com/
│       │           └── openparty/
│       │               └── app/
│       │                   └── [Placeholder]
│       └── iosMain/
│           └── kotlin/
│               └── com/
│                   └── openparty/
│                       └── app/
│                           └── [Placeholder]
└── iosApp/
    ├── configuration/
    ├── iosApp/
    │   ├── Assets.xcassets/
    │   ├── ContentView.swift
    │   ├── Info.plist
    │   ├── iOSApp.swift
    │   ├── iosApp.xcodeproj/
    │   └── Preview Content/
    └── iosApp.xcodeproj/

---------

//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/utils/settings/feature_settings/presentation/SettingsScreen.kt
package com.openparty.app.features.utils.settings.feature_settings.presentation

import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp

@Composable
fun SettingsScreen() {
    Box(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp),
        contentAlignment = Alignment.Center
    ) {
        Text(
            text = "Disclaimer\n\n" +
                    "This app is not affiliated with, endorsed by, or representative of any government entity. " +
                    "Any government-related content displayed in this app is uploaded by users. " +
                    "The app is a social media platform that allows user-generated content, and its inclusion of " +
                    "government-related information is solely from users. " +
                    "Use of this app does not establish any government affiliation or authorization.",
            style = MaterialTheme.typography.bodyLarge
        )
    }
}

package com.openparty.app.features.startup.account.feature_login.di

import com.openparty.app.features.startup.account.feature_login.domain.usecase.PerformLoginUseCase
import com.openparty.app.features.startup.account.shared.domain.usecase.ValidateCredentialsUseCase
import com.openparty.app.features.startup.account.feature_login.presentation.LoginViewModel
import org.koin.core.module.Module
import org.koin.dsl.module
import org.koin.core.module.dsl.viewModel

val loginModule: Module = module {
    single {
        ValidateCredentialsUseCase()
    }

    single {
        PerformLoginUseCase(
            validateCredentialsUseCase = get(),
            signInUseCase = get()
        )
    }

    viewModel {
        LoginViewModel(
            performLoginUseCase = get(),
            determineAuthStatesUseCase = get(),
            authFlowNavigationMapper = get()
        )
    }
}

package com.openparty.app.features.startup.account.feature_login.domain.usecase

import com.openparty.app.core.shared.domain.DomainResult
import com.openparty.app.features.startup.account.shared.domain.usecase.ValidateCredentialsUseCase
import com.openparty.app.features.startup.feature_authentication.domain.usecase.SignInUseCase
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.IO
import kotlinx.coroutines.withContext

class PerformLoginUseCase(
    private val validateCredentialsUseCase: ValidateCredentialsUseCase,
    private val signInUseCase: SignInUseCase
) {
    suspend operator fun invoke(email: String, password: String): DomainResult<Unit> {
        println("PerformLoginUseCase invoked with email: $email")
        return withContext(Dispatchers.IO) {
            println("Validating credentials")
            when (val validationResult = validateCredentialsUseCase(email, password)) {
                is DomainResult.Failure -> {
                    println("Validation failed: ${validationResult.error}")
                    return@withContext validationResult
                }
                is DomainResult.Success -> {
                    println("Validation successful for email: $email")
                }
            }
            println("Attempting to sign in")
            when (val signInResult = signInUseCase(email, password)) {
                is DomainResult.Success -> {
                    println("Sign in successful for email: $email")
                    DomainResult.Success(Unit)
                }
                is DomainResult.Failure -> {
                    println("Sign in failed: ${signInResult.error}")
                    signInResult
                }
            }
        }
    }
}
package com.openparty.app.features.startup.account.feature_login.presentation

import androidx.compose.runtime.Composable
import androidx.navigation.NavHostController
import com.openparty.app.features.startup.account.shared.presentation.AccountScreen
import org.koin.compose.viewmodel.koinViewModel

@Composable
fun LoginScreen(
    navController: NavHostController,
    viewModel: LoginViewModel = koinViewModel()
) {
    AccountScreen(
        viewModel = viewModel,
        title = "Login",
        actionText = "Login",
        footerText = "Don't have an account? Register",
        onActionClick = { viewModel.onLoginButtonClick() },
        onFooterClick = { viewModel.onTextFooterClick() },
        uiEvent = viewModel.uiEvent,
        navController = navController
    )
}
package com.openparty.app.features.startup.account.feature_login.presentation

import androidx.lifecycle.viewModelScope
import com.openparty.app.core.shared.domain.DomainResult
import com.openparty.app.core.shared.domain.error.AppErrorMapper
import com.openparty.app.core.shared.presentation.UiEvent
import com.openparty.app.features.startup.account.feature_login.domain.usecase.PerformLoginUseCase
import com.openparty.app.features.startup.account.shared.presentation.AccountViewModel
import com.openparty.app.features.startup.account.shared.presentation.model.AccountUiStateUpdate
import com.openparty.app.features.startup.feature_authentication.domain.usecase.DetermineAuthStatesUseCase
import com.openparty.app.features.startup.feature_authentication.presentation.AuthFlowNavigationMapper
import com.openparty.app.navigation.Screen
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.SharedFlow
import kotlinx.coroutines.launch

class LoginViewModel(
    private val performLoginUseCase: PerformLoginUseCase,
    private val determineAuthStatesUseCase: DetermineAuthStatesUseCase,
    private val authFlowNavigationMapper: AuthFlowNavigationMapper
) : AccountViewModel() {
    private val _uiEvent = MutableSharedFlow<UiEvent>()
    val uiEvent: SharedFlow<UiEvent> = _uiEvent
    fun onLoginButtonClick() {
        viewModelScope.launch {
            updateState(AccountUiStateUpdate.UpdateLoading(true))
            val currentState = accountUiState.value
            when (val loginResult = performLoginUseCase(currentState.email, currentState.password)) {
                is DomainResult.Success -> {
                    when (val authStatesResult = determineAuthStatesUseCase()) {
                        is DomainResult.Success -> {
                            val destination = authFlowNavigationMapper.determineDestination(authStatesResult.data)
                            _uiEvent.emit(UiEvent.Navigate(destination.route))
                        }
                        is DomainResult.Failure -> {
                            val errorMessage = AppErrorMapper.getUserFriendlyMessage(authStatesResult.error)
                            updateState(AccountUiStateUpdate.UpdateError(errorMessage))
                        }
                    }
                }
                is DomainResult.Failure -> {
                    val errorMessage = AppErrorMapper.getUserFriendlyMessage(loginResult.error)
                    updateState(AccountUiStateUpdate.UpdateError(errorMessage))
                }
            }
            updateState(AccountUiStateUpdate.UpdateLoading(false))
        }
    }
    fun onTextFooterClick() {
        viewModelScope.launch {
            _uiEvent.emit(UiEvent.Navigate(Screen.Register.route))
        }
    }
    fun clearError() {
        updateState(AccountUiStateUpdate.UpdateError(null))
    }
}
package com.openparty.app.features.startup.account.feature_register.di

import com.openparty.app.features.startup.account.feature_register.domain.usecase.PerformRegisterUseCase
import com.openparty.app.features.startup.account.feature_register.presentation.RegisterViewModel
import com.openparty.app.features.startup.account.shared.domain.usecase.ValidateCredentialsUseCase
import org.koin.core.module.dsl.viewModel
import org.koin.core.module.Module
import org.koin.dsl.module

val registerModule: Module = module {
    single { ValidateCredentialsUseCase() }
    single {
        PerformRegisterUseCase(
            validateCredentialsUseCase = get(),
            registerUseCase = get(),
            determineAuthStatesUseCase = get()
        )
    }
    viewModel {
        RegisterViewModel(
            performRegisterUseCase = get(),
            determineAuthStatesUseCase = get(),
            authFlowNavigationMapper = get()
        )
    }
}
package com.openparty.app.features.startup.account.feature_register.domain.usecase

import com.openparty.app.core.shared.domain.DomainResult
import com.openparty.app.core.shared.domain.error.AppError
import com.openparty.app.features.startup.account.shared.domain.usecase.ValidateCredentialsUseCase
import com.openparty.app.features.startup.feature_authentication.domain.usecase.DetermineAuthStatesUseCase
import com.openparty.app.features.startup.feature_authentication.domain.usecase.RegisterUseCase

class PerformRegisterUseCase(
    private val validateCredentialsUseCase: ValidateCredentialsUseCase,
    private val registerUseCase: RegisterUseCase,
    private val determineAuthStatesUseCase: DetermineAuthStatesUseCase
) {
    suspend operator fun invoke(email: String, password: String): DomainResult<Unit> {
        return try {
            println("Starting PerformRegisterUseCase with email: $email")
            when (val validateResult = validateCredentialsUseCase(email, password)) {
                is DomainResult.Failure -> {
                    println("Validation failed: $validateResult")
                    return validateResult
                }
                is DomainResult.Success -> {
                    println("Validation succeeded")
                }
            }
            when (val registerResult = registerUseCase(email, password)) {
                is DomainResult.Failure -> {
                    println("Registration failed: $registerResult")
                    return registerResult
                }
                is DomainResult.Success -> {
                    println("Registration succeeded")
                    when (val authStatesResult = determineAuthStatesUseCase()) {
                        is DomainResult.Failure -> {
                            println("DetermineAuthStatesUseCase failed: $authStatesResult")
                            return authStatesResult
                        }
                        is DomainResult.Success -> {
                            println("DetermineAuthStatesUseCase succeeded: ${authStatesResult.data}")
                        }
                    }
                }
            }
            println("PerformRegisterUseCase completed successfully")
            DomainResult.Success(Unit)
        } catch (e: Exception) {
            println("Unexpected error in PerformRegisterUseCase: $e")
            DomainResult.Failure(AppError.Authentication.Register)
        }
    }
}package com.openparty.app.features.startup.account.feature_register.presentation

import androidx.compose.runtime.Composable
import org.koin.compose.viewmodel.koinViewModel
import androidx.navigation.NavHostController
import com.openparty.app.features.startup.account.shared.presentation.AccountScreen

@Composable
fun RegisterScreen(
    navController: NavHostController,
    viewModel: RegisterViewModel = koinViewModel()
) {
    AccountScreen(
        viewModel = viewModel,
        title = "Create Your Account",
        actionText = "Register",
        footerText = "Already have an account? Login",
        onActionClick = { viewModel.onRegisterButtonClick() },
        onFooterClick = { viewModel.onTextFooterClick() },
        uiEvent = viewModel.uiEvent,
        navController = navController
    )
}
package com.openparty.app.features.startup.account.feature_register.presentation

import androidx.lifecycle.viewModelScope
import com.openparty.app.core.shared.domain.DomainResult
import com.openparty.app.core.shared.domain.error.AppErrorMapper
import com.openparty.app.core.shared.presentation.UiEvent
import com.openparty.app.features.startup.account.feature_register.domain.usecase.PerformRegisterUseCase
import com.openparty.app.features.startup.account.shared.presentation.AccountViewModel
import com.openparty.app.features.startup.account.shared.presentation.model.AccountUiStateUpdate
import com.openparty.app.features.startup.feature_authentication.domain.usecase.DetermineAuthStatesUseCase
import com.openparty.app.features.startup.feature_authentication.presentation.AuthFlowNavigationMapper
import com.openparty.app.navigation.Screen
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.SharedFlow
import kotlinx.coroutines.launch

class RegisterViewModel(
    private val performRegisterUseCase: PerformRegisterUseCase,
    private val determineAuthStatesUseCase: DetermineAuthStatesUseCase,
    private val authFlowNavigationMapper: AuthFlowNavigationMapper
) : AccountViewModel() {
    private val _uiEvent = MutableSharedFlow<UiEvent>()
    val uiEvent: SharedFlow<UiEvent> = _uiEvent
    fun onRegisterButtonClick() {
        viewModelScope.launch {
            updateState(AccountUiStateUpdate.UpdateLoading(true))
            val currentState = accountUiState.value
            when (val registerResult = performRegisterUseCase(currentState.email, currentState.password)) {
                is DomainResult.Success -> {
                    when (val authStatesResult = determineAuthStatesUseCase()) {
                        is DomainResult.Success -> {
                            val destination = authFlowNavigationMapper.determineDestination(authStatesResult.data)
                            _uiEvent.emit(UiEvent.Navigate(destination.route))
                        }
                        is DomainResult.Failure -> {
                            val errorMessage = AppErrorMapper.getUserFriendlyMessage(authStatesResult.error)
                            updateState(AccountUiStateUpdate.UpdateError(errorMessage))
                        }
                    }
                }
                is DomainResult.Failure -> {
                    val errorMessage = AppErrorMapper.getUserFriendlyMessage(registerResult.error)
                    updateState(AccountUiStateUpdate.UpdateError(errorMessage))
                }
            }
            updateState(AccountUiStateUpdate.UpdateLoading(false))
        }
    }
    fun onTextFooterClick() {
        viewModelScope.launch {
            _uiEvent.emit(UiEvent.Navigate(Screen.Login.route))
        }
    }
    fun clearError() {
        updateState(AccountUiStateUpdate.UpdateError(null))
    }
}
//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/startup/account/shared/domain/usecase/ValidateCredentialsUseCase.kt
package com.openparty.app.features.startup.account.shared.domain.usecase

import com.openparty.app.core.shared.domain.DomainResult
import com.openparty.app.core.shared.domain.error.AppError
import kotlin.text.Regex

class ValidateCredentialsUseCase {
    operator fun invoke(email: String, password: String): DomainResult<Unit> {
        println("Validating credentials for email: $email")
        if (email.isBlank() || password.isBlank()) {
            println("Validation failed: Email or password is blank")
            return DomainResult.Failure(AppError.Register.ValidateEmail)
        }
        val emailRegex = Regex("^[A-Za-z0-9+_.-]+@(.+)$")
        if (!emailRegex.matches(email)) {
            println("Validation failed: Invalid email format - $email")
            return DomainResult.Failure(AppError.Register.ValidateEmail)
        }
        if (password.length < 6) {
            println("Validation failed: Password length is less than 6 characters")
            return DomainResult.Failure(AppError.Register.ValidatePassword)
        }
        println("Validation succeeded for email: $email")
        return DomainResult.Success(Unit)
    }
}
//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/startup/account/shared/presentation/components/EmailForm.kt
package com.openparty.app.features.startup.account.shared.presentation.components

import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.input.ImeAction

@Composable
fun EmailForm(
    email: String,
    onEmailChange: (String) -> Unit
) {
    OutlinedTextField(
        value = email,
        onValueChange = onEmailChange,
        label = { Text("Email") },
        modifier = Modifier.fillMaxWidth(),
        keyboardOptions = KeyboardOptions.Default.copy(
            imeAction = ImeAction.Next
        )
    )
}
//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/startup/account/shared/presentation/components/PasswordForm.kt
package com.openparty.app.features.startup.account.shared.presentation.components

import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Visibility
import androidx.compose.material.icons.filled.VisibilityOff
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.input.ImeAction
import androidx.compose.ui.text.input.PasswordVisualTransformation
import androidx.compose.ui.text.input.VisualTransformation

@Composable
fun PasswordForm(
    password: String,
    onPasswordChange: (String) -> Unit,
    isPasswordVisible: Boolean,
    onTogglePasswordVisibility: () -> Unit,
    onDone: () -> Unit
) {
    OutlinedTextField(
        value = password,
        onValueChange = onPasswordChange,
        label = { Text("Password") },
        modifier = Modifier.fillMaxWidth(),
        visualTransformation = if (isPasswordVisible) VisualTransformation.None else PasswordVisualTransformation(),
        trailingIcon = {
            IconButton(onClick = onTogglePasswordVisibility) {
                Icon(
                    imageVector = if (isPasswordVisible) Icons.Default.Visibility else Icons.Default.VisibilityOff,
                    contentDescription = null
                )
            }
        },
        keyboardOptions = KeyboardOptions.Default.copy(
            imeAction = ImeAction.Done
        )
    )
}//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/startup/account/shared/presentation/model/AccountUiState.kt
package com.openparty.app.features.startup.account.shared.presentation.model

data class AccountUiState(
    val email: String = "",
    val password: String = "",
    val isPasswordVisible: Boolean = false,
    val error: String? = null,
    val isLoading: Boolean = false
)

//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/startup/account/shared/presentation/model/AccountUiStateUpdate.kt
package com.openparty.app.features.startup.account.shared.presentation.model

sealed class AccountUiStateUpdate {
    data class UpdateEmail(val email: String) : AccountUiStateUpdate()
    data class UpdatePassword(val password: String) : AccountUiStateUpdate()
    object TogglePasswordVisibility : AccountUiStateUpdate()
    data class UpdateError(val error: String?) : AccountUiStateUpdate()
    data class UpdateLoading(val isLoading: Boolean) : AccountUiStateUpdate()
}
//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/startup/account/shared/presentation/AccountScreen.kt
package com.openparty.app.features.startup.account.shared.presentation

import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.Button
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Surface
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.navigation.NavHostController
import com.openparty.app.core.shared.presentation.ErrorText
import com.openparty.app.core.shared.presentation.TitleText
import com.openparty.app.core.shared.presentation.UiEvent
import com.openparty.app.features.startup.account.shared.presentation.components.EmailForm
import com.openparty.app.features.startup.account.shared.presentation.components.PasswordForm
import com.openparty.app.features.startup.account.shared.presentation.model.AccountUiStateUpdate
import kotlinx.coroutines.flow.SharedFlow
import kotlinx.coroutines.flow.collectLatest

@Composable
fun AccountScreen(
    viewModel: AccountViewModel,
    title: String,
    actionText: String,
    footerText: String,
    onActionClick: () -> Unit,
    onFooterClick: () -> Unit,
    uiEvent: SharedFlow<UiEvent>? = null,
    navController: NavHostController
) {
    val state = viewModel.accountUiState.collectAsState().value
    LaunchedEffect(uiEvent) {
        uiEvent?.collectLatest { event ->
            when (event) {
                is UiEvent.Navigate -> {
                    navController.navigate(event.destination) {
                        popUpTo(event.destination) { inclusive = true }
                    }
                }
            }
        }
    }
    Surface(
        modifier = Modifier.fillMaxSize(),
        color = MaterialTheme.colorScheme.background
    ) {
        Box(modifier = Modifier.fillMaxSize()) {
            Column(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(horizontal = 32.dp, vertical = 16.dp),
                verticalArrangement = Arrangement.Center,
                horizontalAlignment = Alignment.CenterHorizontally
            ) {
                TitleText(text = title)
                Spacer(modifier = Modifier.height(16.dp))
                EmailForm(
                    email = state.email,
                    onEmailChange = { viewModel.updateState(AccountUiStateUpdate.UpdateEmail(it)) }
                )
                Spacer(modifier = Modifier.height(8.dp))
                PasswordForm(
                    password = state.password,
                    onPasswordChange = { viewModel.updateState(AccountUiStateUpdate.UpdatePassword(it)) },
                    isPasswordVisible = state.isPasswordVisible,
                    onTogglePasswordVisibility = { viewModel.updateState(AccountUiStateUpdate.TogglePasswordVisibility) },
                    onDone = onActionClick
                )
                ErrorText(errorMessage = state.error)
                Spacer(modifier = Modifier.height(16.dp))
                Button(
                    onClick = onActionClick,
                    modifier = Modifier.fillMaxWidth()
                ) {
                    Text(text = actionText)
                }
                Text(
                    text = footerText,
                    modifier = Modifier.clickable { onFooterClick() }
                )
                if (state.isLoading) {
                    Spacer(modifier = Modifier.height(16.dp))
                    CircularProgressIndicator()
                }
                Spacer(modifier = Modifier.height(16.dp))
            }
        }
    }
}
//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/startup/account/shared/presentation/AccountViewModel.kt
package com.openparty.app.features.startup.account.shared.presentation

import androidx.lifecycle.ViewModel
import com.openparty.app.features.startup.account.shared.presentation.model.AccountUiState
import com.openparty.app.features.startup.account.shared.presentation.model.AccountUiStateUpdate
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow

open class AccountViewModel : ViewModel() {
    private val _accountUiState = MutableStateFlow(AccountUiState())
    val accountUiState: StateFlow<AccountUiState> = _accountUiState.asStateFlow()
    fun updateState(update: AccountUiStateUpdate) {
        _accountUiState.value = when (update) {
            is AccountUiStateUpdate.UpdateEmail -> _accountUiState.value.copy(email = update.email)
            is AccountUiStateUpdate.UpdatePassword -> _accountUiState.value.copy(password = update.password)
            AccountUiStateUpdate.TogglePasswordVisibility -> _accountUiState.value.copy(
                isPasswordVisible = !_accountUiState.value.isPasswordVisible
            )
            is AccountUiStateUpdate.UpdateError -> _accountUiState.value.copy(error = update.error)
            is AccountUiStateUpdate.UpdateLoading -> _accountUiState.value.copy(isLoading = update.isLoading)
        }
    }
}
//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/startup/feature_authentication/data/datasource/AuthDataSource.kt
package com.openparty.app.features.startup.feature_authentication.data.datasource

import dev.gitlive.firebase.auth.FirebaseUser
import kotlinx.coroutines.flow.Flow

interface AuthDataSource {
    suspend fun signIn(email: String, password: String): FirebaseUser
    suspend fun register(email: String, password: String): FirebaseUser
    suspend fun sendVerificationEmail(user: FirebaseUser)
    fun authStateFlow(): Flow<Result<FirebaseUser?>>
    fun currentUser(): FirebaseUser?
    suspend fun getToken(forceRefresh: Boolean = false): Result<String?>
    suspend fun signOut(): Result<Unit>
}

package com.openparty.app.features.startup.feature_authentication.data.datasource

import com.openparty.app.core.shared.domain.error.AppError
import dev.gitlive.firebase.Firebase
import dev.gitlive.firebase.auth.FirebaseAuth
import dev.gitlive.firebase.auth.FirebaseAuthException
import dev.gitlive.firebase.auth.FirebaseUser
import dev.gitlive.firebase.auth.auth
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.catch
import kotlinx.coroutines.flow.flow
import kotlinx.coroutines.flow.map
import kotlin.coroutines.cancellation.CancellationException

class FirebaseAuthDataSource(
    private val auth: FirebaseAuth = Firebase.auth
) : AuthDataSource {

    override suspend fun signIn(email: String, password: String): FirebaseUser {
        return try {
            val result = auth.signInWithEmailAndPassword(email, password)
            result.user ?: throw AppError.Authentication.General
        } catch (e: FirebaseAuthException) {
            throw Exception("Sign-in failed for email: $email. Please check credentials or try again.", e)
        } catch (e: CancellationException) {
            throw e
        } catch (e: Exception) {
            throw Exception("Sign-in failed for email: $email. Please check credentials or try again.", e)
        }
    }

    override suspend fun register(email: String, password: String): FirebaseUser {
        return try {
            val result = auth.createUserWithEmailAndPassword(email, password)
            result.user ?: throw AppError.Authentication.General
        } catch (e: FirebaseAuthException) {
            if (e.message?.contains("email already in use") == true) {
                throw AppError.Authentication.UserAlreadyExists
            } else {
                throw Exception("Registration failed for email: $email. Please check input and try again.", e)
            }
        } catch (e: CancellationException) {
            throw e
        } catch (e: Exception) {
            throw Exception("Registration failed for email: $email. Please check input and try again.", e)
        }
    }

    override suspend fun sendVerificationEmail(user: FirebaseUser) {
        try {
            auth.currentUser?.sendEmailVerification()
        } catch (e: FirebaseAuthException) {
            throw Exception("Failed to send verification email to user: ${user.uid}. Please try again.", e)
        } catch (e: Exception) {
            throw Exception("Failed to send verification email to user: ${user.uid}. Please try again.", e)
        }
    }

    override fun authStateFlow(): Flow<Result<FirebaseUser?>> {
        return flow {
            emit(auth.currentUser)
            auth.authStateChanged.collect { user ->
                emit(user)
            }
        }.map { user ->
            Result.success(user)
        }.catch { e ->
            emit(Result.failure(e))
        }
    }

    override fun currentUser(): FirebaseUser? {
        return auth.currentUser
    }

    override suspend fun getToken(forceRefresh: Boolean): Result<String?> {
        return try {
            val token = auth.currentUser?.getIdToken(forceRefresh)
            Result.success(token)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }

    override suspend fun signOut(): Result<Unit> {
        return try {
            auth.signOut() // Call the Firebase sign-out method
            Result.success(Unit)
        } catch (e: Exception) {
            Result.failure(Exception("Error during sign-out process: ${e.message}", e))
        }
    }

}
//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/startup/feature_authentication/data/AuthenticationRepositoryImpl.kt
package com.openparty.app.features.startup.feature_authentication.data

import com.openparty.app.core.shared.domain.DomainResult
import com.openparty.app.core.shared.domain.error.AppError
import com.openparty.app.core.storage.SecureStorage
import com.openparty.app.features.startup.feature_authentication.data.datasource.AuthDataSource
import com.openparty.app.features.startup.feature_authentication.domain.repository.AuthenticationRepository
import dev.gitlive.firebase.auth.FirebaseUser
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map

class AuthenticationRepositoryImpl(
    private val authDataSource: AuthDataSource,
    private val secureStorage: SecureStorage
) : AuthenticationRepository {

    override suspend fun login(email: String, password: String): DomainResult<Unit> {
        println("Login invoked with email: $email")
        return try {
            val user = authDataSource.signIn(email, password)
            println("Login successful for email: $email, userId: ${user.uid}")
            val tokenResult = authDataSource.getToken(forceRefresh = true)
            tokenResult.onSuccess { token ->
                if (token != null) {
                    secureStorage.saveToken(token)
                    println("Token saved successfully for userId: ${user.uid}")
                } else {
                    println("Token is null for userId: ${user.uid}")
                    throw AppError.Authentication.General
                }
            }.onFailure { error ->
                println("Failed to fetch token for userId: ${user.uid}, exception: ${error.message}")
                throw AppError.Authentication.General
            }
            DomainResult.Success(Unit)
        } catch (e: AppError.Authentication) {
            println("Login failed for email: $email, exception: ${e.message}")
            DomainResult.Failure(e)
        } catch (e: Throwable) {
            println("Login failed for email: $email, exception: ${e.message}")
            DomainResult.Failure(AppError.Authentication.General)
        }
    }

    override suspend fun register(email: String, password: String): DomainResult<String> {
        println("Register invoked with email: $email")
        return try {
            val user = authDataSource.register(email, password)
            println("Registration successful for email: $email, userId: ${user.uid}")
            val tokenResult = authDataSource.getToken(forceRefresh = true)
            tokenResult.onSuccess { token ->
                if (token != null) {
                    secureStorage.saveToken(token)
                    println("Token saved successfully for userId: ${user.uid}")
                } else {
                    println("Token is null for userId: ${user.uid}")
                    throw AppError.Authentication.General
                }
            }.onFailure { error ->
                println("Failed to fetch token for userId: ${user.uid}, exception: ${error.message}")
                throw AppError.Authentication.General
            }
            DomainResult.Success(user.uid)
        } catch (e: AppError.Authentication.UserAlreadyExists) {
            println("Registration failed: User already exists for email: $email")
            DomainResult.Failure(AppError.Authentication.UserAlreadyExists)
        } catch (e: Throwable) {
            println("Registration failed for email: $email, exception: ${e.message}")
            DomainResult.Failure(AppError.Authentication.General)
        }
    }

    override suspend fun sendEmailVerification(): DomainResult<Unit> {
        println("SendEmailVerification invoked")
        val currentUser = authDataSource.currentUser()
        if (currentUser == null) {
            println("SendEmailVerification failed: No current user found")
            return DomainResult.Failure(AppError.Authentication.General)
        }
        return try {
            authDataSource.sendVerificationEmail(currentUser)
            println("Verification email sent successfully to userId: ${currentUser.uid}")
            DomainResult.Success(Unit)
        } catch (e: Throwable) {
            println("Failed to send verification email to userId: ${currentUser.uid}, exception: ${e.message}")
            DomainResult.Failure(AppError.Authentication.General)
        }
    }

    override fun observeAuthState(): Flow<FirebaseUser?> {
        return authDataSource.authStateFlow()
            .map { result ->
                result.getOrElse {
                    println("Error observing auth state: ${it.message}")
                    null
                }
            }
    }

    override suspend fun logout(): DomainResult<Unit> {
        println("Logout invoked")
        return try {
            val signOutResult = authDataSource.signOut()
            signOutResult.onSuccess {
                secureStorage.clearToken()
                println("User logged out and token cleared successfully")
            }.onFailure { error ->
                println("Error during sign-out process: ${error.message}")
                throw AppError.Authentication.General
            }
            DomainResult.Success(Unit)
        } catch (e: Throwable) {
            println("Logout failed, exception: ${e.message}")
            DomainResult.Failure(AppError.Authentication.General)
        }
    }

    override suspend fun getCurrentUser(): FirebaseUser? {
        println("GetCurrentUser invoked")
        return try {
            val user = authDataSource.currentUser()
            println("Current user fetched: $user")
            user
        } catch (e: Throwable) {
            println("Error fetching current user, exception: ${e.message}")
            null
        }
    }

    override suspend fun refreshAccessToken(): DomainResult<String> {
        println("RefreshAccessToken invoked")
        val user = authDataSource.currentUser()
        if (user == null) {
            println("RefreshAccessToken failed: No current user found")
            return DomainResult.Failure(AppError.Authentication.General)
        }
        return try {
            val tokenResult = authDataSource.getToken(forceRefresh = true)
            tokenResult.fold(
                onSuccess = { token ->
                    if (token != null) {
                        secureStorage.saveToken(token)
                        println("Access token refreshed and saved successfully for userId: ${user.uid}")
                        DomainResult.Success(token)
                    } else {
                        println("Token is null for userId: ${user.uid}")
                        DomainResult.Failure(AppError.Authentication.General)
                    }
                },
                onFailure = { error ->
                    println("Failed to refresh access token for userId: ${user.uid}, exception: ${error.message}")
                    DomainResult.Failure(AppError.Authentication.General)
                }
            )
        } catch (e: Throwable) {
            println("Failed to refresh access token for userId: ${user.uid}, exception: ${e.message}")
            DomainResult.Failure(AppError.Authentication.General)
        }
    }
}
//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/startup/feature_authentication/di/AuthenticationModule.kt
package com.openparty.app.features.startup.feature_authentication.di

import com.openparty.app.features.startup.feature_authentication.data.datasource.AuthDataSource
import com.openparty.app.features.startup.feature_authentication.data.datasource.FirebaseAuthDataSource
import com.openparty.app.features.startup.feature_authentication.data.AuthenticationRepositoryImpl
import com.openparty.app.features.startup.feature_authentication.domain.repository.AuthenticationRepository
import com.openparty.app.features.startup.feature_authentication.domain.usecase.*
import com.openparty.app.features.startup.feature_authentication.presentation.AuthFlowNavigationMapper
import com.openparty.app.features.shared.feature_user.domain.usecase.GetUserUseCase
import org.koin.core.module.Module
import org.koin.dsl.module

val authenticationModule: Module = module {
    single<AuthDataSource> {
        FirebaseAuthDataSource()
    }
    single<AuthenticationRepository> {
        AuthenticationRepositoryImpl(
            authDataSource = get(),
            secureStorage = get()
        )
    }
    single {
        SignInUseCase(authenticationRepository = get())
    }
    single {
        RegisterUseCase(
            authenticationRepository = get(),
            userRepository = get()
        )
    }
    single {
        SendEmailVerificationUseCase(authenticationRepository = get())
    }
    single {
        LogoutUseCase(authenticationRepository = get())
    }
    single {
        RefreshAccessTokenUseCase(authenticationRepository = get())
    }
    single {
        GetUserUseCase(
            userRepository = get(),
            getFirebaseUserUseCase = get()
        )
    }
    single {
        DetermineAuthStatesUseCase(
            authenticationRepository = get(),
            getUserUseCase = get()
        )
    }
    single {
        GetFirebaseUserUseCase(authenticationRepository = get())
    }
    single {
        GetCurrentUserIdUseCase(getFirebaseUserUseCase = get())
    }
    single {
        AuthFlowNavigationMapper()
    }
}
//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/startup/feature_authentication/domain/model/AuthState.kt
package com.openparty.app.features.startup.feature_authentication.domain.model

sealed class AuthState(val name: String) {
    object isLoggedIn : AuthState("isLoggedIn")
    object isEmailVerified : AuthState("isEmailVerified")
    object isLocationVerified : AuthState("isLocationVerified")
    object isScreenNameGenerated : AuthState("isScreenNameGenerated")
    object isPolicyAccepted : AuthState("isPolicyAccepted")
    object isManuallyVerified : AuthState("isManuallyVerified")
}
//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/startup/feature_authentication/domain/repository/AuthenticationRepository.kt
package com.openparty.app.features.startup.feature_authentication.domain.repository

import com.openparty.app.core.shared.domain.DomainResult
import dev.gitlive.firebase.auth.FirebaseUser
import kotlinx.coroutines.flow.Flow

interface AuthenticationRepository {
    suspend fun login(email: String, password: String): DomainResult<Unit>
    suspend fun register(email: String, password: String): DomainResult<String>
    suspend fun sendEmailVerification(): DomainResult<Unit>
    fun observeAuthState(): Flow<FirebaseUser?>
    suspend fun logout(): DomainResult<Unit>
    suspend fun getCurrentUser(): FirebaseUser?
    suspend fun refreshAccessToken(): DomainResult<String>
}
//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/startup/feature_authentication/domain/usecase/DetermineAuthStatesUseCase.kt
package com.openparty.app.features.startup.feature_authentication.domain.usecase

import dev.gitlive.firebase.auth.FirebaseUser
import com.openparty.app.core.shared.domain.DomainResult
import com.openparty.app.core.shared.domain.error.AppError
import com.openparty.app.features.shared.feature_user.domain.model.User
import com.openparty.app.features.startup.feature_authentication.domain.model.AuthState
import com.openparty.app.features.startup.feature_authentication.domain.repository.AuthenticationRepository
import com.openparty.app.features.shared.feature_user.domain.usecase.GetUserUseCase
import com.openparty.app.core.shared.domain.GlobalLogger.logger
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.firstOrNull
import kotlinx.coroutines.withContext

class DetermineAuthStatesUseCase(
    private val authenticationRepository: AuthenticationRepository,
    private val getUserUseCase: GetUserUseCase
) {
    suspend operator fun invoke(): DomainResult<List<AuthState>> {
        return try {
            withContext(Dispatchers.Default) {
                logger.d { "Invoking DetermineAuthStatesUseCase" }
                val firebaseUser = getFirebaseUser() ?: return@withContext DomainResult.Success(emptyList())
                reloadFirebaseUser(firebaseUser)
                determineAuthStates(firebaseUser)
            }
        } catch (e: Exception) {
            logger.e { "Unexpected error in DetermineAuthStatesUseCase: ${e.message}" }
            DomainResult.Failure(AppError.Navigation.DetermineAuthStates)
        }
    }

    private suspend fun determineAuthStates(firebaseUser: FirebaseUser): DomainResult<List<AuthState>> {
        val states = mutableListOf<AuthState>()
        val domainUser = getUserDetails(firebaseUser.uid)
            ?: return DomainResult.Failure(AppError.Navigation.DetermineAuthStates)
        states.add(AuthState.isLoggedIn)
        if (!firebaseUser.isEmailVerified) {
            logger.d { "User is logged in but email is not verified." }
            return DomainResult.Success(states)
        }
        states.add(AuthState.isEmailVerified)
        if (!domainUser.isLocationVerified) {
            logger.d { "Location not verified." }
            return DomainResult.Success(states)
        }
        states.add(AuthState.isLocationVerified)
        if (domainUser.screenName.isBlank()) {
            logger.d { "Screen name not generated." }
            return DomainResult.Success(states)
        }
        states.add(AuthState.isScreenNameGenerated)
        if (!domainUser.isPolicyAccepted) {
            logger.d { "Privacy policy not accepted." }
            return DomainResult.Success(states)
        }
        states.add(AuthState.isPolicyAccepted)
        if (!domainUser.manuallyVerified) {
            logger.d { "User not manually verified." }
            return DomainResult.Success(states)
        }
        states.add(AuthState.isManuallyVerified)
        logger.d { "All checks passed. Determined auth states: $states" }
        return DomainResult.Success(states)
    }

    private suspend fun getFirebaseUser(): FirebaseUser? {
        return try {
            authenticationRepository.observeAuthState().firstOrNull().also {
                if (it == null) logger.d { "No Firebase user found." }
            }
        } catch (e: Exception) {
            logger.e { "Error observing auth state: ${e.message}" }
            null
        }
    }

    private suspend fun reloadFirebaseUser(firebaseUser: FirebaseUser): Boolean {
        return try {
            logger.d { "Reloading Firebase user data" }
            firebaseUser.reload()
            true
        } catch (e: Exception) {
            logger.e { "Failed to reload Firebase user data: ${e.message}" }
            false
        }
    }

    private suspend fun getUserDetails(userId: String): User? {
        return try {
            when (val result = getUserUseCase()) {
                is DomainResult.Success -> {
                    logger.d { "User details fetched successfully for userId: $userId" }
                    result.data
                }
                is DomainResult.Failure -> {
                    logger.e { "Failed to fetch user details for userId: $userId" }
                    null
                }
            }
        } catch (e: Throwable) {
            logger.e { "Unexpected error fetching user details for userId: $userId, error: ${e.message}" }
            null
        }
    }
}//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/startup/feature_authentication/domain/usecase/GetCurrentUserIdUseCase.kt
package com.openparty.app.features.startup.feature_authentication.domain.usecase

import com.openparty.app.core.shared.domain.DomainResult
import com.openparty.app.core.shared.domain.error.AppError
import com.openparty.app.core.shared.domain.GlobalLogger.logger
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext

class GetCurrentUserIdUseCase(
    private val getFirebaseUserUseCase: GetFirebaseUserUseCase
) {
    suspend operator fun invoke(): DomainResult<String> {
        return withContext(Dispatchers.Default) {
            logger.i { "GetCurrentUserIdUseCase invoked" }
            try {
                logger.i { "Fetching current user" }
                when (val userResult = getFirebaseUserUseCase()) {
                    is DomainResult.Success -> {
                        logger.i { "User fetched successfully: UID=${userResult.data.uid}" }
                        DomainResult.Success(userResult.data.uid)
                    }
                    is DomainResult.Failure -> {
                        logger.e { "Failed to fetch user: ${userResult.error}" }
                        DomainResult.Failure(AppError.Authentication.GetUserId)
                    }
                }
            } catch (e: Throwable) {
                logger.e(e) { "Unexpected error while fetching user ID: ${e.message}" }
                DomainResult.Failure(AppError.Authentication.GetUserId)
            }
        }
    }
}
//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/startup/feature_authentication/domain/usecase/GetFirebaseUserUseCase.kt
package com.openparty.app.features.startup.feature_authentication.domain.usecase

import dev.gitlive.firebase.auth.FirebaseUser
import com.openparty.app.core.shared.domain.DomainResult
import com.openparty.app.core.shared.domain.error.AppError
import com.openparty.app.features.startup.feature_authentication.domain.repository.AuthenticationRepository
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext

class GetFirebaseUserUseCase(
    private val authenticationRepository: AuthenticationRepository
) {
    suspend operator fun invoke(): DomainResult<FirebaseUser> {
        return withContext(Dispatchers.Default) {
            println("GetFirebaseUserUseCase invoked")
            try {
                println("Fetching current user from authentication repository")
                val user = authenticationRepository.getCurrentUser()
                if (user != null) {
                    println("Current user retrieved successfully: UID=${user.uid}")
                    DomainResult.Success(user)
                } else {
                    println("No current user found; returning failure")
                    DomainResult.Failure(AppError.Authentication.GetUser)
                }
            } catch (e: Throwable) {
                println("Unexpected error while fetching current user: ${e.message}")
                DomainResult.Failure(AppError.Authentication.GetUser)
            }
        }
    }
}
//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/startup/feature_authentication/domain/usecase/LogoutUseCase.kt
package com.openparty.app.features.startup.feature_authentication.domain.usecase

import com.openparty.app.core.shared.domain.DomainResult
import com.openparty.app.core.shared.domain.error.AppError
import com.openparty.app.features.startup.feature_authentication.domain.repository.AuthenticationRepository
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext

class LogoutUseCase(
    private val authenticationRepository: AuthenticationRepository
) {
    suspend operator fun invoke(): DomainResult<Unit> {
        return withContext(Dispatchers.Default) {
            println("LogoutUseCase invoked")
            try {
                println("Attempting to log out user")
                val result = authenticationRepository.logout()
                when (result) {
                    is DomainResult.Success -> {
                        println("User logged out successfully")
                        DomainResult.Success(Unit)
                    }
                    is DomainResult.Failure -> {
                        println("Failed to log out user: ${result.error}")
                        DomainResult.Failure(result.error)
                    }
                }
            } catch (e: Throwable) {
                println("Unexpected error during logout: ${e.message}")
                DomainResult.Failure(AppError.Authentication.Logout)
            }
        }
    }
}
//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/startup/feature_authentication/domain/usecase/RefreshAccessTokenUseCase.kt
package com.openparty.app.features.startup.feature_authentication.domain.usecase

import com.openparty.app.core.shared.domain.DomainResult
import com.openparty.app.core.shared.domain.error.AppError
import com.openparty.app.features.startup.feature_authentication.domain.repository.AuthenticationRepository
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext

class RefreshAccessTokenUseCase(
    private val authenticationRepository: AuthenticationRepository
) {
    suspend operator fun invoke(): DomainResult<String> {
        return withContext(Dispatchers.Default) {
            println("RefreshAccessTokenUseCase invoked")
            try {
                println("Attempting to refresh access token")
                when (val result = authenticationRepository.refreshAccessToken()) {
                    is DomainResult.Success -> {
                        println("Access token refreshed successfully: ${result.data}")
                        result
                    }
                    is DomainResult.Failure -> {
                        println("Failed to refresh access token: ${result.error}")
                        DomainResult.Failure(result.error)
                    }
                }
            } catch (e: Throwable) {
                println("Unexpected error during access token refresh: ${e.message}")
                DomainResult.Failure(AppError.Authentication.RefreshToken)
            }
        }
    }
}
//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/startup/feature_authentication/domain/usecase/RegisterUseCase.kt
package com.openparty.app.features.startup.feature_authentication.domain.usecase

import com.openparty.app.core.shared.domain.DomainResult
import com.openparty.app.core.shared.domain.error.AppError
import com.openparty.app.features.shared.feature_user.data.model.OtherUserInfo
import com.openparty.app.features.shared.feature_user.data.model.UserDto
import com.openparty.app.features.shared.feature_user.domain.repository.UserRepository
import com.openparty.app.features.startup.feature_authentication.domain.repository.AuthenticationRepository
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext

class RegisterUseCase(
    private val authenticationRepository: AuthenticationRepository,
    private val userRepository: UserRepository
) {
    suspend operator fun invoke(email: String, password: String): DomainResult<Unit> {
        return withContext(Dispatchers.Default) {
            println("Registering user with email: $email")
            try {
                when (val registerResult = authenticationRepository.register(email, password)) {
                    is DomainResult.Success -> {
                        println("User successfully registered in AuthenticationRepository")
                        val userId = registerResult.data
                        val user = UserDto(
                            userId = userId,
                            accountType = "Constituent",
                            manuallyVerified = false,
                            governmentName = null,
                            location = null,
                            locationVerified = false,
                            otherUserInfo = OtherUserInfo(
                                email = email,
                                phoneNumber = null,
                                profilePictureUrl = null
                            ),
                            screenName = null,
                            title = null
                        )
                        println("Creating UserDto with userId: $userId")
                        when (val addResult = userRepository.addUser(userId, user)) {
                            is DomainResult.Success -> {
                                println("User successfully added in UserRepository with userId: $userId")
                                DomainResult.Success(Unit)
                            }
                            is DomainResult.Failure -> {
                                println("Failed to add user in UserRepository with userId: $userId")
                                DomainResult.Failure(AppError.Authentication.Register)
                            }
                        }
                    }
                    is DomainResult.Failure -> {
                        if (registerResult.error == AppError.Authentication.UserAlreadyExists) {
                            println("Failed to register user: User already exists for email: $email")
                            DomainResult.Failure(AppError.Authentication.UserAlreadyExists)
                        } else {
                            println("Failed to register user in AuthenticationRepository")
                            DomainResult.Failure(AppError.Authentication.Register)
                        }
                    }
                }
            } catch (e: Throwable) {
                println("An exception occurred while registering the user with email: $email, error: ${e.message}")
                DomainResult.Failure(AppError.Authentication.Register)
            }
        }
    }
}
//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/startup/feature_authentication/domain/usecase/SendEmailVerificationUseCase.kt
package com.openparty.app.features.startup.feature_authentication.domain.usecase

import com.openparty.app.core.shared.domain.DomainResult
import com.openparty.app.core.shared.domain.error.AppError
import com.openparty.app.features.startup.feature_authentication.domain.repository.AuthenticationRepository
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext

class SendEmailVerificationUseCase(
    private val authenticationRepository: AuthenticationRepository
) {
    suspend operator fun invoke(): DomainResult<Unit> {
        return withContext(Dispatchers.Default) {
            try {
                println("SendEmailVerificationUseCase invoked")
                when (val result = authenticationRepository.sendEmailVerification()) {
                    is DomainResult.Success -> result
                    is DomainResult.Failure -> DomainResult.Failure(result.error)
                }
            } catch (e: Throwable) {
                println("An error occurred while sending email verification: ${e.message}")
                DomainResult.Failure(AppError.Authentication.EmailVerification)
            }
        }
    }
}
//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/startup/feature_authentication/domain/usecase/SignInUseCase.kt
package com.openparty.app.features.startup.feature_authentication.domain.usecase

import com.openparty.app.core.shared.domain.DomainResult
import com.openparty.app.core.shared.domain.error.AppError
import com.openparty.app.features.startup.feature_authentication.domain.repository.AuthenticationRepository
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext

class SignInUseCase(
    private val authenticationRepository: AuthenticationRepository
) {
    suspend operator fun invoke(email: String, password: String): DomainResult<Unit> {
        return withContext(Dispatchers.Default) {
            try {
                println("SignInUseCase invoked with email: $email")
                when (val result = authenticationRepository.login(email, password)) {
                    is DomainResult.Success -> result
                    is DomainResult.Failure -> DomainResult.Failure(result.error)
                }
            } catch (e: Throwable) {
                println("An exception occurred during sign-in: ${e.message}")
                DomainResult.Failure(AppError.Authentication.SignIn)
            }
        }
    }
}
//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/startup/feature_authentication/presentation/AuthFlowNavigationMapper.kt
package com.openparty.app.features.startup.feature_authentication.presentation

import com.openparty.app.features.startup.feature_authentication.domain.model.AuthState
import com.openparty.app.navigation.Screen

class AuthFlowNavigationMapper {

    fun determineDestination(states: List<AuthState>): Screen {
        println("Determining navigation destination based on auth states: $states")

        return when {
            !states.contains(AuthState.isLoggedIn) -> {
                println("User is not logged in; navigating to Login")
                Screen.Login
            }
            !states.contains(AuthState.isEmailVerified) -> {
                println("User email is not verified; navigating to EmailVerification")
                Screen.EmailVerification
            }
            !states.contains(AuthState.isLocationVerified) -> {
                println("User location is not verified; navigating to LocationVerification")
                Screen.LocationVerification
            }
            !states.contains(AuthState.isScreenNameGenerated) -> {
                println("User screen name is not generated; navigating to ScreenNameGeneration")
                Screen.ScreenNameGeneration
            }
            !states.contains(AuthState.isPolicyAccepted) -> {
                println("Policy is not accepted; navigating to PolicyScreen")
                Screen.Policy
            }
            !states.contains(AuthState.isManuallyVerified) -> {
                println("User is not manually verified; navigating to ManualVerification")
                Screen.ManualVerification
            }
            else -> {
                println("All auth states satisfied; navigating to DiscussionsPreview")
                Screen.DiscussionsPreview
            }
        }
    }
}
//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/shared/feature_user/data/model/UserDto.kt
package com.openparty.app.features.shared.feature_user.data.model

import kotlinx.serialization.Serializable

@Serializable
data class UserDto(
    val userId: String = "",
    val accountType: String? = null,
    val manuallyVerified: Boolean = false,
    val governmentName: String? = null,
    val location: String? = null,
    val locationVerified: Boolean = false,
    val otherUserInfo: OtherUserInfo? = null,
    val screenName: String? = null,
    val title: String? = null,
    val isPolicyAccepted: Boolean = false,
    val blockedUsers: List<String> = emptyList(),
    val hiddenDiscussions: List<String> = emptyList()
)

@Serializable
data class OtherUserInfo(
    val email: String = "",
    val phoneNumber: String? = null,
    val profilePictureUrl: String? = null
)
//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/shared/feature_user/data/repository/UserRepositoryImpl.kt
package com.openparty.app.features.shared.feature_user.data.repository

import com.openparty.app.core.shared.domain.DomainResult
import com.openparty.app.core.shared.domain.error.AppError
import com.openparty.app.features.shared.feature_user.data.datasource.UserDataSource
import com.openparty.app.features.shared.feature_user.data.mapper.UserMapper
import com.openparty.app.features.shared.feature_user.data.model.UserDto
import com.openparty.app.features.shared.feature_user.domain.model.User
import com.openparty.app.features.shared.feature_user.domain.repository.UserRepository

class UserRepositoryImpl(
    private val userDataSource: UserDataSource
) : UserRepository {

    override suspend fun getUser(userId: String): DomainResult<User> {
        println("getUser called with userId: $userId")
        return try {
            val dto = userDataSource.fetchUser(userId)
            val user = UserMapper.map(dto)
            DomainResult.Success(user)
        } catch (e: Exception) {
            println("Error fetching user with userId: $userId, exception: ${e.message}")
            DomainResult.Failure(AppError.User.General)
        }
    }

    override suspend fun isScreenNameTaken(name: String): DomainResult<Boolean> {
        println("isScreenNameTaken called for name: $name")
        return try {
            val taken = userDataSource.isScreenNameTaken(name)
            DomainResult.Success(taken)
        } catch (e: Exception) {
            println("Error checking if screen name is taken: $name, exception: ${e.message}")
            DomainResult.Failure(AppError.User.General)
        }
    }

    override suspend fun updateUser(userId: String, request: Any): DomainResult<Unit> {
        println("updateUser called with userId: $userId, request: $request")
        return try {
            if (request is com.openparty.app.features.shared.feature_user.domain.model.UpdateUserRequest) {
                userDataSource.updateUser(userId, request)
                println("Successfully updated user with userId: $userId")
            } else {
                println("Invalid request type for updateUser: $request")
            }
            DomainResult.Success(Unit)
        } catch (e: Exception) {
            println("Error updating user with userId: $userId, exception: ${e.message}")
            DomainResult.Failure(AppError.User.UpdateUserUseCase)
        }
    }

    override suspend fun addUser(userId: String, user: UserDto): DomainResult<Unit> {
        println("addUser called with userId: $userId, user: $user")
        return try {
            userDataSource.addUser(userId, user)
            println("Successfully added user with userId: $userId")
            DomainResult.Success(Unit)
        } catch (e: Exception) {
            println("Error adding user with userId: $userId, exception: ${e.message}")
            DomainResult.Failure(AppError.User.General)
        }
    }

    override suspend fun blockUser(currentUserId: String, blockedUserId: String): DomainResult<Unit> {
        println("blockUser called with currentUserId: $currentUserId, blockedUserId: $blockedUserId")
        return try {
            userDataSource.blockUser(currentUserId, blockedUserId)
            println("Successfully blocked user: $blockedUserId for user: $currentUserId")
            DomainResult.Success(Unit)
        } catch (e: Exception) {
            println("Error blocking user with currentUserId: $currentUserId, blockedUserId: $blockedUserId, exception: ${e.message}")
            DomainResult.Failure(AppError.User.BlockUser)
        }
    }

    override suspend fun hideDiscussion(userId: String, discussionId: String): DomainResult<Unit> {
        println("hideDiscussion called with userId: $userId, discussionId: $discussionId")
        return try {
            userDataSource.hideDiscussion(userId, discussionId)
            println("Successfully hid discussion with discussionId: $discussionId for user: $userId")
            DomainResult.Success(Unit)
        } catch (e: Exception) {
            println("Error hiding discussion with userId: $userId, discussionId: $discussionId, exception: ${e.message}")
            DomainResult.Failure(AppError.User.HideDiscussion)
        }
    }
}
//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/shared/feature_user/domain/model/User.kt
package com.openparty.app.features.shared.feature_user.domain.model

data class User(
    val userId: String,
    val screenName: String,
    val accountType: AccountType,
    val title: String?,
    val manuallyVerified: Boolean,
    val isLocationVerified: Boolean,
    val isPolicyAccepted: Boolean,
    val blockedUsers: List<String>,
    val hiddenDiscussions: List<String>
)

enum class AccountType {
    ADMIN,
    CONSTITUENT,
    REPRESENTATIVE
}
//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/shared/feature_user/domain/model/UpdateUserRequest.kt
package com.openparty.app.features.shared.feature_user.domain.model

data class UpdateUserRequest(
    val location: String? = null,
    val locationVerified: Boolean? = null,
    val screenName: String? = null,
    val locationCoordinates: String? = null
)
//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/shared/feature_user/domain/repository/UserRepository.kt
package com.openparty.app.features.shared.feature_user.domain.repository

import com.openparty.app.core.shared.domain.DomainResult
import com.openparty.app.features.shared.feature_user.data.model.UserDto
import com.openparty.app.features.shared.feature_user.domain.model.User

interface UserRepository {
    suspend fun getUser(userId: String): DomainResult<User>
    suspend fun isScreenNameTaken(name: String): DomainResult<Boolean>
    suspend fun updateUser(userId: String, request: Any): DomainResult<Unit>
    suspend fun addUser(userId: String, user: UserDto): DomainResult<Unit>
    suspend fun blockUser(currentUserId: String, blockedUserId: String): DomainResult<Unit>
    suspend fun hideDiscussion(userId: String, discussionId: String): DomainResult<Unit>
}
//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/shared/feature_user/domain/usecase/BlockUserUseCase.kt
package com.openparty.app.features.shared.feature_user.domain.usecase

import com.openparty.app.core.shared.domain.DomainResult
import com.openparty.app.core.shared.domain.error.AppError
import com.openparty.app.core.shared.domain.GlobalLogger.logger
import com.openparty.app.features.shared.feature_user.domain.repository.UserRepository

class BlockUserUseCase(
    private val userRepository: UserRepository
) {
    suspend operator fun invoke(currentUserId: String, blockedUserId: String): DomainResult<Unit> {
        logger.i { "BlockUserUseCase invoked with currentUserId: $currentUserId and blockedUserId: $blockedUserId" }
        return try {
            userRepository.blockUser(currentUserId, blockedUserId)
        } catch (e: Throwable) {
            logger.e(e) { "Exception in BlockUserUseCase: ${e.message}" }
            DomainResult.Failure(AppError.User.BlockUser)
        }
    }
}
//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/shared/feature_user/domain/usecase/GetUserUseCase.kt
package com.openparty.app.features.shared.feature_user.domain.usecase

import com.openparty.app.core.shared.domain.DomainResult
import com.openparty.app.core.shared.domain.error.AppError
import com.openparty.app.features.shared.feature_user.domain.model.User
import com.openparty.app.features.shared.feature_user.domain.repository.UserRepository
import com.openparty.app.features.startup.feature_authentication.domain.usecase.GetFirebaseUserUseCase

class GetUserUseCase(
    private val userRepository: UserRepository,
    private val getFirebaseUserUseCase: GetFirebaseUserUseCase
) {
    suspend operator fun invoke(): DomainResult<User> {
        println("GetUserUseCase invoked")
        return try {
            when (val firebaseUserResult = getFirebaseUserUseCase()) {
                is DomainResult.Success -> {
                    val userId = firebaseUserResult.data.uid
                    println("Successfully retrieved FirebaseUser with UID: $userId")
                    when (val userResult = userRepository.getUser(userId)) {
                        is DomainResult.Success -> {
                            println("Successfully fetched user with userId: $userId")
                            DomainResult.Success(userResult.data)
                        }
                        is DomainResult.Failure -> {
                            println("Failed to fetch user with userId: $userId")
                            DomainResult.Failure(AppError.Authentication.GetUser)
                        }
                    }
                }
                is DomainResult.Failure -> {
                    println("Failed to retrieve FirebaseUser")
                    DomainResult.Failure(AppError.Authentication.GetUser)
                }
            }
        } catch (e: Throwable) {
            println("Exception occurred while fetching user: ${e.message}")
            DomainResult.Failure(AppError.Authentication.GetUser)
        }
    }
}

//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/shared/feature_user/domain/usecase/UpdateUserUseCase.kt
package com.openparty.app.features.shared.feature_user.domain.usecase

import com.openparty.app.core.shared.domain.DomainResult
import com.openparty.app.core.shared.domain.error.AppError
import com.openparty.app.features.shared.feature_user.domain.model.UpdateUserRequest
import com.openparty.app.features.shared.feature_user.domain.repository.UserRepository

class UpdateUserUseCase(
    private val userRepository: UserRepository
) {
    suspend operator fun invoke(userId: String, request: UpdateUserRequest): DomainResult<Unit> {
        println("UpdateUserUseCase invoked with userId: $userId and request: $request")
        return try {
            when (val result = userRepository.updateUser(userId, request)) {
                is DomainResult.Success -> {
                    println("Successfully updated user with userId: $userId")
                    result
                }
                is DomainResult.Failure -> {
                    println("Failed to update user with userId: $userId")
                    DomainResult.Failure(AppError.User.UpdateUserUseCase)
                }
            }
        } catch (e: Throwable) {
            println("Exception occurred while updating user with userId: $userId, exception: ${e.message}")
            DomainResult.Failure(AppError.User.UpdateUserUseCase)
        }
    }
}


---------

Notes: 
- When you give code, give the entire file, don't abbreviate anything
- Don't leave comments in the code, except a comment at a top of the file stating the file path
    - e.g. //File: composeApp/src/androidMain/kotlin/com/openparty/app/main/MainViewModel.kt
- Use the cleanest, most robust, scalable architecture you can 
- For every gradle dependency, give it in this format: implementation("org.jetbrains.androidx.lifecycle:lifecycle-viewmodel-compose:2.8.2")
    - don't give it in the libs.version.toml format. i.e. don't do this - implementation(compose.components.uiToolingPreview)
    - The exception to this is the dependencies that are already in my gradle files, leave them in the original format
- I'm using koin compose multiplatform for my depedency injection, that means that in my screen classes, I use this import - import org.koin.compose.viewmodel.koinViewModel
    - And the view model is injected like this - viewModel: DiscussionArticleViewModel = koinViewModel()
    - This might look odd to you since it's a new approach but don't change it, assume it's correct 
- Keep all business logic in use cases where appropriate 
- Whenenever you use use cases, return the DomainResult Success or Failure 
- Add Kermit logs where appropriate 
- Whenever you call a use case (for example in the view model), handle the DomainResult.Success or Failure case and use this: val errorMessage = AppErrorMapper.getUserFriendlyMessage(result.error) - to return a friendly error to the user
- Whenever you use a library in commonMain code, make sure that it's a library that's compatible with compose multiplatform

---------

I want to add functionality to the above code

The settings screen right now is just a box with text in it as a disclaimer. I want to change this 

Instead I want the settings screen to have these two features: 
- A list of cards, each card representing a setting that the user can change 
    - Each card should have an icon repreesenting the setting and text saying what the setting is 
    - e.g. for "Disclaimer" it would be an icon representing the disclaimer, then text saying "Disclaimer" 
- A logout button pinned to the bottom of the screen 
    - Don't create the functionality for the logout button right now, just leave it as a placeholder
    - I'll ask you to make this functionality later

- For right now, there will only be one card in the list of settings cards (I'll add more later) 
- The only card right now will be for "Disclaimer"
- The Disclaimer setting, when clicked, takes the user to the Disclaimer screen 
- The disclaimer screen just shows the user text that has the disclaimer 
- Right now, this text is already being shown to the user in the Settings Screen, so just take the text from the settings screen, and move it to the disclaimer screen 
- make the disclaimer screen its own feature - feature_disclaimer
- Put it here - //File: composeApp/src/commonMain/kotlin/com/openparty/app/features/utils/settings/feature_disclaimer/presentation