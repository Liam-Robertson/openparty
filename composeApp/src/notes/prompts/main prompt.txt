package com.openparty.app.core.shared.domain

import co.touchlab.kermit.Logger

object GlobalLogger {
    val logger: Logger = Logger.withTag("GlobalLogger")
}

//File: composeApp/src/commonMain/kotlin/com/openparty/app/core/shared/domain/DomainResult.kt

package com.openparty.app.core.shared.domain

import com.openparty.app.core.shared.domain.error.AppError

sealed class DomainResult<out T> {
    data class Success<out T>(val data: T) : DomainResult<T>()
    data class Failure(val error: AppError) : DomainResult<Nothing>()
}

--
package com.openparty.app.core.shared.domain.error

sealed class AppError : Exception() {

    sealed class Navigation : AppError() {
        object General : AppError()
        object DetermineAuthStates : AppError()
    }

    sealed class Analytics : AppError() {
        object TrackAppOpen : AppError()
        object IdentifyUser : AppError()
        object TrackDiscussionsPreviewClick : AppError()
        object TrackCouncilMeetingPreviewClick : AppError()
        object TrackDiscussionPosted : AppError()
        object TrackCommentPosted : AppError()
    }
.......

--
package com.openparty.app.core.shared.domain.error

import kotlin.reflect.KClass

object AppErrorMapper {

    fun getUserFriendlyMessage(
        error: AppError,
        customOverrides: Map<KClass<out AppError>, String>? = null
    ): String {
        val overrideMessage = customOverrides?.get(error::class)
        if (overrideMessage != null) {
            return overrideMessage
        }
        return when (error) {
            // Authentication
            is AppError.Authentication.SignIn -> "We couldn't sign you in. Please check your credentials."
            is AppError.Authentication.EmailVerification -> "Verification email couldn't be sent. Please try again in a while."
            is AppError.Authentication.RefreshToken -> "There was an issue sending your request. Please try again in a while."
            is AppError.Authentication.Logout -> "Logout failed. Please try again in a while."
            is AppError.Authentication.General -> "Unknown authentication error."
            is AppError.Authentication.GetUser -> "Unable to fetch user."
            is AppError.Authentication.GetUserId -> "Unable to fetch user."
            is AppError.Authentication.Register -> "Registration failed. Please try again in a while."
            is AppError.Authentication.UserAlreadyExists -> "Cannot create a user that already exists."
..........

- Also on a side note, i'm using compose multiplatform with the koin compose library. This is an unusual library but it's important that any code you give me uses it
- I'm going to give you code from my splash feature below as an example of using koin compose library 

package com.openparty.app.features.startup.feature_splash.di

import com.openparty.app.features.startup.feature_splash.presentation.SplashViewModel
import org.koin.core.module.dsl.viewModel
import org.koin.core.module.Module
import org.koin.dsl.module

val splashModule: Module = module {
    viewModel {
        SplashViewModel(
            determineAuthStatesUseCase = get(),
            authFlowNavigationMapper = get()
        )
    }
}
package com.openparty.app.features.startup.feature_splash.presentation

import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.navigation.NavHostController
import com.openparty.app.core.shared.presentation.ErrorText
import com.openparty.app.core.shared.presentation.UiEvent
import kotlinx.coroutines.flow.collectLatest
import org.koin.compose.viewmodel.koinViewModel

@Composable
fun SplashScreen(
    navController: NavHostController,
    viewModel: SplashViewModel = koinViewModel()
) {
    val uiState by viewModel.uiState.collectAsState()

    LaunchedEffect(Unit) {
        viewModel.uiEvent.collectLatest { event ->
            when (event) {
                is UiEvent.Navigate -> {
                    navController.navigate(event.destination) {
                        popUpTo(0) { inclusive = true }
                    }
                }
            }
        }
    }

    if (uiState.errorMessage != null) {
        ErrorText(errorMessage = uiState.errorMessage)
    }
}
//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/startup/feature_splash/presentation/SplashViewModel.kt
// File: composeApp/src/commonMain/kotlin/com/openparty/app/features/startup/feature_splash/presentation/SplashViewModel.kt
package com.openparty.app.features.startup.feature_splash.presentation

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.openparty.app.core.shared.domain.DomainResult
import com.openparty.app.core.shared.domain.error.AppErrorMapper
import com.openparty.app.core.shared.presentation.UiEvent
import com.openparty.app.core.shared.presentation.UiState
import com.openparty.app.features.startup.feature_authentication.domain.usecase.DetermineAuthStatesUseCase
import com.openparty.app.features.startup.feature_authentication.presentation.AuthFlowNavigationMapper
import com.openparty.app.core.shared.domain.GlobalLogger.logger
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.SharedFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch

class SplashViewModel(
    private val determineAuthStatesUseCase: DetermineAuthStatesUseCase,
    private val authFlowNavigationMapper: AuthFlowNavigationMapper
) : ViewModel() {

    private val _uiState = MutableStateFlow(UiState())
    val uiState: StateFlow<UiState> = _uiState

    private val _uiEvent = MutableSharedFlow<UiEvent>()
    val uiEvent: SharedFlow<UiEvent> = _uiEvent

    init {
        logger.i { "SplashViewModel initialized" }
        viewModelScope.launch {
            navigateToNextAuthScreen()
        }
    }

    private suspend fun navigateToNextAuthScreen() {
        logger.i { "Starting navigation process in SplashViewModel" }
        _uiState.value = _uiState.value.copy(isLoading = true)
        when (val authStatesResult = determineAuthStatesUseCase()) {
            is DomainResult.Success -> {
                logger.i { "DetermineAuthStatesUseCase succeeded with states: ${authStatesResult.data}" }
                val destination = authFlowNavigationMapper.determineDestination(authStatesResult.data)
                _uiState.value = _uiState.value.copy(isLoading = false, errorMessage = null)
                logger.i { "Navigating to destination: ${destination.route}" }
                _uiEvent.emit(UiEvent.Navigate(destination.route))
            }
            is DomainResult.Failure -> {
                logger.e { "DetermineAuthStatesUseCase failed with error: ${authStatesResult.error}" }
                val errorMessage = AppErrorMapper.getUserFriendlyMessage(authStatesResult.error)
                _uiState.value = _uiState.value.copy(isLoading = false, errorMessage = errorMessage)
            }
        }
    }
}

- So notice that the SplashScreen uses this import: 
    - import org.koin.compose.viewmodel.koinViewModel
- And the SplashModule uses this: 
    - import org.koin.core.module.dsl.viewModel
- and it looks like this: 
viewModel {
        SplashViewModel(
            determineAuthStatesUseCase = get(),
            authFlowNavigationMapper = get()
        )
    }
- Make sure that whenever you are injecting view models using koin, it's done using koin compose and it's done using the same method as the splash view model
- Also notice how the splash viewmodel handles errors: 
when (val authStatesResult = determineAuthStatesUseCase()) {
            is DomainResult.Success -> {
                val destination = authFlowNavigationMapper.determineDestination(authStatesResult.data)
                _uiState.value = _uiState.value.copy(isLoading = false, errorMessage = null)
                _uiEvent.emit(UiEvent.Navigate(destination.route))
            }
            is DomainResult.Failure -> {
                val errorMessage = AppErrorMapper.getUserFriendlyMessage(authStatesResult.error)
                _uiState.value = _uiState.value.copy(isLoading = false, errorMessage = errorMessage)
            }
        }
- It handles them in a when statement
- If it's a success it handles the success
- If it's a failure, it unwraps the DomainResult Failure message
- It uses AppErrorMapper.getUserFriendlyMessage to map the error code to a friendly message for hte user 
- Then it uses this: 
    - _uiState.value = _uiState.value.copy(isLoading = false, errorMessage = errorMessage)
- To send an event to the SplashScreen to trigger the ErrorText in the SplashScreen: 
if (uiState.errorMessage != null) {
        ErrorText(errorMessage = uiState.errorMessage)
    }
- Make sure that whenever you are handling use cases in view models, you do it using the above pattern 
- All use cases will return a DomainResult, if it's a failure you map it to a user friendly message and send an event about it to the user 
- Also notice that navigation is done using this in the SplashScreen:
LaunchedEffect(Unit) {
        viewModel.uiEvent.collectLatest { event ->
            when (event) {
                is UiEvent.Navigate -> {
                    navController.navigate(event.destination) {
                        popUpTo(0) { inclusive = true }
                    }
                }
            }
        }
    }
- This is standard across my app. Whenever you do navigation, it should be handled in the screen
- All navigation based logic should be done in places like the view model or use cases, then the view model emits a navigation event for the screen to handle 
- This is standard across my app, so whenever you are doing navigation you should follow this pattern
- Also notice that my SplashViewModel doesn't contain any business logic
    - Instead it has use cases that handle all business logic and it injects them 
    - This again is standard across my app, all business logic is handled in use cases
    - Whenever you want to do business logic, it should be in use cases (unless it's logic that is tightly tied to the user interface)
- Also notice how the logging in splashviewmodel is done with kermit logging
    - It uses my global logger using kermit
    - Then it just implements that logging 
    - Use logging in the code you give me whwere appropriate, but always use the kermit global logger in the same way the SplashViewModel does

.............

- Also on another note, i want my use cases to be set up a specific way so i'll give you an example of that

//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/startup/feature_authentication/domain/usecase/GetCurrentUserIdUseCase.kt
package com.openparty.app.features.startup.feature_authentication.domain.usecase

import com.openparty.app.core.shared.domain.DomainResult
import com.openparty.app.core.shared.domain.error.AppError
import com.openparty.app.core.shared.domain.GlobalLogger.logger
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext

class GetCurrentUserIdUseCase(
    private val getFirebaseUserUseCase: GetFirebaseUserUseCase
) {
    suspend operator fun invoke(): DomainResult<String> {
        return withContext(Dispatchers.Default) {
            logger.i { "GetCurrentUserIdUseCase invoked" }
            try {
                logger.i { "Fetching current user" }
                when (val userResult = getFirebaseUserUseCase()) {
                    is DomainResult.Success -> {
                        logger.i { "User fetched successfully: UID=${userResult.data.uid}" }
                        DomainResult.Success(userResult.data.uid)
                    }
                    is DomainResult.Failure -> {
                        logger.e { "Failed to fetch user: ${userResult.error}" }
                        DomainResult.Failure(AppError.Authentication.GetUserId)
                    }
                }
            } catch (e: Throwable) {
                logger.e(e) { "Unexpected error while fetching user ID: ${e.message}" }
                DomainResult.Failure(AppError.Authentication.GetUserId)
            }
        }
    }
}

- So whenever there is a success, the use case wraps the success in a DomainResult and returns the relevant data
- It also has a catch statement 
- It uses kermit logging with the global logger as before
- Whenever there is a catch or a fail case, it returns the same AppError wrapped in a DomainResult.Failure
- The reason is because the point of the AppErrors is to create user friendly messages in the user interface 
- All the actual debugging is done by developers using log statements, the AppErrors are just to create user messages
- For that reason, the only thing the AppErrors represent is a simple Error about where the app failed 
- For example, if i have this -  AppError.Authentication.GetUserId
    - I know that can be mapped to a user friendly message about getting the user id such as "Failed to find the user. Try again later."
- Whenever you have use cases, it should follow the above pattern 
- Use logging, a catch statement, wrap every result in a DomainResult, have it be a DomainResult.Success for success and DomainResult.Failure for anything else
- In a DomainResult.Failure, put an error code which relates to that specific use case
- For example, if the above use case, it's called GetCurrentUserIdUseCase and returns AppError.Authentication.GetUserId
    - i.e. the AppError reflects the use case where the app failed
- You will probably need to create new AppErrors when you create a new use case since one likely won't exist
- Remember that only your use cases should be returning DomainResult object, you don't need to do this for every class
- For example this is wrong: 
class PrivacyPolicyRepositoryImpl : PrivacyPolicyRepository {
    override suspend fun acceptPrivacyPolicy(): DomainResult<Unit> {
        return DomainResult.Success(Unit)
    }
}
- There is no reason to wrap a repository implementation in a DomainResult

--

OpenParty/
├── build.gradle.kts
├── gradle/
│   ├── libs.versions.toml
│   └── wrapper/
│       ├── gradle-wrapper.jar
│       └── gradle-wrapper.properties
├── gradle.properties
├── gradlew
├── gradlew.bat
├── composeApp/
│   ├── build.gradle.kts
│   └── src/
│       ├── androidMain/
│       │   ├── AndroidManifest.xml
│       │   └── kotlin/
│       │       └── com/
│       │           └── openparty/
│       │               └── app/
│       │                   └── [Placeholder]
│       ├── commonMain/
│       │   └── kotlin/
│       │       └── com/
│       │           └── openparty/
│       │               └── app/
│       │                   └── [Placeholder]
│       └── iosMain/
│           └── kotlin/
│               └── com/
│                   └── openparty/
│                       └── app/
│                           └── [Placeholder]
└── iosApp/
    ├── configuration/
    ├── iosApp/
    │   ├── Assets.xcassets/
    │   ├── ContentView.swift
    │   ├── Info.plist
    │   ├── iOSApp.swift
    │   ├── iosApp.xcodeproj/
    │   └── Preview Content/
    └── iosApp.xcodeproj/

---------
//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/startup/feature_policy/data/PolicyProvider.kt
package com.openparty.app.features.startup.feature_policy.data

expect fun loadPolicyText(): String

//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/startup/feature_policy/data/PolicyRepositoryImpl.kt
package com.openparty.app.features.startup.feature_policy.data

import com.openparty.app.features.startup.feature_policy.domain.repository.PolicyRepository

class PolicyRepositoryImpl : PolicyRepository {
    override suspend fun acceptPolicy() {
        // Implement your acceptance logic here (e.g., update local storage or make a network call)
    }
}

//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/startup/feature_policy/di/policyModule.kt
package com.openparty.app.features.startup.feature_policy.di

import com.openparty.app.features.startup.feature_policy.data.PolicyRepositoryImpl
import com.openparty.app.features.startup.feature_policy.domain.repository.PolicyRepository
import com.openparty.app.features.startup.feature_policy.domain.usecase.AcceptPolicyUseCase
import com.openparty.app.features.startup.feature_policy.presentation.PolicyViewModel
import org.koin.dsl.module
import org.koin.core.module.dsl.viewModel

val policyModule = module {
    single<PolicyRepository> { PolicyRepositoryImpl() }
    single { AcceptPolicyUseCase(get()) }
    viewModel { PolicyViewModel(get()) }
}
//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/startup/feature_policy/domain/repository/PolicyRepository.kt
package com.openparty.app.features.startup.feature_policy.domain.repository

interface PolicyRepository {
    suspend fun acceptPolicy()
}
//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/startup/feature_policy/domain/usecase/AcceptPolicyUseCase.kt
package com.openparty.app.features.startup.feature_policy.domain.usecase

import com.openparty.app.core.shared.domain.DomainResult
import com.openparty.app.core.shared.domain.GlobalLogger.logger
import com.openparty.app.core.shared.domain.error.AppError
import com.openparty.app.features.startup.feature_policy.domain.repository.PolicyRepository
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext

class AcceptPolicyUseCase(
    private val policyRepository: PolicyRepository
) {
    suspend operator fun invoke(): DomainResult<Unit> {
        return withContext(Dispatchers.Default) {
            logger.i { "AcceptPolicyUseCase invoked" }
            try {
                policyRepository.acceptPolicy()
                logger.i { "Policy accepted successfully" }
                DomainResult.Success(Unit)
            } catch (e: Exception) {
                logger.e(e) { "Error occurred while accepting policy: ${e.message}" }
                DomainResult.Failure(AppError.Policy.AcceptPolicy)
            }
        }
    }
}
//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/startup/feature_policy/presentation/PolicyScreen.kt
package com.openparty.app.features.startup.feature_policy.presentation

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.navigation.NavHostController
import com.openparty.app.core.shared.presentation.ErrorText
import com.openparty.app.core.shared.presentation.UiEvent
import com.openparty.app.features.startup.feature_policy.data.loadPolicyText
import kotlinx.coroutines.flow.collectLatest
import org.koin.compose.viewmodel.koinViewModel

@Composable
fun PolicyScreen(
    navController: NavHostController,
    viewModel: PolicyViewModel = koinViewModel()
) {
    var policyText by remember { mutableStateOf("") }

    LaunchedEffect(Unit) {
        policyText = loadPolicyText()
        viewModel.uiEvent.collectLatest { event ->
            when (event) {
                is UiEvent.Navigate -> {
                    navController.navigate(event.destination) {
                        popUpTo(0) { inclusive = true }
                    }
                }
            }
        }
    }

    val uiState by viewModel.uiState.collectAsState()

    Scaffold(
        bottomBar = {
            Button(
                onClick = { viewModel.acceptPolicy() },
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(16.dp)
            ) {
                Text(text = "Accept")
            }
        }
    ) { innerPadding ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(innerPadding)
                .padding(horizontal = 16.dp)
        ) {
            Text(
                text = "End User License Agreement",
                style = MaterialTheme.typography.headlineSmall,
                modifier = Modifier.padding(bottom = 16.dp)
            )
            Box(
                modifier = Modifier
                    .weight(1f)
                    .verticalScroll(rememberScrollState())
            ) {
                Text(
                    text = policyText,
                    style = MaterialTheme.typography.bodyMedium,
                    modifier = Modifier.padding(bottom = 16.dp)
                )
            }
            if (uiState.errorMessage != null) {
                ErrorText(errorMessage = uiState.errorMessage)
            }
        }
    }
}
//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/startup/feature_policy/presentation/PolicyViewModel.kt
package com.openparty.app.features.startup.feature_policy.presentation

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.openparty.app.core.shared.domain.DomainResult
import com.openparty.app.core.shared.domain.error.AppErrorMapper
import com.openparty.app.core.shared.presentation.UiEvent
import com.openparty.app.core.shared.presentation.UiState
import com.openparty.app.features.startup.feature_policy.domain.usecase.AcceptPolicyUseCase
import com.openparty.app.core.shared.domain.GlobalLogger.logger
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.SharedFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch

class PolicyViewModel(
    private val acceptPolicyUseCase: AcceptPolicyUseCase
) : ViewModel() {

    private val _uiState = MutableStateFlow(UiState())
    val uiState: StateFlow<UiState> = _uiState

    private val _uiEvent = MutableSharedFlow<UiEvent>()
    val uiEvent: SharedFlow<UiEvent> = _uiEvent

    init {
        logger.i { "PolicyViewModel initialized" }
    }

    fun acceptPolicy() {
        viewModelScope.launch {
            logger.i { "Accept policy triggered" }
            _uiState.value = _uiState.value.copy(isLoading = true)
            when (val result = acceptPolicyUseCase()) {
                is DomainResult.Success -> {
                    logger.i { "Policy accepted, navigating to manual verification" }
                    _uiState.value = _uiState.value.copy(isLoading = false, errorMessage = null)
                    _uiEvent.emit(UiEvent.Navigate("manual_verification"))
                }
                is DomainResult.Failure -> {
                    logger.e { "Accept policy failed with error: ${result.error}" }
                    val errorMessage = AppErrorMapper.getUserFriendlyMessage(result.error)
                    _uiState.value = _uiState.value.copy(isLoading = false, errorMessage = errorMessage)
                }
            }
        }
    }
}
//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/startup/feature_authentication/domain/usecase/DetermineAuthStatesUseCase.kt
package com.openparty.app.features.startup.feature_authentication.domain.usecase

import dev.gitlive.firebase.auth.FirebaseUser
import com.openparty.app.core.shared.domain.DomainResult
import com.openparty.app.core.shared.domain.error.AppError
import com.openparty.app.features.shared.feature_user.domain.model.User
import com.openparty.app.features.startup.feature_authentication.domain.model.AuthState
import com.openparty.app.features.startup.feature_authentication.domain.repository.AuthenticationRepository
import com.openparty.app.features.shared.feature_user.domain.usecase.GetUserUseCase
import com.openparty.app.core.shared.domain.GlobalLogger.logger
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.firstOrNull
import kotlinx.coroutines.withContext

class DetermineAuthStatesUseCase(
    private val authenticationRepository: AuthenticationRepository,
    private val getUserUseCase: GetUserUseCase
) {
    suspend operator fun invoke(): DomainResult<List<AuthState>> {
        return try {
            withContext(Dispatchers.Default) {
                logger.d { "Invoking DetermineAuthStatesUseCase" }
                val firebaseUser = getFirebaseUser() ?: return@withContext DomainResult.Success(emptyList())
                reloadFirebaseUser(firebaseUser)
                determineAuthStates(firebaseUser)
            }
        } catch (e: Exception) {
            logger.e { "Unexpected error in DetermineAuthStatesUseCase: ${e.message}" }
            DomainResult.Failure(AppError.Navigation.DetermineAuthStates)
        }
    }

    private suspend fun determineAuthStates(firebaseUser: FirebaseUser): DomainResult<List<AuthState>> {
        val states = mutableListOf<AuthState>()
        val domainUser = getUserDetails(firebaseUser.uid)
            ?: return DomainResult.Failure(AppError.Navigation.DetermineAuthStates)
        states.add(AuthState.isLoggedIn)
        if (!firebaseUser.isEmailVerified) {
            logger.d { "User is logged in but email is not verified." }
            return DomainResult.Success(states)
        }
        states.add(AuthState.isEmailVerified)
        if (!domainUser.isLocationVerified) {
            logger.d { "Location not verified." }
            return DomainResult.Success(states)
        }
        states.add(AuthState.isLocationVerified)
        if (domainUser.screenName.isBlank()) {
            logger.d { "Screen name not generated." }
            return DomainResult.Success(states)
        }
        states.add(AuthState.isScreenNameGenerated)
        if (!domainUser.isPolicyAccepted) {
            logger.d { "Privacy policy not accepted." }
            return DomainResult.Success(states)
        }
        states.add(AuthState.isPolicyAccepted)
        if (!domainUser.manuallyVerified) {
            logger.d { "User not manually verified." }
            return DomainResult.Success(states)
        }
        states.add(AuthState.isManuallyVerified)
        logger.d { "All checks passed. Determined auth states: $states" }
        return DomainResult.Success(states)
    }

    private suspend fun getFirebaseUser(): FirebaseUser? {
        return try {
            authenticationRepository.observeAuthState().firstOrNull().also {
                if (it == null) logger.d { "No Firebase user found." }
            }
        } catch (e: Exception) {
            logger.e { "Error observing auth state: ${e.message}" }
            null
        }
    }

    private suspend fun reloadFirebaseUser(firebaseUser: FirebaseUser): Boolean {
        return try {
            logger.d { "Reloading Firebase user data" }
            firebaseUser.reload()
            true
        } catch (e: Exception) {
            logger.e { "Failed to reload Firebase user data: ${e.message}" }
            false
        }
    }

    private suspend fun getUserDetails(userId: String): User? {
        return try {
            when (val result = getUserUseCase()) {
                is DomainResult.Success -> {
                    logger.d { "User details fetched successfully for userId: $userId" }
                    result.data
                }
                is DomainResult.Failure -> {
                    logger.e { "Failed to fetch user details for userId: $userId" }
                    null
                }
            }
        } catch (e: Throwable) {
            logger.e { "Unexpected error fetching user details for userId: $userId, error: ${e.message}" }
            null
        }
    }
}
//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/startup/feature_authentication/presentation/AuthFlowNavigationMapper.kt
package com.openparty.app.features.startup.feature_authentication.presentation

import com.openparty.app.features.startup.feature_authentication.domain.model.AuthState
import com.openparty.app.navigation.Screen

class AuthFlowNavigationMapper {

    fun determineDestination(states: List<AuthState>): Screen {
        println("Determining navigation destination based on auth states: $states")

        return when {
            !states.contains(AuthState.isLoggedIn) -> {
                println("User is not logged in; navigating to Login")
                Screen.Login
            }
            !states.contains(AuthState.isEmailVerified) -> {
                println("User email is not verified; navigating to EmailVerification")
                Screen.EmailVerification
            }
            !states.contains(AuthState.isLocationVerified) -> {
                println("User location is not verified; navigating to LocationVerification")
                Screen.LocationVerification
            }
            !states.contains(AuthState.isScreenNameGenerated) -> {
                println("User screen name is not generated; navigating to ScreenNameGeneration")
                Screen.ScreenNameGeneration
            }
            !states.contains(AuthState.isPolicyAccepted) -> {
                println("Policy is not accepted; navigating to PolicyScreen")
                Screen.Policy
            }
            !states.contains(AuthState.isManuallyVerified) -> {
                println("User is not manually verified; navigating to ManualVerification")
                Screen.ManualVerification
            }
            else -> {
                println("All auth states satisfied; navigating to DiscussionsPreview")
                Screen.DiscussionsPreview
            }
        }
    }
}
//File: composeApp/src/commonMain/kotlin/com/openparty/app/navigation/AppNavigation.kt
package com.openparty.app.navigation

import androidx.compose.foundation.layout.padding
import androidx.compose.material3.Scaffold
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.ui.Modifier
import androidx.navigation.NavType
import androidx.navigation.compose.NavHost
import androidx.navigation.compose.currentBackStackEntryAsState
import androidx.navigation.compose.rememberNavController
import androidx.navigation.compose.composable
import androidx.navigation.navArgument
import com.openparty.app.features.engagement.comments.feature_add_comment.presentation.AddCommentScreen
import com.openparty.app.features.newsfeed.council_meetings.feature_council_meetings_article.presentation.CouncilMeetingArticleScreen
import com.openparty.app.features.newsfeed.council_meetings.feature_council_meetings_preview.presentation.CouncilMeetingsPreviewScreen
import com.openparty.app.features.newsfeed.discussions.feature_add_discussion.presentation.AddDiscussionScreen
import com.openparty.app.features.newsfeed.discussions.feature_discussions_article.presentation.DiscussionArticleScreen
import com.openparty.app.features.newsfeed.discussions.feature_discussions_preview.presentation.DiscussionsPreviewScreen
import com.openparty.app.features.startup.account.feature_login.presentation.LoginScreen
import com.openparty.app.features.startup.account.feature_register.presentation.RegisterScreen
import com.openparty.app.features.startup.feature_policy.presentation.PolicyScreen
import com.openparty.app.features.startup.feature_screen_name_generation.presentation.ScreenNameGenerationScreen
import com.openparty.app.features.startup.feature_splash.presentation.SplashScreen
import com.openparty.app.features.startup.verification.feature_email_verification.presentation.EmailVerificationScreen
import com.openparty.app.features.startup.verification.feature_location_verification.presentation.LocationVerificationScreen
import com.openparty.app.features.startup.verification.feature_manual_verification.presentation.ManualVerificationScreen
import com.openparty.app.features.utils.feature_settings.presentation.SettingsScreen
import org.koin.compose.viewmodel.koinViewModel
import org.koin.core.parameter.parametersOf

@Composable
fun AppNavigation() {
    val navController = rememberNavController()
    val navBackStackEntry by navController.currentBackStackEntryAsState()
    val currentRoute = navBackStackEntry?.destination?.route
    val bottomBarRoutes = listOf(
        Screen.DiscussionsPreview.route,
        Screen.CouncilMeetingsPreview.route,
        Screen.Settings.route
    )
    Scaffold(
        bottomBar = {
            if (currentRoute in bottomBarRoutes) {
                NavigationFooter(navController = navController, currentRoute = currentRoute)
            }
        }
    ) { padding ->
        NavHost(
            navController = navController,
            startDestination = Screen.Splash.route,
            modifier = Modifier.padding(padding)
        ) {
            composable(Screen.Splash.route) { SplashScreen(navController) }
            composable(Screen.Login.route) { LoginScreen(navController) }
            composable(Screen.Register.route) { RegisterScreen(navController) }
            composable(Screen.EmailVerification.route) { EmailVerificationScreen(navController) }
            composable(Screen.LocationVerification.route) { LocationVerificationScreen(navController) }
            composable(Screen.ScreenNameGeneration.route) { ScreenNameGenerationScreen(navController) }
            composable(Screen.Policy.route) { PolicyScreen(navController) }
            composable(Screen.ManualVerification.route) { ManualVerificationScreen() }
            composable(Screen.DiscussionsPreview.route) { DiscussionsPreviewScreen(navController) }
            composable(Screen.CouncilMeetingsPreview.route) { CouncilMeetingsPreviewScreen(navController) }
            composable(Screen.AddDiscussion.route) { AddDiscussionScreen(navController) }
            composable(Screen.Settings.route) { SettingsScreen() }
            composable(
                route = Screen.DiscussionsArticle("").route,
                arguments = listOf(navArgument("discussionId") { type = NavType.StringType })
            ) {
                DiscussionArticleScreen(navController)
            }
            composable(
                route = Screen.CouncilMeetingsArticle("").route,
                arguments = listOf(navArgument("councilMeetingId") { type = NavType.StringType })
            ) { backStackEntry ->
                val councilMeetingId = backStackEntry.arguments?.getString("councilMeetingId") ?: ""
                val viewModel = koinViewModel<com.openparty.app.features.newsfeed.council_meetings.feature_council_meetings_article.presentation.CouncilMeetingArticleViewModel> {
                    parametersOf(councilMeetingId)
                }
                CouncilMeetingArticleScreen(navController, viewModel)
            }
            composable(
                route = Screen.AddComment("", "").route,
                arguments = listOf(
                    navArgument("discussionId") { type = NavType.StringType },
                    navArgument("titleText") { type = NavType.StringType }
                )
            ) { backStackEntry ->
                val discussionId = backStackEntry.arguments?.getString("discussionId") ?: ""
                val titleText = backStackEntry.arguments?.getString("titleText") ?: ""
                val viewModel = koinViewModel<com.openparty.app.features.engagement.comments.feature_add_comment.presentation.AddCommentViewModel> {
                    parametersOf(discussionId, titleText)
                }
                AddCommentScreen(navController, discussionId, titleText, viewModel)
            }
        }
    }
}
//File: composeApp/src/commonMain/kotlin/com/openparty/app/navigation/Screen.kt
package com.openparty.app.navigation

import kotlinx.serialization.Serializable

@Serializable
sealed class Screen(val route: String) {

    @Serializable object Splash : Screen("splash")
    @Serializable object Login : Screen("login")
    @Serializable object Register : Screen("register")
    @Serializable object EmailVerification : Screen("email_verification")
    @Serializable object LocationVerification : Screen("location_verification")
    @Serializable object ScreenNameGeneration : Screen("screen_name_generation")
    @Serializable object Policy : Screen("policy")
    @Serializable object ManualVerification : Screen("manual_verification")
    @Serializable object DiscussionsPreview : Screen("discussions_preview")
    @Serializable object CouncilMeetingsPreview : Screen("council_meetings_preview")
    @Serializable object AddDiscussion : Screen("add_discussion")
    @Serializable object Settings : Screen("settings")

    @Serializable
    data class DiscussionsArticle(val discussionId: String) : Screen("discussions_article/{discussionId}") {
        companion object {
            fun createRoute(discussionId: String): String = "discussions_article/$discussionId"
        }
    }

    @Serializable
    data class CouncilMeetingsArticle(val councilMeetingId: String) : Screen("council_meetings_article/{councilMeetingId}") {
        companion object {
            fun createRoute(councilMeetingId: String): String = "council_meetings_article/$councilMeetingId"
        }
    }

    @Serializable
    data class AddComment(val discussionId: String, val titleText: String) : Screen("add_comment/{discussionId}/{titleText}") {
        companion object {
            fun createRoute(discussionId: String, titleText: String): String = "add_comment/$discussionId/$titleText"
        }
    }
}

---------

Notes: 
- When you give code, give the entire file, don't abbreviate anything
- Don't leave comments in the code, except a comment at a top of the file stating the file path
    - e.g. //File: composeApp/src/androidMain/kotlin/com/openparty/app/main/MainViewModel.kt
- Use the cleanest, most robust, scalable architecture you can 
- For every gradle dependency, give it in this format: implementation("org.jetbrains.androidx.lifecycle:lifecycle-viewmodel-compose:2.8.2")
    - don't give it in the libs.version.toml format. i.e. don't do this - implementation(compose.components.uiToolingPreview)
    - The exception to this is the dependencies that are already in my gradle files, leave them in the original format
- I'm using koin compose multiplatform for my depedency injection, that means that in my screen classes, I use this import - import org.koin.compose.viewmodel.koinViewModel
    - And the view model is injected like this - viewModel: DiscussionArticleViewModel = koinViewModel()
    - This might look odd to you since it's a new approach but don't change it, assume it's correct 
- Keep all business logic in use cases where appropriate 
- Whenenever you use use cases, return the DomainResult Success or Failure 
- Add Kermit logs where appropriate 
- Whenever you call a use case (for example in the view model), handle the DomainResult.Success or Failure case and use this: val errorMessage = AppErrorMapper.getUserFriendlyMessage(result.error) - to return a friendly error to the user
- Whenever you use a library in commonMain code, make sure that it's a library that's compatible with compose multiplatform

---------

I've given you my policy feature 

This mostly works but i'm having issues 

on the policy screen, when the user clicks the "Accept" button, it should update the firebase database so that the user's field  "isPolicyAccepted" is set to true 

Then it should use the determineAuthStatesuseCase to go to the next screen. Here's an example: 
private suspend fun navigateToNextAuthScreen() {
        when (val result = determineAuthStatesUseCase()) {
            is DomainResult.Success -> {
                val destination = authFlowNavigationMapper.determineDestination(result.data)
                _uiEvent.emit(UiEvent.Navigate(destination.route))
            }
            is DomainResult.Failure -> {
                val errorMessage = AppErrorMapper.getUserFriendlyMessage(result.error)
                _uiState.value = _uiState.value.copy(
                    isLoading = false,
                    errorMessage = errorMessage
                )
            }
        }
    }

    ---

Right now it jsut seems to always navigate to the manual verification screen without updating the database which is wrong