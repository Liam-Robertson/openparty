package com.openparty.app.core.shared.domain

import co.touchlab.kermit.Logger

object GlobalLogger {
    val logger: Logger = Logger.withTag("GlobalLogger")
}

//File: composeApp/src/commonMain/kotlin/com/openparty/app/core/shared/domain/DomainResult.kt

package com.openparty.app.core.shared.domain

import com.openparty.app.core.shared.domain.error.AppError

sealed class DomainResult<out T> {
    data class Success<out T>(val data: T) : DomainResult<T>()
    data class Failure(val error: AppError) : DomainResult<Nothing>()
}

--
package com.openparty.app.core.shared.domain.error

sealed class AppError : Exception() {

    sealed class Navigation : AppError() {
        object General : AppError()
        object DetermineAuthStates : AppError()
    }

    sealed class Analytics : AppError() {
        object TrackAppOpen : AppError()
        object IdentifyUser : AppError()
        object TrackDiscussionsPreviewClick : AppError()
        object TrackCouncilMeetingPreviewClick : AppError()
        object TrackDiscussionPosted : AppError()
        object TrackCommentPosted : AppError()
    }
.......

--
package com.openparty.app.core.shared.domain.error

import kotlin.reflect.KClass

object AppErrorMapper {

    fun getUserFriendlyMessage(
        error: AppError,
        customOverrides: Map<KClass<out AppError>, String>? = null
    ): String {
        val overrideMessage = customOverrides?.get(error::class)
        if (overrideMessage != null) {
            return overrideMessage
        }
        return when (error) {
            // Authentication
            is AppError.Authentication.SignIn -> "We couldn't sign you in. Please check your credentials."
            is AppError.Authentication.EmailVerification -> "Verification email couldn't be sent. Please try again in a while."
            is AppError.Authentication.RefreshToken -> "There was an issue sending your request. Please try again in a while."
            is AppError.Authentication.Logout -> "Logout failed. Please try again in a while."
            is AppError.Authentication.General -> "Unknown authentication error."
            is AppError.Authentication.GetUser -> "Unable to fetch user."
            is AppError.Authentication.GetUserId -> "Unable to fetch user."
            is AppError.Authentication.Register -> "Registration failed. Please try again in a while."
            is AppError.Authentication.UserAlreadyExists -> "Cannot create a user that already exists."
..........

- Also on a side note, i'm using compose multiplatform with the koin compose library. This is an unusual library but it's important that any code you give me uses it
- I'm going to give you code from my splash feature below as an example of using koin compose library 

package com.openparty.app.features.startup.feature_splash.di

import com.openparty.app.features.startup.feature_splash.presentation.SplashViewModel
import org.koin.core.module.dsl.viewModel
import org.koin.core.module.Module
import org.koin.dsl.module

val splashModule: Module = module {
    viewModel {
        SplashViewModel(
            determineAuthStatesUseCase = get(),
            authFlowNavigationMapper = get()
        )
    }
}
package com.openparty.app.features.startup.feature_splash.presentation

import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.navigation.NavHostController
import com.openparty.app.core.shared.presentation.ErrorText
import com.openparty.app.core.shared.presentation.UiEvent
import kotlinx.coroutines.flow.collectLatest
import org.koin.compose.viewmodel.koinViewModel

@Composable
fun SplashScreen(
    navController: NavHostController,
    viewModel: SplashViewModel = koinViewModel()
) {
    val uiState by viewModel.uiState.collectAsState()

    LaunchedEffect(Unit) {
        viewModel.uiEvent.collectLatest { event ->
            when (event) {
                is UiEvent.Navigate -> {
                    navController.navigate(event.destination) {
                        popUpTo(0) { inclusive = true }
                    }
                }
            }
        }
    }

    if (uiState.errorMessage != null) {
        ErrorText(errorMessage = uiState.errorMessage)
    }
}
//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/startup/feature_splash/presentation/SplashViewModel.kt
// File: composeApp/src/commonMain/kotlin/com/openparty/app/features/startup/feature_splash/presentation/SplashViewModel.kt
package com.openparty.app.features.startup.feature_splash.presentation

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.openparty.app.core.shared.domain.DomainResult
import com.openparty.app.core.shared.domain.error.AppErrorMapper
import com.openparty.app.core.shared.presentation.UiEvent
import com.openparty.app.core.shared.presentation.UiState
import com.openparty.app.features.startup.feature_authentication.domain.usecase.DetermineAuthStatesUseCase
import com.openparty.app.features.startup.feature_authentication.presentation.AuthFlowNavigationMapper
import com.openparty.app.core.shared.domain.GlobalLogger.logger
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.SharedFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch

class SplashViewModel(
    private val determineAuthStatesUseCase: DetermineAuthStatesUseCase,
    private val authFlowNavigationMapper: AuthFlowNavigationMapper
) : ViewModel() {

    private val _uiState = MutableStateFlow(UiState())
    val uiState: StateFlow<UiState> = _uiState

    private val _uiEvent = MutableSharedFlow<UiEvent>()
    val uiEvent: SharedFlow<UiEvent> = _uiEvent

    init {
        logger.i { "SplashViewModel initialized" }
        viewModelScope.launch {
            navigateToNextAuthScreen()
        }
    }

    private suspend fun navigateToNextAuthScreen() {
        logger.i { "Starting navigation process in SplashViewModel" }
        _uiState.value = _uiState.value.copy(isLoading = true)
        when (val authStatesResult = determineAuthStatesUseCase()) {
            is DomainResult.Success -> {
                logger.i { "DetermineAuthStatesUseCase succeeded with states: ${authStatesResult.data}" }
                val destination = authFlowNavigationMapper.determineDestination(authStatesResult.data)
                _uiState.value = _uiState.value.copy(isLoading = false, errorMessage = null)
                logger.i { "Navigating to destination: ${destination.route}" }
                _uiEvent.emit(UiEvent.Navigate(destination.route))
            }
            is DomainResult.Failure -> {
                logger.e { "DetermineAuthStatesUseCase failed with error: ${authStatesResult.error}" }
                val errorMessage = AppErrorMapper.getUserFriendlyMessage(authStatesResult.error)
                _uiState.value = _uiState.value.copy(isLoading = false, errorMessage = errorMessage)
            }
        }
    }
}

- So notice that the SplashScreen uses this import: 
    - import org.koin.compose.viewmodel.koinViewModel
- And the SplashModule uses this: 
    - import org.koin.core.module.dsl.viewModel
- and it looks like this: 
viewModel {
        SplashViewModel(
            determineAuthStatesUseCase = get(),
            authFlowNavigationMapper = get()
        )
    }
- Make sure that whenever you are injecting view models using koin, it's done using koin compose and it's done using the same method as the splash view model
- Also notice how the splash viewmodel handles errors: 
when (val authStatesResult = determineAuthStatesUseCase()) {
            is DomainResult.Success -> {
                val destination = authFlowNavigationMapper.determineDestination(authStatesResult.data)
                _uiState.value = _uiState.value.copy(isLoading = false, errorMessage = null)
                _uiEvent.emit(UiEvent.Navigate(destination.route))
            }
            is DomainResult.Failure -> {
                val errorMessage = AppErrorMapper.getUserFriendlyMessage(authStatesResult.error)
                _uiState.value = _uiState.value.copy(isLoading = false, errorMessage = errorMessage)
            }
        }
- It handles them in a when statement
- If it's a success it handles the success
- If it's a failure, it unwraps the DomainResult Failure message
- It uses AppErrorMapper.getUserFriendlyMessage to map the error code to a friendly message for hte user 
- Then it uses this: 
    - _uiState.value = _uiState.value.copy(isLoading = false, errorMessage = errorMessage)
- To send an event to the SplashScreen to trigger the ErrorText in the SplashScreen: 
if (uiState.errorMessage != null) {
        ErrorText(errorMessage = uiState.errorMessage)
    }
- Make sure that whenever you are handling use cases in view models, you do it using the above pattern 
- All use cases will return a DomainResult, if it's a failure you map it to a user friendly message and send an event about it to the user 
- Also notice that navigation is done using this in the SplashScreen:
LaunchedEffect(Unit) {
        viewModel.uiEvent.collectLatest { event ->
            when (event) {
                is UiEvent.Navigate -> {
                    navController.navigate(event.destination) {
                        popUpTo(0) { inclusive = true }
                    }
                }
            }
        }
    }
- This is standard across my app. Whenever you do navigation, it should be handled in the screen
- All navigation based logic should be done in places like the view model or use cases, then the view model emits a navigation event for the screen to handle 
- This is standard across my app, so whenever you are doing navigation you should follow this pattern
- Also notice that my SplashViewModel doesn't contain any business logic
    - Instead it has use cases that handle all business logic and it injects them 
    - This again is standard across my app, all business logic is handled in use cases
    - Whenever you want to do business logic, it should be in use cases (unless it's logic that is tightly tied to the user interface)
- Also notice how the logging in splashviewmodel is done with kermit logging
    - It uses my global logger using kermit
    - Then it just implements that logging 
    - Use logging in the code you give me whwere appropriate, but always use the kermit global logger in the same way the SplashViewModel does

.............

- Also on another note, i want my use cases to be set up a specific way so i'll give you an example of that

//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/startup/feature_authentication/domain/usecase/GetCurrentUserIdUseCase.kt
package com.openparty.app.features.startup.feature_authentication.domain.usecase

import com.openparty.app.core.shared.domain.DomainResult
import com.openparty.app.core.shared.domain.error.AppError
import com.openparty.app.core.shared.domain.GlobalLogger.logger
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext

class GetCurrentUserIdUseCase(
    private val getFirebaseUserUseCase: GetFirebaseUserUseCase
) {
    suspend operator fun invoke(): DomainResult<String> {
        return withContext(Dispatchers.Default) {
            logger.i { "GetCurrentUserIdUseCase invoked" }
            try {
                logger.i { "Fetching current user" }
                when (val userResult = getFirebaseUserUseCase()) {
                    is DomainResult.Success -> {
                        logger.i { "User fetched successfully: UID=${userResult.data.uid}" }
                        DomainResult.Success(userResult.data.uid)
                    }
                    is DomainResult.Failure -> {
                        logger.e { "Failed to fetch user: ${userResult.error}" }
                        DomainResult.Failure(AppError.Authentication.GetUserId)
                    }
                }
            } catch (e: Throwable) {
                logger.e(e) { "Unexpected error while fetching user ID: ${e.message}" }
                DomainResult.Failure(AppError.Authentication.GetUserId)
            }
        }
    }
}

- So whenever there is a success, the use case wraps the success in a DomainResult and returns the relevant data
- It also has a catch statement 
- It uses kermit logging with the global logger as before
- Whenever there is a catch or a fail case, it returns the same AppError wrapped in a DomainResult.Failure
- The reason is because the point of the AppErrors is to create user friendly messages in the user interface 
- All the actual debugging is done by developers using log statements, the AppErrors are just to create user messages
- For that reason, the only thing the AppErrors represent is a simple Error about where the app failed 
- For example, if i have this -  AppError.Authentication.GetUserId
    - I know that can be mapped to a user friendly message about getting the user id such as "Failed to find the user. Try again later."
- Whenever you have use cases, it should follow the above pattern 
- Use logging, a catch statement, wrap every result in a DomainResult, have it be a DomainResult.Success for success and DomainResult.Failure for anything else
- In a DomainResult.Failure, put an error code which relates to that specific use case
- For example, if the above use case, it's called GetCurrentUserIdUseCase and returns AppError.Authentication.GetUserId
    - i.e. the AppError reflects the use case where the app failed
- You will probably need to create new AppErrors when you create a new use case since one likely won't exist
- Remember that only your use cases should be returning DomainResult object, you don't need to do this for every class
- For example this is wrong: 
class PrivacyPolicyRepositoryImpl : PrivacyPolicyRepository {
    override suspend fun acceptPrivacyPolicy(): DomainResult<Unit> {
        return DomainResult.Success(Unit)
    }
}
- There is no reason to wrap a repository implementation in a DomainResult

--

OpenParty/
├── build.gradle.kts
├── gradle/
│   ├── libs.versions.toml
│   └── wrapper/
│       ├── gradle-wrapper.jar
│       └── gradle-wrapper.properties
├── gradle.properties
├── gradlew
├── gradlew.bat
├── composeApp/
│   ├── build.gradle.kts
│   └── src/
│       ├── androidMain/
│       │   ├── AndroidManifest.xml
│       │   └── kotlin/
│       │       └── com/
│       │           └── openparty/
│       │               └── app/
│       │                   └── [Placeholder]
│       ├── commonMain/
│       │   └── kotlin/
│       │       └── com/
│       │           └── openparty/
│       │               └── app/
│       │                   └── [Placeholder]
│       └── iosMain/
│           └── kotlin/
│               └── com/
│                   └── openparty/
│                       └── app/
│                           └── [Placeholder]
└── iosApp/
    ├── configuration/
    ├── iosApp/
    │   ├── Assets.xcassets/
    │   ├── ContentView.swift
    │   ├── Info.plist
    │   ├── iOSApp.swift
    │   ├── iosApp.xcodeproj/
    │   └── Preview Content/
    └── iosApp.xcodeproj/

---------

//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/newsfeed/discussions/feature_discussions_preview/di/DiscussionsKoinModule.kt
package com.openparty.app.features.newsfeed.discussions.feature_discussions_preview.di

import com.openparty.app.features.newsfeed.discussions.shared.domain.repository.DiscussionRepository
import com.openparty.app.features.newsfeed.discussions.shared.data.repository.DiscussionRepositoryImpl
import com.openparty.app.features.newsfeed.discussions.feature_discussions_preview.domain.usecase.GetDiscussionsUseCase
import com.openparty.app.features.newsfeed.discussions.feature_discussions_preview.presentation.DiscussionsPreviewViewModel
import dev.gitlive.firebase.Firebase
import dev.gitlive.firebase.firestore.firestore
import org.koin.core.module.dsl.viewModel
import org.koin.dsl.module

val discussionsKoinModule = module {
    single<DiscussionRepository> { DiscussionRepositoryImpl(get()) }
    single { Firebase.firestore }
    single { GetDiscussionsUseCase(get()) }
    viewModel { DiscussionsPreviewViewModel(get(), get(), get(), get()) }
}
//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/newsfeed/discussions/feature_discussions_preview/domain/usecase/GetDiscussionsUseCase.kt
package com.openparty.app.features.newsfeed.discussions.feature_discussions_preview.domain.usecase

import androidx.paging.PagingData
import com.openparty.app.core.shared.domain.DomainResult
import com.openparty.app.core.shared.domain.error.AppError
import com.openparty.app.features.newsfeed.discussions.shared.domain.model.Discussion
import com.openparty.app.features.newsfeed.discussions.shared.domain.repository.DiscussionRepository
import kotlinx.coroutines.flow.Flow
import com.openparty.app.core.shared.domain.GlobalLogger.logger

class GetDiscussionsUseCase(
    private val repository: DiscussionRepository
) {
    operator fun invoke(): DomainResult<Flow<PagingData<Discussion>>> {
        logger.i { "GetDiscussionsUseCase invoked" }
        return try {
            logger.i { "Fetching discussions from repository" }
            val discussionsFlow = repository.getDiscussions()
            logger.i { "Successfully fetched discussions flow" }
            DomainResult.Success(discussionsFlow)
        } catch (e: Exception) {
            logger.e(e) { "Error occurred while fetching discussions" }
            DomainResult.Failure(AppError.Discussion.FetchDiscussions)
        }
    }
}

//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/newsfeed/discussions/feature_discussions_preview/presentation/DiscussionCard.kt
package com.openparty.app.features.newsfeed.discussions.feature_discussions_preview.presentation

import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.Card
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.ListItem
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.ModalBottomSheet
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.getValue
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.dp
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.MoreVert
import androidx.compose.material.icons.filled.Block
import androidx.compose.material.icons.filled.VisibilityOff
import com.openparty.app.features.engagement.engagement_bars.feature_preview_enagement_footer.presentation.EngagementFooter
import com.openparty.app.features.engagement.engagement_bars.feature_preview_enagement_footer.domain.model.EngagementFooterState
import com.openparty.app.features.newsfeed.discussions.shared.domain.model.Discussion

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun DiscussionCard(
    discussion: Discussion,
    currentUserId: String,
    onClick: () -> Unit,
    onBlockUser: (blockedUserId: String) -> Unit
) {
    var showBottomSheet by remember { mutableStateOf(false) }
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .padding(8.dp)
    ) {
        Box(modifier = Modifier.fillMaxSize()) {
            Column(
                modifier = Modifier
                    .clickable { onClick() }
                    .padding(16.dp)
            ) {
                Text(
                    text = discussion.title,
                    style = MaterialTheme.typography.titleLarge,
                    maxLines = 1,
                    overflow = TextOverflow.Ellipsis
                )
                Spacer(modifier = Modifier.height(8.dp))
                Text(
                    text = discussion.contentText,
                    style = MaterialTheme.typography.bodyMedium,
                    maxLines = 2,
                    overflow = TextOverflow.Ellipsis
                )
                Spacer(modifier = Modifier.height(16.dp))
                EngagementFooter(
                    currentUserId = currentUserId,
                    discussionId = discussion.discussionId,
                    initialState = EngagementFooterState(
                        upvoteCount = discussion.upvoteCount,
                        downvoteCount = discussion.downvoteCount,
                        commentCount = discussion.commentCount,
                        userVote = null
                    )
                )
            }
            IconButton(
                onClick = { showBottomSheet = true },
                modifier = Modifier.align(Alignment.TopEnd)
            ) {
                Icon(
                    imageVector = Icons.Default.MoreVert,
                    contentDescription = "Settings"
                )
            }
        }
    }
    if (showBottomSheet) {
        ModalBottomSheet(
            onDismissRequest = { showBottomSheet = false }
        ) {
            ListItem(
                headlineContent = { Text("Block Account") },
                leadingContent = {
                    Icon(
                        imageVector = Icons.Default.Block,
                        contentDescription = "Block Account"
                    )
                },
                modifier = Modifier.clickable {
                    showBottomSheet = false
                    onBlockUser(discussion.userId)
                }
            )
            ListItem(
                headlineContent = { Text("Hide Content") },
                leadingContent = {
                    Icon(
                        imageVector = Icons.Default.VisibilityOff,
                        contentDescription = "Hide Content"
                    )
                },
                modifier = Modifier.clickable { showBottomSheet = false }
            )
        }
    }
}
//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/newsfeed/discussions/feature_discussions_preview/presentation/DiscussionsPreviewScreen.kt
package com.openparty.app.features.newsfeed.discussions.feature_discussions_preview.presentation

import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.ui.Modifier
import org.koin.compose.viewmodel.koinViewModel
import androidx.navigation.NavHostController
import app.cash.paging.compose.collectAsLazyPagingItems
import com.openparty.app.core.shared.presentation.ErrorText
import com.openparty.app.core.shared.presentation.UiEvent
import com.openparty.app.features.newsfeed.discussions.feature_add_discussion.presentation.AddDiscussionButton
import com.openparty.app.features.newsfeed.shared.presentation.BaseFeedScreen
import com.openparty.app.navigation.NavigationFooter
import com.openparty.app.navigation.Screen
import com.openparty.app.features.newsfeed.discussions.shared.domain.model.Discussion
import kotlinx.coroutines.flow.collectLatest

@Composable
fun DiscussionsPreviewScreen(
    navController: NavHostController,
    viewModel: DiscussionsPreviewViewModel = koinViewModel()
) {
    val lazyDiscussions = viewModel.discussions.collectAsLazyPagingItems()
    val uiEvent = viewModel.uiEvent
    val uiState by viewModel.uiState.collectAsState()
    val currentUserId by viewModel.currentUserId.collectAsState()

    LaunchedEffect(uiEvent) {
        uiEvent.collectLatest { event ->
            when (event) {
                is UiEvent.Navigate -> {
                    navController.navigate(event.destination)
                }
            }
        }
    }

    Box(modifier = Modifier.fillMaxSize()) {
        Column(modifier = Modifier.fillMaxSize()) {
            Box(modifier = Modifier.weight(1f)) {
                if (currentUserId != null) {
                    BaseFeedScreen<Discussion>(
                        items = lazyDiscussions,
                        emptyPlaceholder = "No discussions yet..."
                    ) { discussion ->
                        if (discussion != null) {
                            DiscussionCard(
                                discussion = discussion,
                                currentUserId = currentUserId!!,
                                onClick = { viewModel.onDiscussionSelected(discussion.discussionId) },
                                onBlockUser = { blockedUserId ->
                                    viewModel.onBlockUser(blockedUserId)
                                }
                            )
                        }
                    }
                    AddDiscussionButton {
                        navController.navigate(Screen.AddDiscussion.route)
                    }
                } else {
                    // Optionally, display a loading indicator or placeholder until user ID is available.
                }
            }
            ErrorText(errorMessage = uiState.errorMessage)
        }
    }
}//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/newsfeed/discussions/feature_discussions_preview/presentation/DiscussionsPreviewViewModel.kt
package com.openparty.app.features.newsfeed.discussions.feature_discussions_preview.presentation

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import androidx.paging.PagingData
import androidx.paging.cachedIn
import androidx.paging.filter
import com.openparty.app.core.analytics.domain.usecase.TrackDiscussionSelectedUseCase
import com.openparty.app.core.shared.domain.DomainResult
import com.openparty.app.core.shared.domain.error.AppErrorMapper
import com.openparty.app.core.shared.presentation.UiEvent
import com.openparty.app.core.shared.presentation.UiState
import com.openparty.app.features.newsfeed.discussions.shared.domain.model.Discussion
import com.openparty.app.features.newsfeed.discussions.feature_discussions_preview.domain.usecase.GetDiscussionsUseCase
import com.openparty.app.features.shared.feature_user.domain.usecase.BlockUserUseCase
import com.openparty.app.features.shared.feature_user.domain.usecase.GetUserUseCase
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.SharedFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.launch
import com.openparty.app.core.shared.domain.GlobalLogger.logger
import com.openparty.app.navigation.Screen

class DiscussionsPreviewViewModel(
    private val getDiscussionsUseCase: GetDiscussionsUseCase,
    private val trackDiscussionSelectedUseCase: TrackDiscussionSelectedUseCase,
    private val blockUserUseCase: BlockUserUseCase,
    private val getUserUseCase: GetUserUseCase
) : ViewModel() {

    private val _uiState = MutableStateFlow(UiState())
    val uiState: StateFlow<UiState> = _uiState

    private val _uiEvent = MutableSharedFlow<UiEvent>()
    val uiEvent: SharedFlow<UiEvent> = _uiEvent

    private val _currentUserId = MutableStateFlow<String?>(null)
    val currentUserId: StateFlow<String?> = _currentUserId

    private val _blockedUsers = MutableStateFlow<List<String>>(emptyList())
    val blockedUsers: StateFlow<List<String>> = _blockedUsers

    private val _rawDiscussions = MutableStateFlow<PagingData<Discussion>>(PagingData.empty())
    val discussions = combine(_rawDiscussions, _blockedUsers) { pagingData, blockedUsers ->
        pagingData.filter { discussion ->
            !blockedUsers.contains(discussion.userId)
        }
    }

    init {
        loadUser()
        loadDiscussions()
    }

    private fun loadUser() {
        viewModelScope.launch {
            when (val result = getUserUseCase()) {
                is DomainResult.Success -> {
                    val user = result.data
                    _currentUserId.value = user.userId
                    _blockedUsers.value = user.blockedUsers
                    logger.i { "Loaded user: ${user.userId} with blocked users: ${user.blockedUsers}" }
                }
                is DomainResult.Failure -> {
                    val errorMessage = AppErrorMapper.getUserFriendlyMessage(result.error)
                    logger.e(result.error) { "Error loading user: $errorMessage" }
                }
            }
        }
    }

    private fun loadDiscussions() {
        viewModelScope.launch {
            _uiState.value = _uiState.value.copy(isLoading = true)
            when (val result = getDiscussionsUseCase()) {
                is DomainResult.Success -> {
                    result.data.cachedIn(viewModelScope).collect { pagingData ->
                        _rawDiscussions.value = pagingData
                    }
                    _uiState.value = _uiState.value.copy(isLoading = false, errorMessage = null)
                }
                is DomainResult.Failure -> {
                    val errorMessage = AppErrorMapper.getUserFriendlyMessage(result.error)
                    logger.e(result.error) { "Error loading discussions" }
                    _uiState.value = _uiState.value.copy(isLoading = false, errorMessage = errorMessage)
                }
            }
        }
    }

    fun onDiscussionSelected(discussionId: String) {
        viewModelScope.launch {
            when (val result = trackDiscussionSelectedUseCase(discussionId)) {
                is DomainResult.Success -> logger.i { "Discussion selected event tracked: $discussionId" }
                is DomainResult.Failure -> logger.e { "Failed to track discussion selected event for ID: $discussionId" }
            }
            _uiEvent.emit(UiEvent.Navigate(Screen.DiscussionsArticle.createRoute(discussionId)))
        }
    }

    fun onBlockUser(authorId: String) {
        viewModelScope.launch {
            val currentUser = _currentUserId.value
            if (currentUser == null) {
                logger.e { "Current user ID is null, cannot block user" }
                return@launch
            }
            when (val result = blockUserUseCase(currentUser, authorId)) {
                is DomainResult.Success -> {
                    logger.i { "Successfully blocked user: $authorId" }
                    loadUser()
                }
                is DomainResult.Failure -> {
                    val errorMessage = AppErrorMapper.getUserFriendlyMessage(result.error)
                    logger.e(result.error) { "Failed to block user: $authorId" }
                    _uiState.value = _uiState.value.copy(errorMessage = errorMessage)
                }
            }
        }
    }
}
// File: composeApp/src/commonMain/kotlin/com/openparty/app/features/newsfeed/discussions/shared/data/repository/DiscussionRepositoryImpl.kt
package com.openparty.app.features.newsfeed.discussions.shared.data.repository

import androidx.paging.PagingData
import com.openparty.app.core.shared.domain.DomainResult
import com.openparty.app.core.shared.domain.error.AppError
import com.openparty.app.features.newsfeed.discussions.shared.domain.repository.DiscussionRepository
import com.openparty.app.features.newsfeed.discussions.shared.domain.model.Discussion
import com.openparty.app.features.newsfeed.shared.data.datasource.FirebaseNewsfeedDataSource
import com.openparty.app.features.newsfeed.shared.data.repository.FirestoreRepository
import kotlinx.coroutines.flow.Flow
import com.openparty.app.core.shared.domain.GlobalLogger.logger
import dev.gitlive.firebase.firestore.FirebaseFirestore
import kotlin.random.Random
import kotlinx.serialization.serializer

class DiscussionRepositoryImpl(
    private val firestore: FirebaseFirestore
) : FirestoreRepository<Discussion>(
    dataSource = FirebaseNewsfeedDataSource(
        firestore = firestore,
        collectionName = "discussions",
        orderByField = "upvoteCount",
        transform = { documentSnapshot ->
            try {
                logger.i { "Transforming document snapshot to Discussion object: ${documentSnapshot.id}" }
                val decoded: Discussion? = try {
                    documentSnapshot.data(Discussion.serializer())
                } catch (e: Exception) {
                    null
                }
                decoded?.copy(discussionId = documentSnapshot.id)
            } catch (e: Exception) {
                logger.e(e) { "Error transforming document snapshot to Discussion object: ${documentSnapshot.id}" }
                null
            }
        }
    ),
    error = AppError.Discussion.General
), DiscussionRepository {

    override fun getDiscussions(): Flow<PagingData<Discussion>> {
        logger.i { "Fetching discussions from DiscussionRepositoryImpl" }
        return getPagedItems()
    }

    override suspend fun getDiscussionById(discussionId: String): DomainResult<Discussion> {
        logger.i { "Fetching discussion by ID: $discussionId from DiscussionRepositoryImpl" }
        return getItemById(discussionId)
    }

    override suspend fun addDiscussion(discussion: Discussion): DomainResult<Discussion> {
        logger.i { "addDiscussion invoked for discussion: ${discussion.title}" }
        return try {
            val generatedId = Random.nextLong().toString()
            val document = firestore.collection("discussions").document(generatedId)
            logger.i { "Generated new document ID: ${document.id} for discussion: ${discussion.title}" }
            val discussionWithId = discussion.copy(discussionId = document.id)
            document.set(discussionWithId)
            logger.i { "Successfully added discussion with ID: ${discussionWithId.discussionId}" }
            DomainResult.Success(discussionWithId)
        } catch (e: Exception) {
            logger.e(e) { "Error adding discussion: ${discussion.title}" }
            DomainResult.Failure(AppError.Discussion.General)
        }
    }
}
//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/newsfeed/discussions/shared/domain/model/Discussion.kt
package com.openparty.app.features.newsfeed.discussions.shared.domain.model

import dev.gitlive.firebase.firestore.Timestamp
import kotlinx.serialization.Serializable

@Serializable
data class Discussion(
    val discussionId: String = "",
    val userId: String = "",
    val title: String = "",
    val contentText: String = "",
    val timestamp: Timestamp? = null,
    val commentCount: Int = 0,
    val upvoteCount: Int = 0,
    val downvoteCount: Int = 0
)
//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/newsfeed/discussions/shared/data/domain/repository/DiscussionRepository.kt
package com.openparty.app.features.newsfeed.discussions.shared.domain.repository

import androidx.paging.PagingData
import com.openparty.app.core.shared.domain.DomainResult
import com.openparty.app.features.newsfeed.discussions.shared.domain.model.Discussion
import kotlinx.coroutines.flow.Flow

interface DiscussionRepository {
    fun getDiscussions(): Flow<PagingData<Discussion>>
    suspend fun getDiscussionById(discussionId: String): DomainResult<Discussion>
    suspend fun addDiscussion(discussion: Discussion): DomainResult<Discussion>
}
//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/newsfeed/shared/data/datasource/FirebaseNewsfeedDataSource.kt
package com.openparty.app.features.newsfeed.shared.data.datasource

import dev.gitlive.firebase.firestore.DocumentSnapshot
import dev.gitlive.firebase.firestore.FirebaseFirestore
import dev.gitlive.firebase.firestore.Query
import dev.gitlive.firebase.firestore.Direction
import com.openparty.app.core.shared.domain.GlobalLogger.logger

class FirebaseNewsfeedDataSource<T : Any>(
    private val firestore: FirebaseFirestore,
    val collectionName: String,
    private val orderByField: String,
    val transform: (DocumentSnapshot) -> T?
) {
    fun getQuery(startAfter: DocumentSnapshot?, loadSize: Int): Query {
        val queryDescription = buildString {
            appendLine("Constructing Firestore query:")
            appendLine("  Collection: $collectionName")
            appendLine("  OrderBy: $orderByField (DESC)")
            appendLine("  Limit: $loadSize")
            if (startAfter != null) {
                appendLine("  StartAfter doc ID: ${startAfter.id}")
            }
        }
        logger.d { "getQuery() -> $queryDescription" }
        return try {
            val baseQuery = firestore.collection(collectionName)
                .orderBy(orderByField, Direction.DESCENDING)
                .limit(loadSize.toLong())
            if (startAfter != null) {
                baseQuery.startAfter(startAfter)
            } else {
                baseQuery
            }
        } catch (e: Exception) {
            logger.e(e) { "Error creating query for collection: $collectionName" }
            throw Exception("Failed to create query for collection: $collectionName. Please try again.", e)
        }
    }

    suspend fun getItemById(itemId: String): T? {
        logger.d { "Fetching item by ID: $itemId from collection: $collectionName" }
        return try {
            val snapshot = firestore.collection(collectionName)
                .document(itemId)
                .get()
            logger.d { "Item fetched successfully for ID: $itemId in collection: $collectionName" }
            transform(snapshot)
        } catch (e: Exception) {
            logger.e(e) { "Error fetching item by ID: $itemId from collection: $collectionName" }
            null
        }
    }
}
// File: composeApp/src/commonMain/kotlin/com/openparty/app/features/newsfeed/shared/data/datasource/FirestorePagingSource.kt
package com.openparty.app.features.newsfeed.shared.data.datasource

import app.cash.paging.PagingSource
import app.cash.paging.PagingState
import dev.gitlive.firebase.firestore.DocumentSnapshot
import com.openparty.app.core.shared.domain.GlobalLogger.logger

class FirestorePagingSource<T : Any>(
    private val dataSource: FirebaseNewsfeedDataSource<T>
) : PagingSource<DocumentSnapshot, T>() {

    override suspend fun load(params: LoadParams<DocumentSnapshot>): LoadResult<DocumentSnapshot, T> {
        val collection = dataSource.collectionName
        val startAfterId = params.key?.id
        logger.d { "Loading data from FirestorePagingSource for $collection with loadSize: ${params.loadSize} and startAfter: $startAfterId" }
        return try {
            val query = dataSource.getQuery(params.key, params.loadSize)
            val snapshot = query.get()
            val items = snapshot.documents.mapNotNull { dataSource.transform(it) }
            val nextKey = snapshot.documents.lastOrNull()
            if (items.isEmpty()) {
                logger.w { "No items loaded for $collection (startAfter = $startAfterId). Possibly an empty collection or no more data." }
            } else {
                logger.d { "Successfully loaded ${items.size} items from $collection, next key: ${nextKey?.id}" }
            }
            LoadResult.Page(
                data = items,
                prevKey = null,
                nextKey = nextKey
            )
        } catch (e: Exception) {
            logger.e(e) { "Error loading data in FirestorePagingSource for $collection" }
            LoadResult.Error(e)
        }
    }

    override fun getRefreshKey(state: PagingState<DocumentSnapshot, T>): DocumentSnapshot? {
        logger.d { "Getting refresh key in FirestorePagingSource for ${dataSource.collectionName}" }
        return null
    }
}
// File: composeApp/src/commonMain/kotlin/com/openparty/app/features/newsfeed/shared/data/repository/FirestoreRepository.kt
package com.openparty.app.features.newsfeed.shared.data.repository

import app.cash.paging.Pager
import app.cash.paging.PagingConfig
import app.cash.paging.PagingData
import com.openparty.app.core.shared.domain.DomainResult
import com.openparty.app.core.shared.domain.error.AppError
import com.openparty.app.features.newsfeed.shared.data.datasource.FirestorePagingSource
import kotlinx.coroutines.flow.Flow
import com.openparty.app.core.shared.domain.GlobalLogger.logger
import com.openparty.app.features.newsfeed.shared.data.datasource.FirebaseNewsfeedDataSource

abstract class FirestoreRepository<T : Any>(
    private val dataSource: FirebaseNewsfeedDataSource<T>,
    private val error: AppError
) {
    fun getPagedItems(): Flow<PagingData<T>> {
        logger.d { "Fetching paged items from FirestoreRepository for ${dataSource.collectionName}" }
        return Pager(
            config = PagingConfig(
                pageSize = 10,
                enablePlaceholders = false
            ),
            pagingSourceFactory = {
                logger.d { "Creating FirestorePagingSource for ${dataSource.collectionName}" }
                FirestorePagingSource(dataSource)
            }
        ).flow
    }

    suspend fun getItemById(itemId: String): DomainResult<T> {
        logger.d { "Fetching item by ID: $itemId in FirestoreRepository for ${dataSource.collectionName}" }
        return try {
            val item = dataSource.getItemById(itemId)
            if (item != null) {
                logger.d { "Item found for ID: $itemId in ${dataSource.collectionName}" }
                DomainResult.Success(item)
            } else {
                logger.w { "Item not found for ID: $itemId in ${dataSource.collectionName}" }
                DomainResult.Failure(error)
            }
        } catch (e: Exception) {
            logger.e(e) { "Error fetching item by ID: $itemId in ${dataSource.collectionName}" }
            DomainResult.Failure(error)
        }
    }
}
// File: composeApp/src/commonMain/kotlin/com/openparty/app/features/newsfeed/shared/presentation/BaseFeedScreen.kt
package com.openparty.app.features.newsfeed.shared.presentation

import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import app.cash.paging.compose.LazyPagingItems

@Composable
fun <T : Any> BaseFeedScreen(
    items: LazyPagingItems<T>,
    emptyPlaceholder: String,
    content: @Composable (item: T?) -> Unit
) {
    if (items.itemCount == 0) {
        Box(
            modifier = Modifier.fillMaxSize(),
            contentAlignment = Alignment.Center
        ) {
            Text(text = emptyPlaceholder)
        }
    } else {
        LazyColumn {
            items(
                count = items.itemCount,
                key = { index -> items[index]?.hashCode() ?: index }
            ) { index ->
                val item = items[index]
                content(item)
            }
        }
    }
}
//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/newsfeed/discussions/feature_add_discussion/di/AddDiscussionModule.kt
package com.openparty.app.features.newsfeed.discussions.feature_add_discussion.di

import org.koin.dsl.module
import org.koin.core.module.dsl.viewModel
import com.openparty.app.features.newsfeed.discussions.feature_add_discussion.domain.usecase.AddDiscussionUseCase
import com.openparty.app.features.newsfeed.discussions.feature_add_discussion.presentation.AddDiscussionViewModel

val addDiscussionModule = module {
    single { AddDiscussionUseCase(get()) }
    viewModel { AddDiscussionViewModel(get(), get(), get()) }
}//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/newsfeed/discussions/feature_add_discussion/domain/usecase/AddDiscussionUseCase.kt
package com.openparty.app.features.newsfeed.discussions.feature_add_discussion.domain.usecase

import com.openparty.app.core.shared.domain.DomainResult
import com.openparty.app.core.shared.domain.error.AppError
import com.openparty.app.features.newsfeed.discussions.shared.domain.repository.DiscussionRepository
import com.openparty.app.features.newsfeed.discussions.shared.domain.model.Discussion
import com.openparty.app.core.shared.domain.GlobalLogger.logger

class AddDiscussionUseCase(
    private val discussionRepository: DiscussionRepository
) {
    suspend operator fun invoke(discussion: Discussion): DomainResult<Discussion> {
        logger.i { "AddDiscussionUseCase invoked with discussion: ${discussion.title}" }
        return try {
            when (val result = discussionRepository.addDiscussion(discussion)) {
                is DomainResult.Success -> {
                    logger.i { "Successfully added discussion: ${discussion.title}" }
                    DomainResult.Success(result.data)
                }
                is DomainResult.Failure -> {
                    logger.e { "Failed to add discussion: ${discussion.title}, Error: ${result.error}" }
                    DomainResult.Failure(result.error)
                }
            }
        } catch (e: Exception) {
            logger.e(e) { "Unexpected error while adding discussion: ${discussion.title}" }
            DomainResult.Failure(AppError.Discussion.AddDiscussion)
        }
    }
}
//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/newsfeed/discussions/feature_add_discussion/presentation/components/AddDiscussionUiState.kt
package com.openparty.app.features.newsfeed.discussions.feature_add_discussion.presentation.components

import androidx.compose.ui.text.input.TextFieldValue

data class AddDiscussionUiState(
    val title: TextFieldValue = TextFieldValue(""),
    val contentText: TextFieldValue = TextFieldValue(""),
    val errorMessage: String = "",
    val isLoading: Boolean = false
)
//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/newsfeed/discussions/feature_add_discussion/presentation/AddDiscussionButton.kt
package com.openparty.app.features.newsfeed.discussions.feature_add_discussion.presentation

import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.material3.FloatingActionButton
import androidx.compose.material3.Icon
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material3.MaterialTheme

@Composable
fun AddDiscussionButton(
    onClick: () -> Unit
) {
    Box(
        modifier = Modifier
            .fillMaxSize(),
        contentAlignment = Alignment.BottomCenter
    ) {
        FloatingActionButton(
            onClick = onClick,
            shape = CircleShape,
            containerColor = MaterialTheme.colorScheme.primary,
            modifier = Modifier
                .padding(bottom = 32.dp)
                .size(90.dp)
        ) {
            Icon(
                imageVector = Icons.Default.Add,
                contentDescription = "Create Discussion",
                modifier = Modifier.size(45.dp)
            )
        }
    }
}
//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/newsfeed/discussions/feature_add_discussion/presentation/AddDiscussionScreen.kt
package com.openparty.app.features.newsfeed.discussions.feature_add_discussion.presentation

import androidx.compose.foundation.layout.*
import androidx.compose.runtime.Composable
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import org.koin.compose.viewmodel.koinViewModel
import androidx.navigation.NavController
import com.openparty.app.core.shared.presentation.BodyTextInput
import com.openparty.app.core.shared.presentation.ErrorText
import com.openparty.app.core.shared.presentation.UiEvent
import kotlinx.coroutines.flow.collectLatest
import com.openparty.app.core.shared.presentation.TopContainer

@Composable
fun AddDiscussionScreen(
    navController: NavController,
    viewModel: AddDiscussionViewModel = koinViewModel()
) {
    val uiState by viewModel.uiState.collectAsState()

    LaunchedEffect(viewModel.uiEvent) {
        viewModel.uiEvent.collectLatest { event ->
            when (event) {
                is UiEvent.Navigate -> {
                    if (event.destination == "back") {
                        navController.popBackStack()
                    } else {
                        navController.navigate(event.destination)
                    }
                }
            }
        }
    }

    ErrorText(uiState.errorMessage)

    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp)
    ) {
        TopContainer(
            headerText = "Add Discussion",
            onBackClicked = { viewModel.onBackClicked() },
            onPostClicked = { viewModel.onPostClicked() }
        )


        Spacer(modifier = Modifier.height(16.dp))

        BodyTextInput(
            textFieldValue = uiState.title,
            onTextChange = { viewModel.onTitleTextChanged(it) },
            placeholderText = "Title..."
        )

        Spacer(modifier = Modifier.height(16.dp))

        BodyTextInput(
            textFieldValue = uiState.contentText,
            onTextChange = { viewModel.onContentTextChanged(it) },
            placeholderText = "Main Text..."
        )
    }
}
//File: composeApp/src/commonMain/kotlin/com/openparty/app/features/newsfeed/discussions/feature_add_discussion/presentation/AddDiscussionViewModel.kt
package com.openparty.app.features.newsfeed.discussions.feature_add_discussion.presentation

import androidx.compose.ui.text.input.TextFieldValue
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import dev.gitlive.firebase.firestore.Timestamp
import com.openparty.app.core.analytics.domain.usecase.TrackDiscussionPostedUseCase
import com.openparty.app.core.shared.domain.DomainResult
import com.openparty.app.core.shared.domain.error.AppErrorMapper
import com.openparty.app.core.shared.presentation.UiEvent
import com.openparty.app.features.newsfeed.discussions.feature_add_discussion.domain.usecase.AddDiscussionUseCase
import com.openparty.app.features.newsfeed.discussions.feature_add_discussion.presentation.components.AddDiscussionUiState
import com.openparty.app.features.newsfeed.discussions.shared.domain.model.Discussion
import com.openparty.app.features.startup.feature_authentication.domain.usecase.GetCurrentUserIdUseCase
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.SharedFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch
import com.openparty.app.core.shared.domain.GlobalLogger.logger
import com.openparty.app.navigation.Screen

class AddDiscussionViewModel(
    private val addDiscussionUseCase: AddDiscussionUseCase,
    private val trackDiscussionPostedUseCase: TrackDiscussionPostedUseCase,
    private val getCurrentUserIdUseCase: GetCurrentUserIdUseCase
) : ViewModel() {

    private val _uiState = MutableStateFlow(AddDiscussionUiState())
    val uiState: StateFlow<AddDiscussionUiState> = _uiState

    private val _uiEvent = MutableSharedFlow<UiEvent>()
    val uiEvent: SharedFlow<UiEvent> = _uiEvent

    private val _currentUserId = MutableStateFlow<String?>(null)

    init {
        loadCurrentUserId()
    }

    private fun loadCurrentUserId() {
        viewModelScope.launch {
            when (val result = getCurrentUserIdUseCase()) {
                is DomainResult.Success -> {
                    _currentUserId.value = result.data
                    logger.i { "Fetched current user id: ${result.data}" }
                }
                is DomainResult.Failure -> {
                    val errorMessage = AppErrorMapper.getUserFriendlyMessage(result.error)
                    logger.e(result.error) { "Error fetching current user id: $errorMessage" }
                }
            }
        }
    }

    fun onTitleTextChanged(newText: TextFieldValue) {
        updateUiState(title = newText)
    }

    fun onContentTextChanged(newText: TextFieldValue) {
        updateUiState(contentText = newText)
    }

    fun onBackClicked() {
        emitUiEvent(UiEvent.Navigate("back"))
    }

    fun onPostClicked() {
        val currentState = _uiState.value
        if (isInputValid(currentState)) {
            val discussion = createDiscussionFromState(currentState)
            postDiscussion(discussion)
        } else {
            updateUiState(errorMessage = "Title and content cannot be empty")
        }
    }

    private fun createDiscussionFromState(state: AddDiscussionUiState): Discussion {
        return Discussion(
            discussionId = "",
            userId = _currentUserId.value ?: "",
            title = state.title.text,
            contentText = state.contentText.text,
            timestamp = Timestamp.now(),
            upvoteCount = 0,
            downvoteCount = 0,
            commentCount = 0
        )
    }

    private fun postDiscussion(discussion: Discussion) {
        viewModelScope.launch {
            updateUiState(isLoading = true)
            when (val result = addDiscussionUseCase(discussion)) {
                is DomainResult.Success -> {
                    val addedDiscussion = result.data
                    val discussionId = addedDiscussion.discussionId
                    val title = addedDiscussion.title
                    trackDiscussionPosted(discussionId, title)
                    emitUiEvent(UiEvent.Navigate(Screen.DiscussionsPreview.route))
                    resetUiState()
                }
                is DomainResult.Failure -> {
                    val errorMessage = AppErrorMapper.getUserFriendlyMessage(result.error)
                    updateUiState(isLoading = false, errorMessage = errorMessage)
                }
            }
        }
    }

    private suspend fun trackDiscussionPosted(discussionId: String, title: String) {
        when (val result = trackDiscussionPostedUseCase(discussionId, title)) {
            is DomainResult.Success -> logger.i { "Discussion posted event tracked: $discussionId" }
            is DomainResult.Failure -> logger.e { "Failed to track discussion posted event for ID: $discussionId" }
        }
    }

    private fun updateUiState(
        title: TextFieldValue? = null,
        contentText: TextFieldValue? = null,
        isLoading: Boolean? = null,
        errorMessage: String? = null
    ) {
        val currentState = _uiState.value
        _uiState.value = currentState.copy(
            title = title ?: currentState.title,
            contentText = contentText ?: currentState.contentText,
            isLoading = isLoading ?: currentState.isLoading,
            errorMessage = errorMessage ?: currentState.errorMessage
        )
    }

    private fun resetUiState() {
        _uiState.value = AddDiscussionUiState()
    }

    private fun emitUiEvent(event: UiEvent) {
        viewModelScope.launch {
            _uiEvent.emit(event)
        }
    }

    private fun isInputValid(state: AddDiscussionUiState): Boolean {
        return state.title.text.isNotBlank() && state.contentText.text.isNotBlank()
    }
}




---------

Notes: 
- When you give code, give the entire file, don't abbreviate anything
- Don't leave comments in the code, except a comment at a top of the file stating the file path
    - e.g. //File: composeApp/src/androidMain/kotlin/com/openparty/app/main/MainViewModel.kt
- Use the cleanest, most robust, scalable architecture you can 
- For every gradle dependency, give it in this format: implementation("org.jetbrains.androidx.lifecycle:lifecycle-viewmodel-compose:2.8.2")
    - don't give it in the libs.version.toml format. i.e. don't do this - implementation(compose.components.uiToolingPreview)
    - The exception to this is the dependencies that are already in my gradle files, leave them in the original format
- I'm using koin compose multiplatform for my depedency injection, that means that in my screen classes, I use this import - import org.koin.compose.viewmodel.koinViewModel
    - And the view model is injected like this - viewModel: DiscussionArticleViewModel = koinViewModel()
    - This might look odd to you since it's a new approach but don't change it, assume it's correct 
- Keep all business logic in use cases where appropriate 
- Whenenever you use use cases, return the DomainResult Success or Failure 
- Add Kermit logs where appropriate 
- Whenever you call a use case (for example in the view model), handle the DomainResult.Success or Failure case and use this: val errorMessage = AppErrorMapper.getUserFriendlyMessage(result.error) - to return a friendly error to the user
- Whenever you use a library in commonMain code, make sure that it's a library that's compatible with compose multiplatform

---------

i've given you my feature discussions preview code above 

Right now, on each discussions card, there is a menu that when opened allows the user to block other users or to hide content

I want to add an option to this menu called "Report" 

this should be under a report feature - feature_report - located here - //File: composeApp/src/commonMain/kotlin/com/openparty/app/features/utils/feature_report

When the "Report" option is clicked in the discussions card, it should open a new bottom sheet called ReportMenu (which will be in feature_report) 

ReportMenu has these features: 
- A title that says "Submit a Report" 
- A "X" in the top left hand corner that, when clicked, closes the report menu 
- Under the title - a list of possible options
    - This is the list - Harassment, Threatening violence, Hate, Minor aubse or sexualisation, Sharing personal information, spam
    - Each item in the list is initially greyed out
    - When the user clicks an item, it turns to a highlight colour
    - When the user clicks the item again, it becomes greyed out again 
- A submit button at the bottom
    - When the user has not selected an item from the list, the submit button should not appear
    - When the user has selected an item,, the submit button appears
    - When the user deselects all items, the submit button disappears 
- When the user clicks submit, it persists the report to the firebase database
- The report object should look like this: 
        Report ID
        Discussion ID (foreign key)
        Reporter User ID
        Report Reason (and additional comments)
        Timestamp
        Status (e.g., Pending, Reviewed, Dismissed)
- Also add a "reportCount" field to the Discussion data class
    - reportCount should be initialised to zero when a discussion is added, then iterated every time a report is submitted
    - Right now the reportCount is not set to zero when a discussion is added, so you'll need to add that functionality 
- Once the user has submitted the report, the reportMenu should close
- Remember that all this code should be in its own feature - feature_report
    - Ideally i just want the reportMenu composable to be called from the discussions preview screen (or discussions card if that's better architecture) when necessary, but have all the other code be in its own feature

I asked another AI for advice on this feature and it said the following. If it has any good suggestions that i missed out then just add them: 



The overall approach is to break the feature into two parts: the client‐side UI component and the backend report service. Both parts should be designed with modularity, scalability, and security in mind. Here’s a breakdown:

---

### Frontend (Client-Side)

1. **Card Component Structure:**
   - Each discussion card is a reusable component. In its header (top right), include a settings icon.
   - When clicked, this icon triggers a dropdown or modal that displays options (e.g. “Report Discussion”).

2. **Report UI Flow:**
   - **User Interaction:** The user selects “Report Discussion,” which then opens a report form/modal where the user can optionally select a reason from a list and/or enter additional comments.
   - **State Management:** Use a centralized state (via Redux, Context API, or similar) if needed, so that the UI remains responsive and errors can be handled (e.g., showing a confirmation or error message).

3. **Asynchronous Request:**
   - When the user submits the report, the front-end makes an asynchronous HTTP POST request to the backend API (e.g., `/api/reports`).
   - The payload should include at least the discussion ID, reporter user ID, report reason, and a timestamp (the latter could also be set on the server).

---

### Backend (Server-Side)

1. **API Endpoint:**
   - Expose a secure REST API endpoint (e.g., `POST /api/reports`) that accepts report data.
   - Authenticate the request to ensure only logged-in users can report.

2. **Data Model:**
   - Create a “Report” entity/table with fields such as:
     - Report ID
     - Discussion ID (foreign key)
     - Reporter User ID
     - Report Reason (and additional comments)
     - Timestamp
     - Status (e.g., Pending, Reviewed, Dismissed)
   - Optionally, maintain a count or aggregated score on the discussion for automatic flagging if multiple reports are received.

3. **Processing Reports:**
   - **Immediate Storage:** On receipt, validate and sanitize the input and immediately store the report in your database.
   - **Moderation Workflow:** Optionally push the report onto a message queue or flag the discussion if it exceeds a threshold so that a moderation service (manual or automated) can review it.
   - **Asynchronous Notifications:** Use asynchronous processing (like a background job or message queue) to notify moderators or update the discussion status without delaying the user’s experience.

4. **Security and Abuse Prevention:**
   - Implement rate limiting and input validation to prevent abuse.
   - Log all report submissions for audit purposes.

---

### Integration and Modularity

- **Separation of Concerns:** The report functionality should be implemented as a discrete module or microservice if scaling becomes an issue. The UI simply calls a well-defined API, and the report service handles storage and moderation logic.
- **Error Handling:** Both the front-end and backend should gracefully handle errors (e.g., network issues, invalid inputs) and provide meaningful feedback to the user.
- **Extensibility:** Design the system so that additional reporting reasons, automated flags, or integration with moderation dashboards can be added without major refactoring.

---

### Example Flow

1. **User Interaction:** A user clicks the settings icon on a discussion card and selects “Report.”
2. **Report Form:** A modal appears where the user selects a reason (“Spam,” “Harassment,” etc.) and optionally writes a comment.
3. **API Call:** On form submission, the UI sends a POST request to `/api/reports` with the discussion ID, user ID, and report details.
4. **Backend Processing:** The backend validates and saves the report, optionally updates the discussion’s report count, and pushes a message to a queue if the report count exceeds a threshold.
5. **Feedback:** The UI receives a confirmation response and informs the user that the report has been submitted.

---

This layered architecture keeps the UI responsive while delegating the heavier moderation logic to a backend service, ensuring that the reporting functionality is both robust and scalable—similar to how Reddit and other platforms handle user reports.

This design approach provides clear separation between presentation and business logic, making it easier to maintain, test, and scale as the application grows.